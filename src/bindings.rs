/* automatically generated by rust-bindgen 0.69.1 */

#[doc = " @defgroup LLVMCSupportTypes Types and Enumerations\n\n @{"]
pub type LLVMBool = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueMemoryBuffer {
    _unused: [u8; 0],
}
#[doc = " Used to pass regions of memory through LLVM interfaces.\n\n @see llvm::MemoryBuffer"]
pub type LLVMMemoryBufferRef = *mut LLVMOpaqueMemoryBuffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueContext {
    _unused: [u8; 0],
}
#[doc = " The top-level container for all LLVM global data. See the LLVMContext class."]
pub type LLVMContextRef = *mut LLVMOpaqueContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueModule {
    _unused: [u8; 0],
}
#[doc = " The top-level container for all other LLVM Intermediate Representation (IR)\n objects.\n\n @see llvm::Module"]
pub type LLVMModuleRef = *mut LLVMOpaqueModule;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueType {
    _unused: [u8; 0],
}
#[doc = " Each value in the LLVM IR has a type, an LLVMTypeRef.\n\n @see llvm::Type"]
pub type LLVMTypeRef = *mut LLVMOpaqueType;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueValue {
    _unused: [u8; 0],
}
#[doc = " Represents an individual value in LLVM IR.\n\n This models llvm::Value."]
pub type LLVMValueRef = *mut LLVMOpaqueValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueBasicBlock {
    _unused: [u8; 0],
}
#[doc = " Represents a basic block of instructions in LLVM IR.\n\n This models llvm::BasicBlock."]
pub type LLVMBasicBlockRef = *mut LLVMOpaqueBasicBlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueMetadata {
    _unused: [u8; 0],
}
#[doc = " Represents an LLVM Metadata.\n\n This models llvm::Metadata."]
pub type LLVMMetadataRef = *mut LLVMOpaqueMetadata;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueNamedMDNode {
    _unused: [u8; 0],
}
#[doc = " Represents an LLVM Named Metadata Node.\n\n This models llvm::NamedMDNode."]
pub type LLVMNamedMDNodeRef = *mut LLVMOpaqueNamedMDNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueValueMetadataEntry {
    _unused: [u8; 0],
}
#[doc = " Represents an entry in a Global Object's metadata attachments.\n\n This models std::pair<unsigned, MDNode *>"]
pub type LLVMValueMetadataEntry = LLVMOpaqueValueMetadataEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueBuilder {
    _unused: [u8; 0],
}
#[doc = " Represents an LLVM basic block builder.\n\n This models llvm::IRBuilder."]
pub type LLVMBuilderRef = *mut LLVMOpaqueBuilder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueDIBuilder {
    _unused: [u8; 0],
}
#[doc = " Represents an LLVM debug info builder.\n\n This models llvm::DIBuilder."]
pub type LLVMDIBuilderRef = *mut LLVMOpaqueDIBuilder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueModuleProvider {
    _unused: [u8; 0],
}
#[doc = " Interface used to provide a module to JIT or interpreter.\n This is now just a synonym for llvm::Module, but we have to keep using the\n different type to keep binary compatibility."]
pub type LLVMModuleProviderRef = *mut LLVMOpaqueModuleProvider;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaquePassManager {
    _unused: [u8; 0],
}
#[doc = " @see llvm::PassManagerBase"]
pub type LLVMPassManagerRef = *mut LLVMOpaquePassManager;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueUse {
    _unused: [u8; 0],
}
#[doc = " Used to get the users and usees of a Value.\n\n @see llvm::Use"]
pub type LLVMUseRef = *mut LLVMOpaqueUse;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueAttributeRef {
    _unused: [u8; 0],
}
#[doc = " Used to represent an attributes.\n\n @see llvm::Attribute"]
pub type LLVMAttributeRef = *mut LLVMOpaqueAttributeRef;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueDiagnosticInfo {
    _unused: [u8; 0],
}
#[doc = " @see llvm::DiagnosticInfo"]
pub type LLVMDiagnosticInfoRef = *mut LLVMOpaqueDiagnosticInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMComdat {
    _unused: [u8; 0],
}
#[doc = " @see llvm::Comdat"]
pub type LLVMComdatRef = *mut LLVMComdat;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueModuleFlagEntry {
    _unused: [u8; 0],
}
#[doc = " @see llvm::Module::ModuleFlagEntry"]
pub type LLVMModuleFlagEntry = LLVMOpaqueModuleFlagEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueJITEventListener {
    _unused: [u8; 0],
}
#[doc = " @see llvm::JITEventListener"]
pub type LLVMJITEventListenerRef = *mut LLVMOpaqueJITEventListener;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueBinary {
    _unused: [u8; 0],
}
#[doc = " @see llvm::object::Binary"]
pub type LLVMBinaryRef = *mut LLVMOpaqueBinary;
pub const LLVMVerifierFailureAction_LLVMAbortProcessAction: LLVMVerifierFailureAction = 0;
pub const LLVMVerifierFailureAction_LLVMPrintMessageAction: LLVMVerifierFailureAction = 1;
pub const LLVMVerifierFailureAction_LLVMReturnStatusAction: LLVMVerifierFailureAction = 2;
#[doc = " @defgroup LLVMCAnalysis Analysis\n @ingroup LLVMC\n\n @{"]
pub type LLVMVerifierFailureAction = ::std::os::raw::c_int;
#[doc = "< The linker may choose any COMDAT."]
pub const LLVMComdatSelectionKind_LLVMAnyComdatSelectionKind: LLVMComdatSelectionKind = 0;
#[doc = "< The data referenced by the COMDAT must\n< be the same."]
pub const LLVMComdatSelectionKind_LLVMExactMatchComdatSelectionKind: LLVMComdatSelectionKind = 1;
#[doc = "< The linker will choose the largest\n< COMDAT."]
pub const LLVMComdatSelectionKind_LLVMLargestComdatSelectionKind: LLVMComdatSelectionKind = 2;
#[doc = "< No deduplication is performed."]
pub const LLVMComdatSelectionKind_LLVMNoDeduplicateComdatSelectionKind: LLVMComdatSelectionKind = 3;
#[doc = "< The data referenced by the COMDAT must be\n< the same size."]
pub const LLVMComdatSelectionKind_LLVMSameSizeComdatSelectionKind: LLVMComdatSelectionKind = 4;
#[doc = " @defgroup LLVMCCoreComdat Comdats\n @ingroup LLVMCCore\n\n @{"]
pub type LLVMComdatSelectionKind = ::std::os::raw::c_int;
#[doc = " @addtogroup LLVMCError\n\n @{"]
pub type LLVMFatalErrorHandler =
    ::std::option::Option<unsafe extern "C" fn(Reason: *const ::std::os::raw::c_char)>;
pub const LLVMOpcode_LLVMRet: LLVMOpcode = 1;
pub const LLVMOpcode_LLVMBr: LLVMOpcode = 2;
pub const LLVMOpcode_LLVMSwitch: LLVMOpcode = 3;
pub const LLVMOpcode_LLVMIndirectBr: LLVMOpcode = 4;
pub const LLVMOpcode_LLVMInvoke: LLVMOpcode = 5;
pub const LLVMOpcode_LLVMUnreachable: LLVMOpcode = 7;
pub const LLVMOpcode_LLVMCallBr: LLVMOpcode = 67;
pub const LLVMOpcode_LLVMFNeg: LLVMOpcode = 66;
pub const LLVMOpcode_LLVMAdd: LLVMOpcode = 8;
pub const LLVMOpcode_LLVMFAdd: LLVMOpcode = 9;
pub const LLVMOpcode_LLVMSub: LLVMOpcode = 10;
pub const LLVMOpcode_LLVMFSub: LLVMOpcode = 11;
pub const LLVMOpcode_LLVMMul: LLVMOpcode = 12;
pub const LLVMOpcode_LLVMFMul: LLVMOpcode = 13;
pub const LLVMOpcode_LLVMUDiv: LLVMOpcode = 14;
pub const LLVMOpcode_LLVMSDiv: LLVMOpcode = 15;
pub const LLVMOpcode_LLVMFDiv: LLVMOpcode = 16;
pub const LLVMOpcode_LLVMURem: LLVMOpcode = 17;
pub const LLVMOpcode_LLVMSRem: LLVMOpcode = 18;
pub const LLVMOpcode_LLVMFRem: LLVMOpcode = 19;
pub const LLVMOpcode_LLVMShl: LLVMOpcode = 20;
pub const LLVMOpcode_LLVMLShr: LLVMOpcode = 21;
pub const LLVMOpcode_LLVMAShr: LLVMOpcode = 22;
pub const LLVMOpcode_LLVMAnd: LLVMOpcode = 23;
pub const LLVMOpcode_LLVMOr: LLVMOpcode = 24;
pub const LLVMOpcode_LLVMXor: LLVMOpcode = 25;
pub const LLVMOpcode_LLVMAlloca: LLVMOpcode = 26;
pub const LLVMOpcode_LLVMLoad: LLVMOpcode = 27;
pub const LLVMOpcode_LLVMStore: LLVMOpcode = 28;
pub const LLVMOpcode_LLVMGetElementPtr: LLVMOpcode = 29;
pub const LLVMOpcode_LLVMTrunc: LLVMOpcode = 30;
pub const LLVMOpcode_LLVMZExt: LLVMOpcode = 31;
pub const LLVMOpcode_LLVMSExt: LLVMOpcode = 32;
pub const LLVMOpcode_LLVMFPToUI: LLVMOpcode = 33;
pub const LLVMOpcode_LLVMFPToSI: LLVMOpcode = 34;
pub const LLVMOpcode_LLVMUIToFP: LLVMOpcode = 35;
pub const LLVMOpcode_LLVMSIToFP: LLVMOpcode = 36;
pub const LLVMOpcode_LLVMFPTrunc: LLVMOpcode = 37;
pub const LLVMOpcode_LLVMFPExt: LLVMOpcode = 38;
pub const LLVMOpcode_LLVMPtrToInt: LLVMOpcode = 39;
pub const LLVMOpcode_LLVMIntToPtr: LLVMOpcode = 40;
pub const LLVMOpcode_LLVMBitCast: LLVMOpcode = 41;
pub const LLVMOpcode_LLVMAddrSpaceCast: LLVMOpcode = 60;
pub const LLVMOpcode_LLVMICmp: LLVMOpcode = 42;
pub const LLVMOpcode_LLVMFCmp: LLVMOpcode = 43;
pub const LLVMOpcode_LLVMPHI: LLVMOpcode = 44;
pub const LLVMOpcode_LLVMCall: LLVMOpcode = 45;
pub const LLVMOpcode_LLVMSelect: LLVMOpcode = 46;
pub const LLVMOpcode_LLVMUserOp1: LLVMOpcode = 47;
pub const LLVMOpcode_LLVMUserOp2: LLVMOpcode = 48;
pub const LLVMOpcode_LLVMVAArg: LLVMOpcode = 49;
pub const LLVMOpcode_LLVMExtractElement: LLVMOpcode = 50;
pub const LLVMOpcode_LLVMInsertElement: LLVMOpcode = 51;
pub const LLVMOpcode_LLVMShuffleVector: LLVMOpcode = 52;
pub const LLVMOpcode_LLVMExtractValue: LLVMOpcode = 53;
pub const LLVMOpcode_LLVMInsertValue: LLVMOpcode = 54;
pub const LLVMOpcode_LLVMFreeze: LLVMOpcode = 68;
pub const LLVMOpcode_LLVMFence: LLVMOpcode = 55;
pub const LLVMOpcode_LLVMAtomicCmpXchg: LLVMOpcode = 56;
pub const LLVMOpcode_LLVMAtomicRMW: LLVMOpcode = 57;
pub const LLVMOpcode_LLVMResume: LLVMOpcode = 58;
pub const LLVMOpcode_LLVMLandingPad: LLVMOpcode = 59;
pub const LLVMOpcode_LLVMCleanupRet: LLVMOpcode = 61;
pub const LLVMOpcode_LLVMCatchRet: LLVMOpcode = 62;
pub const LLVMOpcode_LLVMCatchPad: LLVMOpcode = 63;
pub const LLVMOpcode_LLVMCleanupPad: LLVMOpcode = 64;
pub const LLVMOpcode_LLVMCatchSwitch: LLVMOpcode = 65;
#[doc = " External users depend on the following values being stable. It is not safe\n to reorder them."]
pub type LLVMOpcode = ::std::os::raw::c_int;
#[doc = "< type with no size"]
pub const LLVMTypeKind_LLVMVoidTypeKind: LLVMTypeKind = 0;
#[doc = "< 16 bit floating point type"]
pub const LLVMTypeKind_LLVMHalfTypeKind: LLVMTypeKind = 1;
#[doc = "< 32 bit floating point type"]
pub const LLVMTypeKind_LLVMFloatTypeKind: LLVMTypeKind = 2;
#[doc = "< 64 bit floating point type"]
pub const LLVMTypeKind_LLVMDoubleTypeKind: LLVMTypeKind = 3;
#[doc = "< 80 bit floating point type (X87)"]
pub const LLVMTypeKind_LLVMX86_FP80TypeKind: LLVMTypeKind = 4;
#[doc = "< 128 bit floating point type (112-bit mantissa)"]
pub const LLVMTypeKind_LLVMFP128TypeKind: LLVMTypeKind = 5;
#[doc = "< 128 bit floating point type (two 64-bits)"]
pub const LLVMTypeKind_LLVMPPC_FP128TypeKind: LLVMTypeKind = 6;
#[doc = "< Labels"]
pub const LLVMTypeKind_LLVMLabelTypeKind: LLVMTypeKind = 7;
#[doc = "< Arbitrary bit width integers"]
pub const LLVMTypeKind_LLVMIntegerTypeKind: LLVMTypeKind = 8;
#[doc = "< Functions"]
pub const LLVMTypeKind_LLVMFunctionTypeKind: LLVMTypeKind = 9;
#[doc = "< Structures"]
pub const LLVMTypeKind_LLVMStructTypeKind: LLVMTypeKind = 10;
#[doc = "< Arrays"]
pub const LLVMTypeKind_LLVMArrayTypeKind: LLVMTypeKind = 11;
#[doc = "< Pointers"]
pub const LLVMTypeKind_LLVMPointerTypeKind: LLVMTypeKind = 12;
#[doc = "< Fixed width SIMD vector type"]
pub const LLVMTypeKind_LLVMVectorTypeKind: LLVMTypeKind = 13;
#[doc = "< Metadata"]
pub const LLVMTypeKind_LLVMMetadataTypeKind: LLVMTypeKind = 14;
#[doc = "< X86 MMX"]
pub const LLVMTypeKind_LLVMX86_MMXTypeKind: LLVMTypeKind = 15;
#[doc = "< Tokens"]
pub const LLVMTypeKind_LLVMTokenTypeKind: LLVMTypeKind = 16;
#[doc = "< Scalable SIMD vector type"]
pub const LLVMTypeKind_LLVMScalableVectorTypeKind: LLVMTypeKind = 17;
#[doc = "< 16 bit brain floating point type"]
pub const LLVMTypeKind_LLVMBFloatTypeKind: LLVMTypeKind = 18;
#[doc = "< X86 AMX"]
pub const LLVMTypeKind_LLVMX86_AMXTypeKind: LLVMTypeKind = 19;
#[doc = "< Target extension type"]
pub const LLVMTypeKind_LLVMTargetExtTypeKind: LLVMTypeKind = 20;
pub type LLVMTypeKind = ::std::os::raw::c_int;
#[doc = "< Externally visible function"]
pub const LLVMLinkage_LLVMExternalLinkage: LLVMLinkage = 0;
pub const LLVMLinkage_LLVMAvailableExternallyLinkage: LLVMLinkage = 1;
#[doc = "< Keep one copy of function when linking (inline)"]
pub const LLVMLinkage_LLVMLinkOnceAnyLinkage: LLVMLinkage = 2;
#[doc = "< Same, but only replaced by something\nequivalent."]
pub const LLVMLinkage_LLVMLinkOnceODRLinkage: LLVMLinkage = 3;
#[doc = "< Obsolete"]
pub const LLVMLinkage_LLVMLinkOnceODRAutoHideLinkage: LLVMLinkage = 4;
#[doc = "< Keep one copy of function when linking (weak)"]
pub const LLVMLinkage_LLVMWeakAnyLinkage: LLVMLinkage = 5;
#[doc = "< Same, but only replaced by something\nequivalent."]
pub const LLVMLinkage_LLVMWeakODRLinkage: LLVMLinkage = 6;
#[doc = "< Special purpose, only applies to global arrays"]
pub const LLVMLinkage_LLVMAppendingLinkage: LLVMLinkage = 7;
#[doc = "< Rename collisions when linking (static\nfunctions)"]
pub const LLVMLinkage_LLVMInternalLinkage: LLVMLinkage = 8;
#[doc = "< Like Internal, but omit from symbol table"]
pub const LLVMLinkage_LLVMPrivateLinkage: LLVMLinkage = 9;
#[doc = "< Obsolete"]
pub const LLVMLinkage_LLVMDLLImportLinkage: LLVMLinkage = 10;
#[doc = "< Obsolete"]
pub const LLVMLinkage_LLVMDLLExportLinkage: LLVMLinkage = 11;
#[doc = "< ExternalWeak linkage description"]
pub const LLVMLinkage_LLVMExternalWeakLinkage: LLVMLinkage = 12;
#[doc = "< Obsolete"]
pub const LLVMLinkage_LLVMGhostLinkage: LLVMLinkage = 13;
#[doc = "< Tentative definitions"]
pub const LLVMLinkage_LLVMCommonLinkage: LLVMLinkage = 14;
#[doc = "< Like Private, but linker removes."]
pub const LLVMLinkage_LLVMLinkerPrivateLinkage: LLVMLinkage = 15;
#[doc = "< Like LinkerPrivate, but is weak."]
pub const LLVMLinkage_LLVMLinkerPrivateWeakLinkage: LLVMLinkage = 16;
pub type LLVMLinkage = ::std::os::raw::c_int;
#[doc = "< The GV is visible"]
pub const LLVMVisibility_LLVMDefaultVisibility: LLVMVisibility = 0;
#[doc = "< The GV is hidden"]
pub const LLVMVisibility_LLVMHiddenVisibility: LLVMVisibility = 1;
#[doc = "< The GV is protected"]
pub const LLVMVisibility_LLVMProtectedVisibility: LLVMVisibility = 2;
pub type LLVMVisibility = ::std::os::raw::c_int;
#[doc = "< Address of the GV is significant."]
pub const LLVMUnnamedAddr_LLVMNoUnnamedAddr: LLVMUnnamedAddr = 0;
#[doc = "< Address of the GV is locally insignificant."]
pub const LLVMUnnamedAddr_LLVMLocalUnnamedAddr: LLVMUnnamedAddr = 1;
#[doc = "< Address of the GV is globally insignificant."]
pub const LLVMUnnamedAddr_LLVMGlobalUnnamedAddr: LLVMUnnamedAddr = 2;
pub type LLVMUnnamedAddr = ::std::os::raw::c_int;
pub const LLVMDLLStorageClass_LLVMDefaultStorageClass: LLVMDLLStorageClass = 0;
#[doc = "< Function to be imported from DLL."]
pub const LLVMDLLStorageClass_LLVMDLLImportStorageClass: LLVMDLLStorageClass = 1;
#[doc = "< Function to be accessible from DLL."]
pub const LLVMDLLStorageClass_LLVMDLLExportStorageClass: LLVMDLLStorageClass = 2;
pub type LLVMDLLStorageClass = ::std::os::raw::c_int;
pub const LLVMValueKind_LLVMArgumentValueKind: LLVMValueKind = 0;
pub const LLVMValueKind_LLVMBasicBlockValueKind: LLVMValueKind = 1;
pub const LLVMValueKind_LLVMMemoryUseValueKind: LLVMValueKind = 2;
pub const LLVMValueKind_LLVMMemoryDefValueKind: LLVMValueKind = 3;
pub const LLVMValueKind_LLVMMemoryPhiValueKind: LLVMValueKind = 4;
pub const LLVMValueKind_LLVMFunctionValueKind: LLVMValueKind = 5;
pub const LLVMValueKind_LLVMGlobalAliasValueKind: LLVMValueKind = 6;
pub const LLVMValueKind_LLVMGlobalIFuncValueKind: LLVMValueKind = 7;
pub const LLVMValueKind_LLVMGlobalVariableValueKind: LLVMValueKind = 8;
pub const LLVMValueKind_LLVMBlockAddressValueKind: LLVMValueKind = 9;
pub const LLVMValueKind_LLVMConstantExprValueKind: LLVMValueKind = 10;
pub const LLVMValueKind_LLVMConstantArrayValueKind: LLVMValueKind = 11;
pub const LLVMValueKind_LLVMConstantStructValueKind: LLVMValueKind = 12;
pub const LLVMValueKind_LLVMConstantVectorValueKind: LLVMValueKind = 13;
pub const LLVMValueKind_LLVMUndefValueValueKind: LLVMValueKind = 14;
pub const LLVMValueKind_LLVMConstantAggregateZeroValueKind: LLVMValueKind = 15;
pub const LLVMValueKind_LLVMConstantDataArrayValueKind: LLVMValueKind = 16;
pub const LLVMValueKind_LLVMConstantDataVectorValueKind: LLVMValueKind = 17;
pub const LLVMValueKind_LLVMConstantIntValueKind: LLVMValueKind = 18;
pub const LLVMValueKind_LLVMConstantFPValueKind: LLVMValueKind = 19;
pub const LLVMValueKind_LLVMConstantPointerNullValueKind: LLVMValueKind = 20;
pub const LLVMValueKind_LLVMConstantTokenNoneValueKind: LLVMValueKind = 21;
pub const LLVMValueKind_LLVMMetadataAsValueValueKind: LLVMValueKind = 22;
pub const LLVMValueKind_LLVMInlineAsmValueKind: LLVMValueKind = 23;
pub const LLVMValueKind_LLVMInstructionValueKind: LLVMValueKind = 24;
pub const LLVMValueKind_LLVMPoisonValueValueKind: LLVMValueKind = 25;
pub const LLVMValueKind_LLVMConstantTargetNoneValueKind: LLVMValueKind = 26;
pub type LLVMValueKind = ::std::os::raw::c_int;
#[doc = "< equal"]
pub const LLVMIntPredicate_LLVMIntEQ: LLVMIntPredicate = 32;
#[doc = "< not equal"]
pub const LLVMIntPredicate_LLVMIntNE: LLVMIntPredicate = 33;
#[doc = "< unsigned greater than"]
pub const LLVMIntPredicate_LLVMIntUGT: LLVMIntPredicate = 34;
#[doc = "< unsigned greater or equal"]
pub const LLVMIntPredicate_LLVMIntUGE: LLVMIntPredicate = 35;
#[doc = "< unsigned less than"]
pub const LLVMIntPredicate_LLVMIntULT: LLVMIntPredicate = 36;
#[doc = "< unsigned less or equal"]
pub const LLVMIntPredicate_LLVMIntULE: LLVMIntPredicate = 37;
#[doc = "< signed greater than"]
pub const LLVMIntPredicate_LLVMIntSGT: LLVMIntPredicate = 38;
#[doc = "< signed greater or equal"]
pub const LLVMIntPredicate_LLVMIntSGE: LLVMIntPredicate = 39;
#[doc = "< signed less than"]
pub const LLVMIntPredicate_LLVMIntSLT: LLVMIntPredicate = 40;
#[doc = "< signed less or equal"]
pub const LLVMIntPredicate_LLVMIntSLE: LLVMIntPredicate = 41;
pub type LLVMIntPredicate = ::std::os::raw::c_int;
#[doc = "< Always false (always folded)"]
pub const LLVMRealPredicate_LLVMRealPredicateFalse: LLVMRealPredicate = 0;
#[doc = "< True if ordered and equal"]
pub const LLVMRealPredicate_LLVMRealOEQ: LLVMRealPredicate = 1;
#[doc = "< True if ordered and greater than"]
pub const LLVMRealPredicate_LLVMRealOGT: LLVMRealPredicate = 2;
#[doc = "< True if ordered and greater than or equal"]
pub const LLVMRealPredicate_LLVMRealOGE: LLVMRealPredicate = 3;
#[doc = "< True if ordered and less than"]
pub const LLVMRealPredicate_LLVMRealOLT: LLVMRealPredicate = 4;
#[doc = "< True if ordered and less than or equal"]
pub const LLVMRealPredicate_LLVMRealOLE: LLVMRealPredicate = 5;
#[doc = "< True if ordered and operands are unequal"]
pub const LLVMRealPredicate_LLVMRealONE: LLVMRealPredicate = 6;
#[doc = "< True if ordered (no nans)"]
pub const LLVMRealPredicate_LLVMRealORD: LLVMRealPredicate = 7;
#[doc = "< True if unordered: isnan(X) | isnan(Y)"]
pub const LLVMRealPredicate_LLVMRealUNO: LLVMRealPredicate = 8;
#[doc = "< True if unordered or equal"]
pub const LLVMRealPredicate_LLVMRealUEQ: LLVMRealPredicate = 9;
#[doc = "< True if unordered or greater than"]
pub const LLVMRealPredicate_LLVMRealUGT: LLVMRealPredicate = 10;
#[doc = "< True if unordered, greater than, or equal"]
pub const LLVMRealPredicate_LLVMRealUGE: LLVMRealPredicate = 11;
#[doc = "< True if unordered or less than"]
pub const LLVMRealPredicate_LLVMRealULT: LLVMRealPredicate = 12;
#[doc = "< True if unordered, less than, or equal"]
pub const LLVMRealPredicate_LLVMRealULE: LLVMRealPredicate = 13;
#[doc = "< True if unordered or not equal"]
pub const LLVMRealPredicate_LLVMRealUNE: LLVMRealPredicate = 14;
#[doc = "< Always true (always folded)"]
pub const LLVMRealPredicate_LLVMRealPredicateTrue: LLVMRealPredicate = 15;
pub type LLVMRealPredicate = ::std::os::raw::c_int;
pub const LLVMThreadLocalMode_LLVMNotThreadLocal: LLVMThreadLocalMode = 0;
pub const LLVMThreadLocalMode_LLVMGeneralDynamicTLSModel: LLVMThreadLocalMode = 1;
pub const LLVMThreadLocalMode_LLVMLocalDynamicTLSModel: LLVMThreadLocalMode = 2;
pub const LLVMThreadLocalMode_LLVMInitialExecTLSModel: LLVMThreadLocalMode = 3;
pub const LLVMThreadLocalMode_LLVMLocalExecTLSModel: LLVMThreadLocalMode = 4;
pub type LLVMThreadLocalMode = ::std::os::raw::c_int;
#[doc = "< A load or store which is not atomic"]
pub const LLVMAtomicOrdering_LLVMAtomicOrderingNotAtomic: LLVMAtomicOrdering = 0;
#[doc = "< Lowest level of atomicity, guarantees\nsomewhat sane results, lock free."]
pub const LLVMAtomicOrdering_LLVMAtomicOrderingUnordered: LLVMAtomicOrdering = 1;
#[doc = "< guarantees that if you take all the\noperations affecting a specific address,\na consistent ordering exists"]
pub const LLVMAtomicOrdering_LLVMAtomicOrderingMonotonic: LLVMAtomicOrdering = 2;
#[doc = "< Acquire provides a barrier of the sort\nnecessary to acquire a lock to access other\nmemory with normal loads and stores."]
pub const LLVMAtomicOrdering_LLVMAtomicOrderingAcquire: LLVMAtomicOrdering = 4;
#[doc = "< Release is similar to Acquire, but with\na barrier of the sort necessary to release\na lock."]
pub const LLVMAtomicOrdering_LLVMAtomicOrderingRelease: LLVMAtomicOrdering = 5;
#[doc = "< provides both an Acquire and a\nRelease barrier (for fences and\noperations which both read and write\nmemory)."]
pub const LLVMAtomicOrdering_LLVMAtomicOrderingAcquireRelease: LLVMAtomicOrdering = 6;
#[doc = "< provides Acquire semantics\nfor loads and Release\nsemantics for stores.\nAdditionally, it guarantees\nthat a total ordering exists\nbetween all\nSequentiallyConsistent\noperations."]
pub const LLVMAtomicOrdering_LLVMAtomicOrderingSequentiallyConsistent: LLVMAtomicOrdering = 7;
pub type LLVMAtomicOrdering = ::std::os::raw::c_int;
#[doc = "< Set the new value and return the one old"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpXchg: LLVMAtomicRMWBinOp = 0;
#[doc = "< Add a value and return the old one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpAdd: LLVMAtomicRMWBinOp = 1;
#[doc = "< Subtract a value and return the old one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpSub: LLVMAtomicRMWBinOp = 2;
#[doc = "< And a value and return the old one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpAnd: LLVMAtomicRMWBinOp = 3;
#[doc = "< Not-And a value and return the old one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpNand: LLVMAtomicRMWBinOp = 4;
#[doc = "< OR a value and return the old one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpOr: LLVMAtomicRMWBinOp = 5;
#[doc = "< Xor a value and return the old one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpXor: LLVMAtomicRMWBinOp = 6;
#[doc = "< Sets the value if it's greater than the\noriginal using a signed comparison and return\nthe old one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpMax: LLVMAtomicRMWBinOp = 7;
#[doc = "< Sets the value if it's Smaller than the\noriginal using a signed comparison and return\nthe old one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpMin: LLVMAtomicRMWBinOp = 8;
#[doc = "< Sets the value if it's greater than the\noriginal using an unsigned comparison and return\nthe old one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpUMax: LLVMAtomicRMWBinOp = 9;
#[doc = "< Sets the value if it's greater than the\noriginal using an unsigned comparison and return\nthe old one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpUMin: LLVMAtomicRMWBinOp = 10;
#[doc = "< Add a floating point value and return the\nold one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpFAdd: LLVMAtomicRMWBinOp = 11;
#[doc = "< Subtract a floating point value and return the\nold one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpFSub: LLVMAtomicRMWBinOp = 12;
#[doc = "< Sets the value if it's greater than the\noriginal using an floating point comparison and\nreturn the old one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpFMax: LLVMAtomicRMWBinOp = 13;
#[doc = "< Sets the value if it's smaller than the\noriginal using an floating point comparison and\nreturn the old one"]
pub const LLVMAtomicRMWBinOp_LLVMAtomicRMWBinOpFMin: LLVMAtomicRMWBinOp = 14;
pub type LLVMAtomicRMWBinOp = ::std::os::raw::c_int;
pub const LLVMDiagnosticSeverity_LLVMDSError: LLVMDiagnosticSeverity = 0;
pub const LLVMDiagnosticSeverity_LLVMDSWarning: LLVMDiagnosticSeverity = 1;
pub const LLVMDiagnosticSeverity_LLVMDSRemark: LLVMDiagnosticSeverity = 2;
pub const LLVMDiagnosticSeverity_LLVMDSNote: LLVMDiagnosticSeverity = 3;
pub type LLVMDiagnosticSeverity = ::std::os::raw::c_int;
pub const LLVMInlineAsmDialect_LLVMInlineAsmDialectATT: LLVMInlineAsmDialect = 0;
pub const LLVMInlineAsmDialect_LLVMInlineAsmDialectIntel: LLVMInlineAsmDialect = 1;
pub type LLVMInlineAsmDialect = ::std::os::raw::c_int;
#[doc = " Emits an error if two values disagree, otherwise the resulting value is\n that of the operands.\n\n @see Module::ModFlagBehavior::Error"]
pub const LLVMModuleFlagBehavior_LLVMModuleFlagBehaviorError: LLVMModuleFlagBehavior = 0;
#[doc = " Emits a warning if two values disagree. The result value will be the\n operand for the flag from the first module being linked.\n\n @see Module::ModFlagBehavior::Warning"]
pub const LLVMModuleFlagBehavior_LLVMModuleFlagBehaviorWarning: LLVMModuleFlagBehavior = 1;
#[doc = " Adds a requirement that another module flag be present and have a\n specified value after linking is performed. The value must be a metadata\n pair, where the first element of the pair is the ID of the module flag\n to be restricted, and the second element of the pair is the value the\n module flag should be restricted to. This behavior can be used to\n restrict the allowable results (via triggering of an error) of linking\n IDs with the **Override** behavior.\n\n @see Module::ModFlagBehavior::Require"]
pub const LLVMModuleFlagBehavior_LLVMModuleFlagBehaviorRequire: LLVMModuleFlagBehavior = 2;
#[doc = " Uses the specified value, regardless of the behavior or value of the\n other module. If both modules specify **Override**, but the values\n differ, an error will be emitted.\n\n @see Module::ModFlagBehavior::Override"]
pub const LLVMModuleFlagBehavior_LLVMModuleFlagBehaviorOverride: LLVMModuleFlagBehavior = 3;
#[doc = " Appends the two values, which are required to be metadata nodes.\n\n @see Module::ModFlagBehavior::Append"]
pub const LLVMModuleFlagBehavior_LLVMModuleFlagBehaviorAppend: LLVMModuleFlagBehavior = 4;
#[doc = " Appends the two values, which are required to be metadata\n nodes. However, duplicate entries in the second list are dropped\n during the append operation.\n\n @see Module::ModFlagBehavior::AppendUnique"]
pub const LLVMModuleFlagBehavior_LLVMModuleFlagBehaviorAppendUnique: LLVMModuleFlagBehavior = 5;
pub type LLVMModuleFlagBehavior = ::std::os::raw::c_int;
pub type LLVMAttributeIndex = ::std::os::raw::c_uint;
#[doc = " @defgroup LLVMCCoreContext Contexts\n\n Contexts are execution states for the core LLVM IR system.\n\n Most types are tied to a context instance. Multiple contexts can\n exist simultaneously. A single context is not thread safe. However,\n different contexts can execute on different threads simultaneously.\n\n @{"]
pub type LLVMDiagnosticHandler = ::std::option::Option<
    unsafe extern "C" fn(arg1: LLVMDiagnosticInfoRef, arg2: *mut ::std::os::raw::c_void),
>;
pub type LLVMYieldCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: LLVMContextRef, arg2: *mut ::std::os::raw::c_void),
>;
pub const LLVMDIFlags_LLVMDIFlagZero: LLVMDIFlags = 0;
pub const LLVMDIFlags_LLVMDIFlagPrivate: LLVMDIFlags = 1;
pub const LLVMDIFlags_LLVMDIFlagProtected: LLVMDIFlags = 2;
pub const LLVMDIFlags_LLVMDIFlagPublic: LLVMDIFlags = 3;
pub const LLVMDIFlags_LLVMDIFlagFwdDecl: LLVMDIFlags = 4;
pub const LLVMDIFlags_LLVMDIFlagAppleBlock: LLVMDIFlags = 8;
pub const LLVMDIFlags_LLVMDIFlagReservedBit4: LLVMDIFlags = 16;
pub const LLVMDIFlags_LLVMDIFlagVirtual: LLVMDIFlags = 32;
pub const LLVMDIFlags_LLVMDIFlagArtificial: LLVMDIFlags = 64;
pub const LLVMDIFlags_LLVMDIFlagExplicit: LLVMDIFlags = 128;
pub const LLVMDIFlags_LLVMDIFlagPrototyped: LLVMDIFlags = 256;
pub const LLVMDIFlags_LLVMDIFlagObjcClassComplete: LLVMDIFlags = 512;
pub const LLVMDIFlags_LLVMDIFlagObjectPointer: LLVMDIFlags = 1024;
pub const LLVMDIFlags_LLVMDIFlagVector: LLVMDIFlags = 2048;
pub const LLVMDIFlags_LLVMDIFlagStaticMember: LLVMDIFlags = 4096;
pub const LLVMDIFlags_LLVMDIFlagLValueReference: LLVMDIFlags = 8192;
pub const LLVMDIFlags_LLVMDIFlagRValueReference: LLVMDIFlags = 16384;
pub const LLVMDIFlags_LLVMDIFlagReserved: LLVMDIFlags = 32768;
pub const LLVMDIFlags_LLVMDIFlagSingleInheritance: LLVMDIFlags = 65536;
pub const LLVMDIFlags_LLVMDIFlagMultipleInheritance: LLVMDIFlags = 131072;
pub const LLVMDIFlags_LLVMDIFlagVirtualInheritance: LLVMDIFlags = 196608;
pub const LLVMDIFlags_LLVMDIFlagIntroducedVirtual: LLVMDIFlags = 262144;
pub const LLVMDIFlags_LLVMDIFlagBitField: LLVMDIFlags = 524288;
pub const LLVMDIFlags_LLVMDIFlagNoReturn: LLVMDIFlags = 1048576;
pub const LLVMDIFlags_LLVMDIFlagTypePassByValue: LLVMDIFlags = 4194304;
pub const LLVMDIFlags_LLVMDIFlagTypePassByReference: LLVMDIFlags = 8388608;
pub const LLVMDIFlags_LLVMDIFlagEnumClass: LLVMDIFlags = 16777216;
pub const LLVMDIFlags_LLVMDIFlagFixedEnum: LLVMDIFlags = 16777216;
pub const LLVMDIFlags_LLVMDIFlagThunk: LLVMDIFlags = 33554432;
pub const LLVMDIFlags_LLVMDIFlagNonTrivial: LLVMDIFlags = 67108864;
pub const LLVMDIFlags_LLVMDIFlagBigEndian: LLVMDIFlags = 134217728;
pub const LLVMDIFlags_LLVMDIFlagLittleEndian: LLVMDIFlags = 268435456;
pub const LLVMDIFlags_LLVMDIFlagIndirectVirtualBase: LLVMDIFlags = 36;
pub const LLVMDIFlags_LLVMDIFlagAccessibility: LLVMDIFlags = 3;
pub const LLVMDIFlags_LLVMDIFlagPtrToMemberRep: LLVMDIFlags = 196608;
#[doc = " Debug info flags."]
pub type LLVMDIFlags = ::std::os::raw::c_int;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageC89: LLVMDWARFSourceLanguage = 0;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageC: LLVMDWARFSourceLanguage = 1;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageAda83: LLVMDWARFSourceLanguage = 2;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageC_plus_plus: LLVMDWARFSourceLanguage = 3;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageCobol74: LLVMDWARFSourceLanguage = 4;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageCobol85: LLVMDWARFSourceLanguage = 5;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageFortran77: LLVMDWARFSourceLanguage = 6;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageFortran90: LLVMDWARFSourceLanguage = 7;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguagePascal83: LLVMDWARFSourceLanguage = 8;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageModula2: LLVMDWARFSourceLanguage = 9;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageJava: LLVMDWARFSourceLanguage = 10;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageC99: LLVMDWARFSourceLanguage = 11;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageAda95: LLVMDWARFSourceLanguage = 12;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageFortran95: LLVMDWARFSourceLanguage = 13;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguagePLI: LLVMDWARFSourceLanguage = 14;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageObjC: LLVMDWARFSourceLanguage = 15;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageObjC_plus_plus: LLVMDWARFSourceLanguage =
    16;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageUPC: LLVMDWARFSourceLanguage = 17;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageD: LLVMDWARFSourceLanguage = 18;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguagePython: LLVMDWARFSourceLanguage = 19;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageOpenCL: LLVMDWARFSourceLanguage = 20;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageGo: LLVMDWARFSourceLanguage = 21;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageModula3: LLVMDWARFSourceLanguage = 22;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageHaskell: LLVMDWARFSourceLanguage = 23;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageC_plus_plus_03: LLVMDWARFSourceLanguage =
    24;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageC_plus_plus_11: LLVMDWARFSourceLanguage =
    25;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageOCaml: LLVMDWARFSourceLanguage = 26;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageRust: LLVMDWARFSourceLanguage = 27;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageC11: LLVMDWARFSourceLanguage = 28;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageSwift: LLVMDWARFSourceLanguage = 29;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageJulia: LLVMDWARFSourceLanguage = 30;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageDylan: LLVMDWARFSourceLanguage = 31;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageC_plus_plus_14: LLVMDWARFSourceLanguage =
    32;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageFortran03: LLVMDWARFSourceLanguage = 33;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageFortran08: LLVMDWARFSourceLanguage = 34;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageRenderScript: LLVMDWARFSourceLanguage = 35;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageBLISS: LLVMDWARFSourceLanguage = 36;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageKotlin: LLVMDWARFSourceLanguage = 37;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageZig: LLVMDWARFSourceLanguage = 38;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageCrystal: LLVMDWARFSourceLanguage = 39;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageC_plus_plus_17: LLVMDWARFSourceLanguage =
    40;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageC_plus_plus_20: LLVMDWARFSourceLanguage =
    41;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageC17: LLVMDWARFSourceLanguage = 42;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageFortran18: LLVMDWARFSourceLanguage = 43;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageAda2005: LLVMDWARFSourceLanguage = 44;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageAda2012: LLVMDWARFSourceLanguage = 45;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageMojo: LLVMDWARFSourceLanguage = 46;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageMips_Assembler: LLVMDWARFSourceLanguage =
    47;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageGOOGLE_RenderScript:
    LLVMDWARFSourceLanguage = 48;
pub const LLVMDWARFSourceLanguage_LLVMDWARFSourceLanguageBORLAND_Delphi: LLVMDWARFSourceLanguage =
    49;
#[doc = " Source languages known by DWARF."]
pub type LLVMDWARFSourceLanguage = ::std::os::raw::c_int;
pub const LLVMDWARFEmissionKind_LLVMDWARFEmissionNone: LLVMDWARFEmissionKind = 0;
pub const LLVMDWARFEmissionKind_LLVMDWARFEmissionFull: LLVMDWARFEmissionKind = 1;
pub const LLVMDWARFEmissionKind_LLVMDWARFEmissionLineTablesOnly: LLVMDWARFEmissionKind = 2;
#[doc = " The amount of debug information to emit."]
pub type LLVMDWARFEmissionKind = ::std::os::raw::c_int;
pub type LLVMMetadataKind = ::std::os::raw::c_uint;
#[doc = " An LLVM DWARF type encoding."]
pub type LLVMDWARFTypeEncoding = ::std::os::raw::c_uint;
pub const LLVMDWARFMacinfoRecordType_LLVMDWARFMacinfoRecordTypeDefine: LLVMDWARFMacinfoRecordType =
    1;
pub const LLVMDWARFMacinfoRecordType_LLVMDWARFMacinfoRecordTypeMacro: LLVMDWARFMacinfoRecordType =
    2;
pub const LLVMDWARFMacinfoRecordType_LLVMDWARFMacinfoRecordTypeStartFile:
    LLVMDWARFMacinfoRecordType = 3;
pub const LLVMDWARFMacinfoRecordType_LLVMDWARFMacinfoRecordTypeEndFile: LLVMDWARFMacinfoRecordType =
    4;
pub const LLVMDWARFMacinfoRecordType_LLVMDWARFMacinfoRecordTypeVendorExt:
    LLVMDWARFMacinfoRecordType = 255;
#[doc = " Describes the kind of macro declaration used for LLVMDIBuilderCreateMacro.\n @see llvm::dwarf::MacinfoRecordType\n @note Values are from DW_MACINFO_* constants in the DWARF specification."]
pub type LLVMDWARFMacinfoRecordType = ::std::os::raw::c_int;
#[doc = " An opaque reference to a disassembler context."]
pub type LLVMDisasmContextRef = *mut ::std::os::raw::c_void;
#[doc = " The type for the operand information call back function.  This is called to\n get the symbolic information for an operand of an instruction.  Typically\n this is from the relocation information, symbol table, etc.  That block of\n information is saved when the disassembler context is created and passed to\n the call back in the DisInfo parameter.  The instruction containing operand\n is at the PC parameter.  For some instruction sets, there can be more than\n one operand with symbolic information.  To determine the symbolic operand\n information for each operand, the bytes for the specific operand in the\n instruction are specified by the Offset parameter and its byte widith is the\n OpSize parameter.  For instructions sets with fixed widths and one symbolic\n operand per instruction, the Offset parameter will be zero and InstSize\n parameter will be the instruction width.  The information is returned in\n TagBuf and is Triple specific with its specific information defined by the\n value of TagType for that Triple.  If symbolic information is returned the\n function * returns 1, otherwise it returns 0."]
pub type LLVMOpInfoCallback = ::std::option::Option<
    unsafe extern "C" fn(
        DisInfo: *mut ::std::os::raw::c_void,
        PC: u64,
        Offset: u64,
        OpSize: u64,
        InstSize: u64,
        TagType: ::std::os::raw::c_int,
        TagBuf: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " The type for the symbol lookup function.  This may be called by the\n disassembler for things like adding a comment for a PC plus a constant\n offset load instruction to use a symbol name instead of a load address value.\n It is passed the block information is saved when the disassembler context is\n created and the ReferenceValue to look up as a symbol.  If no symbol is found\n for the ReferenceValue NULL is returned.  The ReferenceType of the\n instruction is passed indirectly as is the PC of the instruction in\n ReferencePC.  If the output reference can be determined its type is returned\n indirectly in ReferenceType along with ReferenceName if any, or that is set\n to NULL."]
pub type LLVMSymbolLookupCallback = ::std::option::Option<
    unsafe extern "C" fn(
        DisInfo: *mut ::std::os::raw::c_void,
        ReferenceValue: u64,
        ReferenceType: *mut u64,
        ReferencePC: u64,
        ReferenceName: *mut *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueError {
    _unused: [u8; 0],
}
#[doc = " Opaque reference to an error instance. Null serves as the 'success' value."]
pub type LLVMErrorRef = *mut LLVMOpaqueError;
#[doc = " Error type identifier."]
pub type LLVMErrorTypeId = *const ::std::os::raw::c_void;
pub const LLVMByteOrdering_LLVMBigEndian: LLVMByteOrdering = 0;
pub const LLVMByteOrdering_LLVMLittleEndian: LLVMByteOrdering = 1;
#[doc = " @defgroup LLVMCTarget Target information\n @ingroup LLVMC\n\n @{"]
pub type LLVMByteOrdering = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueTargetData {
    _unused: [u8; 0],
}
pub type LLVMTargetDataRef = *mut LLVMOpaqueTargetData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueTargetLibraryInfotData {
    _unused: [u8; 0],
}
pub type LLVMTargetLibraryInfoRef = *mut LLVMOpaqueTargetLibraryInfotData;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueTargetMachine {
    _unused: [u8; 0],
}
#[doc = " @addtogroup LLVMCTarget\n\n @{"]
pub type LLVMTargetMachineRef = *mut LLVMOpaqueTargetMachine;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMTarget {
    _unused: [u8; 0],
}
pub type LLVMTargetRef = *mut LLVMTarget;
pub const LLVMCodeGenOptLevel_LLVMCodeGenLevelNone: LLVMCodeGenOptLevel = 0;
pub const LLVMCodeGenOptLevel_LLVMCodeGenLevelLess: LLVMCodeGenOptLevel = 1;
pub const LLVMCodeGenOptLevel_LLVMCodeGenLevelDefault: LLVMCodeGenOptLevel = 2;
pub const LLVMCodeGenOptLevel_LLVMCodeGenLevelAggressive: LLVMCodeGenOptLevel = 3;
pub type LLVMCodeGenOptLevel = ::std::os::raw::c_int;
pub const LLVMRelocMode_LLVMRelocDefault: LLVMRelocMode = 0;
pub const LLVMRelocMode_LLVMRelocStatic: LLVMRelocMode = 1;
pub const LLVMRelocMode_LLVMRelocPIC: LLVMRelocMode = 2;
pub const LLVMRelocMode_LLVMRelocDynamicNoPic: LLVMRelocMode = 3;
pub const LLVMRelocMode_LLVMRelocROPI: LLVMRelocMode = 4;
pub const LLVMRelocMode_LLVMRelocRWPI: LLVMRelocMode = 5;
pub const LLVMRelocMode_LLVMRelocROPI_RWPI: LLVMRelocMode = 6;
pub type LLVMRelocMode = ::std::os::raw::c_int;
pub const LLVMCodeModel_LLVMCodeModelDefault: LLVMCodeModel = 0;
pub const LLVMCodeModel_LLVMCodeModelJITDefault: LLVMCodeModel = 1;
pub const LLVMCodeModel_LLVMCodeModelTiny: LLVMCodeModel = 2;
pub const LLVMCodeModel_LLVMCodeModelSmall: LLVMCodeModel = 3;
pub const LLVMCodeModel_LLVMCodeModelKernel: LLVMCodeModel = 4;
pub const LLVMCodeModel_LLVMCodeModelMedium: LLVMCodeModel = 5;
pub const LLVMCodeModel_LLVMCodeModelLarge: LLVMCodeModel = 6;
pub type LLVMCodeModel = ::std::os::raw::c_int;
pub const LLVMCodeGenFileType_LLVMAssemblyFile: LLVMCodeGenFileType = 0;
pub const LLVMCodeGenFileType_LLVMObjectFile: LLVMCodeGenFileType = 1;
pub type LLVMCodeGenFileType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueGenericValue {
    _unused: [u8; 0],
}
pub type LLVMGenericValueRef = *mut LLVMOpaqueGenericValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueExecutionEngine {
    _unused: [u8; 0],
}
pub type LLVMExecutionEngineRef = *mut LLVMOpaqueExecutionEngine;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueMCJITMemoryManager {
    _unused: [u8; 0],
}
pub type LLVMMCJITMemoryManagerRef = *mut LLVMOpaqueMCJITMemoryManager;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMMCJITCompilerOptions {
    pub OptLevel: ::std::os::raw::c_uint,
    pub CodeModel: LLVMCodeModel,
    pub NoFramePointerElim: LLVMBool,
    pub EnableFastISel: LLVMBool,
    pub MCJMM: LLVMMCJITMemoryManagerRef,
}
#[test]
fn bindgen_test_layout_LLVMMCJITCompilerOptions() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMMCJITCompilerOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMMCJITCompilerOptions>(),
        24usize,
        concat!("Size of: ", stringify!(LLVMMCJITCompilerOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMMCJITCompilerOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(LLVMMCJITCompilerOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OptLevel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMMCJITCompilerOptions),
            "::",
            stringify!(OptLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CodeModel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMMCJITCompilerOptions),
            "::",
            stringify!(CodeModel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NoFramePointerElim) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMMCJITCompilerOptions),
            "::",
            stringify!(NoFramePointerElim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnableFastISel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMMCJITCompilerOptions),
            "::",
            stringify!(EnableFastISel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MCJMM) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMMCJITCompilerOptions),
            "::",
            stringify!(MCJMM)
        )
    );
}
pub type LLVMMemoryManagerAllocateCodeSectionCallback = ::std::option::Option<
    unsafe extern "C" fn(
        Opaque: *mut ::std::os::raw::c_void,
        Size: usize,
        Alignment: ::std::os::raw::c_uint,
        SectionID: ::std::os::raw::c_uint,
        SectionName: *const ::std::os::raw::c_char,
    ) -> *mut u8,
>;
pub type LLVMMemoryManagerAllocateDataSectionCallback = ::std::option::Option<
    unsafe extern "C" fn(
        Opaque: *mut ::std::os::raw::c_void,
        Size: usize,
        Alignment: ::std::os::raw::c_uint,
        SectionID: ::std::os::raw::c_uint,
        SectionName: *const ::std::os::raw::c_char,
        IsReadOnly: LLVMBool,
    ) -> *mut u8,
>;
pub type LLVMMemoryManagerFinalizeMemoryCallback = ::std::option::Option<
    unsafe extern "C" fn(
        Opaque: *mut ::std::os::raw::c_void,
        ErrMsg: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool,
>;
pub type LLVMMemoryManagerDestroyCallback =
    ::std::option::Option<unsafe extern "C" fn(Opaque: *mut ::std::os::raw::c_void)>;
#[doc = " Represents an address in the executor process."]
pub type LLVMOrcJITTargetAddress = u64;
#[doc = " Represents an address in the executor process."]
pub type LLVMOrcExecutorAddress = u64;
#[doc = " Represents the linkage flags for a symbol definition."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMJITSymbolFlags {
    pub GenericFlags: u8,
    pub TargetFlags: u8,
}
#[test]
fn bindgen_test_layout_LLVMJITSymbolFlags() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMJITSymbolFlags> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMJITSymbolFlags>(),
        2usize,
        concat!("Size of: ", stringify!(LLVMJITSymbolFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMJITSymbolFlags>(),
        1usize,
        concat!("Alignment of ", stringify!(LLVMJITSymbolFlags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GenericFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMJITSymbolFlags),
            "::",
            stringify!(GenericFlags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetFlags) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMJITSymbolFlags),
            "::",
            stringify!(TargetFlags)
        )
    );
}
#[doc = " Represents an evaluated symbol address and flags."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMJITEvaluatedSymbol {
    pub Address: LLVMOrcExecutorAddress,
    pub Flags: LLVMJITSymbolFlags,
}
#[test]
fn bindgen_test_layout_LLVMJITEvaluatedSymbol() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMJITEvaluatedSymbol> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMJITEvaluatedSymbol>(),
        16usize,
        concat!("Size of: ", stringify!(LLVMJITEvaluatedSymbol))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMJITEvaluatedSymbol>(),
        8usize,
        concat!("Alignment of ", stringify!(LLVMJITEvaluatedSymbol))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMJITEvaluatedSymbol),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMJITEvaluatedSymbol),
            "::",
            stringify!(Flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueExecutionSession {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::ExecutionSession instance."]
pub type LLVMOrcExecutionSessionRef = *mut LLVMOrcOpaqueExecutionSession;
#[doc = " Error reporter function."]
pub type LLVMOrcErrorReporterFunction = ::std::option::Option<
    unsafe extern "C" fn(Ctx: *mut ::std::os::raw::c_void, err: LLVMErrorRef),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueSymbolStringPool {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::SymbolStringPool."]
pub type LLVMOrcSymbolStringPoolRef = *mut LLVMOrcOpaqueSymbolStringPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueSymbolStringPoolEntry {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::SymbolStringPool table entry."]
pub type LLVMOrcSymbolStringPoolEntryRef = *mut LLVMOrcOpaqueSymbolStringPoolEntry;
#[doc = " Represents a pair of a symbol name and LLVMJITSymbolFlags."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcCSymbolFlagsMapPair {
    pub Name: LLVMOrcSymbolStringPoolEntryRef,
    pub Flags: LLVMJITSymbolFlags,
}
#[test]
fn bindgen_test_layout_LLVMOrcCSymbolFlagsMapPair() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMOrcCSymbolFlagsMapPair> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMOrcCSymbolFlagsMapPair>(),
        16usize,
        concat!("Size of: ", stringify!(LLVMOrcCSymbolFlagsMapPair))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMOrcCSymbolFlagsMapPair>(),
        8usize,
        concat!("Alignment of ", stringify!(LLVMOrcCSymbolFlagsMapPair))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCSymbolFlagsMapPair),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCSymbolFlagsMapPair),
            "::",
            stringify!(Flags)
        )
    );
}
#[doc = " Represents a list of (SymbolStringPtr, JITSymbolFlags) pairs that can be used\n to construct a SymbolFlagsMap."]
pub type LLVMOrcCSymbolFlagsMapPairs = *mut LLVMOrcCSymbolFlagsMapPair;
#[doc = " Represents a pair of a symbol name and an evaluated symbol."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcCSymbolMapPair {
    pub Name: LLVMOrcSymbolStringPoolEntryRef,
    pub Sym: LLVMJITEvaluatedSymbol,
}
#[test]
fn bindgen_test_layout_LLVMOrcCSymbolMapPair() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMOrcCSymbolMapPair> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMOrcCSymbolMapPair>(),
        24usize,
        concat!("Size of: ", stringify!(LLVMOrcCSymbolMapPair))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMOrcCSymbolMapPair>(),
        8usize,
        concat!("Alignment of ", stringify!(LLVMOrcCSymbolMapPair))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCSymbolMapPair),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Sym) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCSymbolMapPair),
            "::",
            stringify!(Sym)
        )
    );
}
#[doc = " Represents a list of (SymbolStringPtr, JITEvaluatedSymbol) pairs that can be\n used to construct a SymbolMap."]
pub type LLVMOrcCSymbolMapPairs = *mut LLVMOrcCSymbolMapPair;
#[doc = " Represents a SymbolAliasMapEntry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcCSymbolAliasMapEntry {
    pub Name: LLVMOrcSymbolStringPoolEntryRef,
    pub Flags: LLVMJITSymbolFlags,
}
#[test]
fn bindgen_test_layout_LLVMOrcCSymbolAliasMapEntry() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMOrcCSymbolAliasMapEntry> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMOrcCSymbolAliasMapEntry>(),
        16usize,
        concat!("Size of: ", stringify!(LLVMOrcCSymbolAliasMapEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMOrcCSymbolAliasMapEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(LLVMOrcCSymbolAliasMapEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCSymbolAliasMapEntry),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCSymbolAliasMapEntry),
            "::",
            stringify!(Flags)
        )
    );
}
#[doc = " Represents a pair of a symbol name and SymbolAliasMapEntry."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcCSymbolAliasMapPair {
    pub Name: LLVMOrcSymbolStringPoolEntryRef,
    pub Entry: LLVMOrcCSymbolAliasMapEntry,
}
#[test]
fn bindgen_test_layout_LLVMOrcCSymbolAliasMapPair() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMOrcCSymbolAliasMapPair> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMOrcCSymbolAliasMapPair>(),
        24usize,
        concat!("Size of: ", stringify!(LLVMOrcCSymbolAliasMapPair))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMOrcCSymbolAliasMapPair>(),
        8usize,
        concat!("Alignment of ", stringify!(LLVMOrcCSymbolAliasMapPair))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCSymbolAliasMapPair),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Entry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCSymbolAliasMapPair),
            "::",
            stringify!(Entry)
        )
    );
}
#[doc = " Represents a list of (SymbolStringPtr, (SymbolStringPtr, JITSymbolFlags))\n pairs that can be used to construct a SymbolFlagsMap."]
pub type LLVMOrcCSymbolAliasMapPairs = *mut LLVMOrcCSymbolAliasMapPair;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueJITDylib {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::JITDylib instance."]
pub type LLVMOrcJITDylibRef = *mut LLVMOrcOpaqueJITDylib;
#[doc = " Represents a list of LLVMOrcSymbolStringPoolEntryRef and the associated\n length."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcCSymbolsList {
    pub Symbols: *mut LLVMOrcSymbolStringPoolEntryRef,
    pub Length: usize,
}
#[test]
fn bindgen_test_layout_LLVMOrcCSymbolsList() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMOrcCSymbolsList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMOrcCSymbolsList>(),
        16usize,
        concat!("Size of: ", stringify!(LLVMOrcCSymbolsList))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMOrcCSymbolsList>(),
        8usize,
        concat!("Alignment of ", stringify!(LLVMOrcCSymbolsList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Symbols) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCSymbolsList),
            "::",
            stringify!(Symbols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCSymbolsList),
            "::",
            stringify!(Length)
        )
    );
}
#[doc = " Represents a pair of a JITDylib and LLVMOrcCSymbolsList."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcCDependenceMapPair {
    pub JD: LLVMOrcJITDylibRef,
    pub Names: LLVMOrcCSymbolsList,
}
#[test]
fn bindgen_test_layout_LLVMOrcCDependenceMapPair() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMOrcCDependenceMapPair> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMOrcCDependenceMapPair>(),
        24usize,
        concat!("Size of: ", stringify!(LLVMOrcCDependenceMapPair))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMOrcCDependenceMapPair>(),
        8usize,
        concat!("Alignment of ", stringify!(LLVMOrcCDependenceMapPair))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JD) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCDependenceMapPair),
            "::",
            stringify!(JD)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Names) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCDependenceMapPair),
            "::",
            stringify!(Names)
        )
    );
}
#[doc = " Represents a list of (JITDylibRef, (LLVMOrcSymbolStringPoolEntryRef*,\n size_t)) pairs that can be used to construct a SymbolDependenceMap."]
pub type LLVMOrcCDependenceMapPairs = *mut LLVMOrcCDependenceMapPair;
pub const LLVMOrcLookupKind_LLVMOrcLookupKindStatic: LLVMOrcLookupKind = 0;
pub const LLVMOrcLookupKind_LLVMOrcLookupKindDLSym: LLVMOrcLookupKind = 1;
#[doc = " Lookup kind. This can be used by definition generators when deciding whether\n to produce a definition for a requested symbol.\n\n This enum should be kept in sync with llvm::orc::LookupKind."]
pub type LLVMOrcLookupKind = ::std::os::raw::c_int;
pub const LLVMOrcJITDylibLookupFlags_LLVMOrcJITDylibLookupFlagsMatchExportedSymbolsOnly:
    LLVMOrcJITDylibLookupFlags = 0;
pub const LLVMOrcJITDylibLookupFlags_LLVMOrcJITDylibLookupFlagsMatchAllSymbols:
    LLVMOrcJITDylibLookupFlags = 1;
#[doc = " JITDylib lookup flags. This can be used by definition generators when\n deciding whether to produce a definition for a requested symbol.\n\n This enum should be kept in sync with llvm::orc::JITDylibLookupFlags."]
pub type LLVMOrcJITDylibLookupFlags = ::std::os::raw::c_int;
#[doc = " An element type for a JITDylib search order."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcCJITDylibSearchOrderElement {
    pub JD: LLVMOrcJITDylibRef,
    pub JDLookupFlags: LLVMOrcJITDylibLookupFlags,
}
#[test]
fn bindgen_test_layout_LLVMOrcCJITDylibSearchOrderElement() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMOrcCJITDylibSearchOrderElement> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMOrcCJITDylibSearchOrderElement>(),
        16usize,
        concat!("Size of: ", stringify!(LLVMOrcCJITDylibSearchOrderElement))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMOrcCJITDylibSearchOrderElement>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(LLVMOrcCJITDylibSearchOrderElement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JD) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCJITDylibSearchOrderElement),
            "::",
            stringify!(JD)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JDLookupFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCJITDylibSearchOrderElement),
            "::",
            stringify!(JDLookupFlags)
        )
    );
}
#[doc = " A JITDylib search order.\n\n The list is terminated with an element containing a null pointer for the JD\n field."]
pub type LLVMOrcCJITDylibSearchOrder = *mut LLVMOrcCJITDylibSearchOrderElement;
pub const LLVMOrcSymbolLookupFlags_LLVMOrcSymbolLookupFlagsRequiredSymbol:
    LLVMOrcSymbolLookupFlags = 0;
pub const LLVMOrcSymbolLookupFlags_LLVMOrcSymbolLookupFlagsWeaklyReferencedSymbol:
    LLVMOrcSymbolLookupFlags = 1;
#[doc = " Symbol lookup flags for lookup sets. This should be kept in sync with\n llvm::orc::SymbolLookupFlags."]
pub type LLVMOrcSymbolLookupFlags = ::std::os::raw::c_int;
#[doc = " An element type for a symbol lookup set."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcCLookupSetElement {
    pub Name: LLVMOrcSymbolStringPoolEntryRef,
    pub LookupFlags: LLVMOrcSymbolLookupFlags,
}
#[test]
fn bindgen_test_layout_LLVMOrcCLookupSetElement() {
    const UNINIT: ::std::mem::MaybeUninit<LLVMOrcCLookupSetElement> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LLVMOrcCLookupSetElement>(),
        16usize,
        concat!("Size of: ", stringify!(LLVMOrcCLookupSetElement))
    );
    assert_eq!(
        ::std::mem::align_of::<LLVMOrcCLookupSetElement>(),
        8usize,
        concat!("Alignment of ", stringify!(LLVMOrcCLookupSetElement))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCLookupSetElement),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LookupFlags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LLVMOrcCLookupSetElement),
            "::",
            stringify!(LookupFlags)
        )
    );
}
#[doc = " A set of symbols to look up / generate.\n\n The list is terminated with an element containing a null pointer for the\n Name field.\n\n If a client creates an instance of this type then they are responsible for\n freeing it, and for ensuring that all strings have been retained over the\n course of its life. Clients receiving a copy from a callback are not\n responsible for managing lifetime or retain counts."]
pub type LLVMOrcCLookupSet = *mut LLVMOrcCLookupSetElement;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueMaterializationUnit {
    _unused: [u8; 0],
}
#[doc = " A reference to a uniquely owned orc::MaterializationUnit instance."]
pub type LLVMOrcMaterializationUnitRef = *mut LLVMOrcOpaqueMaterializationUnit;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueMaterializationResponsibility {
    _unused: [u8; 0],
}
#[doc = " A reference to a uniquely owned orc::MaterializationResponsibility instance.\n\n Ownership must be passed to a lower-level layer in a JIT stack."]
pub type LLVMOrcMaterializationResponsibilityRef = *mut LLVMOrcOpaqueMaterializationResponsibility;
#[doc = " A MaterializationUnit materialize callback.\n\n Ownership of the Ctx and MR arguments passes to the callback which must\n adhere to the LLVMOrcMaterializationResponsibilityRef contract (see comment\n for that type).\n\n If this callback is called then the LLVMOrcMaterializationUnitDestroy\n callback will NOT be called."]
pub type LLVMOrcMaterializationUnitMaterializeFunction = ::std::option::Option<
    unsafe extern "C" fn(
        Ctx: *mut ::std::os::raw::c_void,
        MR: LLVMOrcMaterializationResponsibilityRef,
    ),
>;
#[doc = " A MaterializationUnit discard callback.\n\n Ownership of JD and Symbol remain with the caller: These arguments should\n not be disposed of or released."]
pub type LLVMOrcMaterializationUnitDiscardFunction = ::std::option::Option<
    unsafe extern "C" fn(
        Ctx: *mut ::std::os::raw::c_void,
        JD: LLVMOrcJITDylibRef,
        Symbol: LLVMOrcSymbolStringPoolEntryRef,
    ),
>;
#[doc = " A MaterializationUnit destruction callback.\n\n If a custom MaterializationUnit is destroyed before its Materialize\n function is called then this function will be called to provide an\n opportunity for the underlying program representation to be destroyed."]
pub type LLVMOrcMaterializationUnitDestroyFunction =
    ::std::option::Option<unsafe extern "C" fn(Ctx: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueResourceTracker {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::ResourceTracker instance."]
pub type LLVMOrcResourceTrackerRef = *mut LLVMOrcOpaqueResourceTracker;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueDefinitionGenerator {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::DefinitionGenerator."]
pub type LLVMOrcDefinitionGeneratorRef = *mut LLVMOrcOpaqueDefinitionGenerator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueLookupState {
    _unused: [u8; 0],
}
#[doc = " An opaque lookup state object. Instances of this type can be captured to\n suspend a lookup while a custom generator function attempts to produce a\n definition.\n\n If a client captures a lookup state object then they must eventually call\n LLVMOrcLookupStateContinueLookup to restart the lookup. This is required\n in order to release memory allocated for the lookup state, even if errors\n have occurred while the lookup was suspended (if these errors have made the\n lookup impossible to complete then it will issue its own error before\n destruction)."]
pub type LLVMOrcLookupStateRef = *mut LLVMOrcOpaqueLookupState;
#[doc = " A custom generator function. This can be used to create a custom generator\n object using LLVMOrcCreateCustomCAPIDefinitionGenerator. The resulting\n object can be attached to a JITDylib, via LLVMOrcJITDylibAddGenerator, to\n receive callbacks when lookups fail to match existing definitions.\n\n GeneratorObj will contain the address of the custom generator object.\n\n Ctx will contain the context object passed to\n LLVMOrcCreateCustomCAPIDefinitionGenerator.\n\n LookupState will contain a pointer to an LLVMOrcLookupStateRef object. This\n can optionally be modified to make the definition generation process\n asynchronous: If the LookupStateRef value is copied, and the original\n LLVMOrcLookupStateRef set to null, the lookup will be suspended. Once the\n asynchronous definition process has been completed clients must call\n LLVMOrcLookupStateContinueLookup to continue the lookup (this should be\n done unconditionally, even if errors have occurred in the mean time, to\n free the lookup state memory and notify the query object of the failures).\n If LookupState is captured this function must return LLVMErrorSuccess.\n\n The Kind argument can be inspected to determine the lookup kind (e.g.\n as-if-during-static-link, or as-if-during-dlsym).\n\n The JD argument specifies which JITDylib the definitions should be generated\n into.\n\n The JDLookupFlags argument can be inspected to determine whether the original\n lookup included non-exported symobls.\n\n Finally, the LookupSet argument contains the set of symbols that could not\n be found in JD already (the set of generation candidates)."]
pub type LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction = ::std::option::Option<
    unsafe extern "C" fn(
        GeneratorObj: LLVMOrcDefinitionGeneratorRef,
        Ctx: *mut ::std::os::raw::c_void,
        LookupState: *mut LLVMOrcLookupStateRef,
        Kind: LLVMOrcLookupKind,
        JD: LLVMOrcJITDylibRef,
        JDLookupFlags: LLVMOrcJITDylibLookupFlags,
        LookupSet: LLVMOrcCLookupSet,
        LookupSetSize: usize,
    ) -> LLVMErrorRef,
>;
#[doc = " Disposer for a custom generator.\n\n Will be called by ORC when the JITDylib that the generator is attached to\n is destroyed."]
pub type LLVMOrcDisposeCAPIDefinitionGeneratorFunction =
    ::std::option::Option<unsafe extern "C" fn(Ctx: *mut ::std::os::raw::c_void)>;
#[doc = " Predicate function for SymbolStringPoolEntries."]
pub type LLVMOrcSymbolPredicate = ::std::option::Option<
    unsafe extern "C" fn(
        Ctx: *mut ::std::os::raw::c_void,
        Sym: LLVMOrcSymbolStringPoolEntryRef,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueThreadSafeContext {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::ThreadSafeContext instance."]
pub type LLVMOrcThreadSafeContextRef = *mut LLVMOrcOpaqueThreadSafeContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueThreadSafeModule {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::ThreadSafeModule instance."]
pub type LLVMOrcThreadSafeModuleRef = *mut LLVMOrcOpaqueThreadSafeModule;
#[doc = " A function for inspecting/mutating IR modules, suitable for use with\n LLVMOrcThreadSafeModuleWithModuleDo."]
pub type LLVMOrcGenericIRModuleOperationFunction = ::std::option::Option<
    unsafe extern "C" fn(Ctx: *mut ::std::os::raw::c_void, M: LLVMModuleRef) -> LLVMErrorRef,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueJITTargetMachineBuilder {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::JITTargetMachineBuilder instance."]
pub type LLVMOrcJITTargetMachineBuilderRef = *mut LLVMOrcOpaqueJITTargetMachineBuilder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueObjectLayer {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::ObjectLayer instance."]
pub type LLVMOrcObjectLayerRef = *mut LLVMOrcOpaqueObjectLayer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueIRTransformLayer {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::IRTransformLayer instance."]
pub type LLVMOrcIRTransformLayerRef = *mut LLVMOrcOpaqueIRTransformLayer;
#[doc = " A function for applying transformations as part of an transform layer.\n\n Implementations of this type are responsible for managing the lifetime\n of the Module pointed to by ModInOut: If the LLVMModuleRef value is\n overwritten then the function is responsible for disposing of the incoming\n module. If the module is simply accessed/mutated in-place then ownership\n returns to the caller and the function does not need to do any lifetime\n management.\n\n Clients can call LLVMOrcLLJITGetIRTransformLayer to obtain the transform\n layer of a LLJIT instance, and use LLVMOrcIRTransformLayerSetTransform\n to set the function. This can be used to override the default transform\n layer."]
pub type LLVMOrcIRTransformLayerTransformFunction = ::std::option::Option<
    unsafe extern "C" fn(
        Ctx: *mut ::std::os::raw::c_void,
        ModInOut: *mut LLVMOrcThreadSafeModuleRef,
        MR: LLVMOrcMaterializationResponsibilityRef,
    ) -> LLVMErrorRef,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueObjectTransformLayer {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::ObjectTransformLayer instance."]
pub type LLVMOrcObjectTransformLayerRef = *mut LLVMOrcOpaqueObjectTransformLayer;
#[doc = " A function for applying transformations to an object file buffer.\n\n Implementations of this type are responsible for managing the lifetime\n of the memory buffer pointed to by ObjInOut: If the LLVMMemoryBufferRef\n value is overwritten then the function is responsible for disposing of the\n incoming buffer. If the buffer is simply accessed/mutated in-place then\n ownership returns to the caller and the function does not need to do any\n lifetime management.\n\n The transform is allowed to return an error, in which case the ObjInOut\n buffer should be disposed of and set to null."]
pub type LLVMOrcObjectTransformLayerTransformFunction = ::std::option::Option<
    unsafe extern "C" fn(
        Ctx: *mut ::std::os::raw::c_void,
        ObjInOut: *mut LLVMMemoryBufferRef,
    ) -> LLVMErrorRef,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueIndirectStubsManager {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::IndirectStubsManager instance."]
pub type LLVMOrcIndirectStubsManagerRef = *mut LLVMOrcOpaqueIndirectStubsManager;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueLazyCallThroughManager {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::LazyCallThroughManager instance."]
pub type LLVMOrcLazyCallThroughManagerRef = *mut LLVMOrcOpaqueLazyCallThroughManager;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueDumpObjects {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::DumpObjects object.\n\n Can be used to dump object files to disk with unique names. Useful as an\n ObjectTransformLayer transform."]
pub type LLVMOrcDumpObjectsRef = *mut LLVMOrcOpaqueDumpObjects;
#[doc = " Callback type for ExecutionSession lookups.\n\n If Err is LLVMErrorSuccess then Result will contain a pointer to a\n list of ( SymbolStringPtr, JITEvaluatedSymbol ) pairs of length NumPairs.\n\n If Err is a failure value then Result and Ctx are undefined and should\n not be accessed. The Callback is responsible for handling the error\n value (e.g. by calling LLVMGetErrorMessage + LLVMDisposeErrorMessage).\n\n The caller retains ownership of the Result array and will release all\n contained symbol names. Clients are responsible for retaining any symbol\n names that they wish to hold after the function returns."]
pub type LLVMOrcExecutionSessionLookupHandleResultFunction = ::std::option::Option<
    unsafe extern "C" fn(
        err: LLVMErrorRef,
        Result: LLVMOrcCSymbolMapPairs,
        NumPairs: usize,
        Ctx: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " A function for constructing an ObjectLinkingLayer instance to be used\n by an LLJIT instance.\n\n Clients can call LLVMOrcLLJITBuilderSetObjectLinkingLayerCreator to\n set the creator function to use when constructing an LLJIT instance.\n This can be used to override the default linking layer implementation\n that would otherwise be chosen by LLJITBuilder.\n\n Object linking layers returned by this function will become owned by the\n LLJIT instance. The client is not responsible for managing their lifetimes\n after the function returns."]
pub type LLVMOrcLLJITBuilderObjectLinkingLayerCreatorFunction = ::std::option::Option<
    unsafe extern "C" fn(
        Ctx: *mut ::std::os::raw::c_void,
        ES: LLVMOrcExecutionSessionRef,
        Triple: *const ::std::os::raw::c_char,
    ) -> LLVMOrcObjectLayerRef,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueLLJITBuilder {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::LLJITBuilder instance."]
pub type LLVMOrcLLJITBuilderRef = *mut LLVMOrcOpaqueLLJITBuilder;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOrcOpaqueLLJIT {
    _unused: [u8; 0],
}
#[doc = " A reference to an orc::LLJIT instance."]
pub type LLVMOrcLLJITRef = *mut LLVMOrcOpaqueLLJIT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueSectionIterator {
    _unused: [u8; 0],
}
#[doc = " @defgroup LLVMCObject Object file reading and writing\n @ingroup LLVMC\n\n @{"]
pub type LLVMSectionIteratorRef = *mut LLVMOpaqueSectionIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueSymbolIterator {
    _unused: [u8; 0],
}
pub type LLVMSymbolIteratorRef = *mut LLVMOpaqueSymbolIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueRelocationIterator {
    _unused: [u8; 0],
}
pub type LLVMRelocationIteratorRef = *mut LLVMOpaqueRelocationIterator;
#[doc = "< Archive file."]
pub const LLVMBinaryType_LLVMBinaryTypeArchive: LLVMBinaryType = 0;
#[doc = "< Mach-O Universal Binary file."]
pub const LLVMBinaryType_LLVMBinaryTypeMachOUniversalBinary: LLVMBinaryType = 1;
#[doc = "< COFF Import file."]
pub const LLVMBinaryType_LLVMBinaryTypeCOFFImportFile: LLVMBinaryType = 2;
#[doc = "< LLVM IR."]
pub const LLVMBinaryType_LLVMBinaryTypeIR: LLVMBinaryType = 3;
#[doc = "< Windows resource (.res) file."]
pub const LLVMBinaryType_LLVMBinaryTypeWinRes: LLVMBinaryType = 4;
#[doc = "< COFF Object file."]
pub const LLVMBinaryType_LLVMBinaryTypeCOFF: LLVMBinaryType = 5;
#[doc = "< ELF 32-bit, little endian."]
pub const LLVMBinaryType_LLVMBinaryTypeELF32L: LLVMBinaryType = 6;
#[doc = "< ELF 32-bit, big endian."]
pub const LLVMBinaryType_LLVMBinaryTypeELF32B: LLVMBinaryType = 7;
#[doc = "< ELF 64-bit, little endian."]
pub const LLVMBinaryType_LLVMBinaryTypeELF64L: LLVMBinaryType = 8;
#[doc = "< ELF 64-bit, big endian."]
pub const LLVMBinaryType_LLVMBinaryTypeELF64B: LLVMBinaryType = 9;
#[doc = "< MachO 32-bit, little endian."]
pub const LLVMBinaryType_LLVMBinaryTypeMachO32L: LLVMBinaryType = 10;
#[doc = "< MachO 32-bit, big endian."]
pub const LLVMBinaryType_LLVMBinaryTypeMachO32B: LLVMBinaryType = 11;
#[doc = "< MachO 64-bit, little endian."]
pub const LLVMBinaryType_LLVMBinaryTypeMachO64L: LLVMBinaryType = 12;
#[doc = "< MachO 64-bit, big endian."]
pub const LLVMBinaryType_LLVMBinaryTypeMachO64B: LLVMBinaryType = 13;
#[doc = "< Web Assembly."]
pub const LLVMBinaryType_LLVMBinaryTypeWasm: LLVMBinaryType = 14;
#[doc = "< Offloading fatbinary."]
pub const LLVMBinaryType_LLVMBinaryTypeOffload: LLVMBinaryType = 15;
pub type LLVMBinaryType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMOpaqueObjectFile {
    _unused: [u8; 0],
}
#[doc = " Deprecated: Use LLVMBinaryRef instead."]
pub type LLVMObjectFileRef = *mut LLVMOpaqueObjectFile;
pub type LLVMMemoryManagerCreateContextCallback = ::std::option::Option<
    unsafe extern "C" fn(CtxCtx: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub type LLVMMemoryManagerNotifyTerminatingCallback =
    ::std::option::Option<unsafe extern "C" fn(CtxCtx: *mut ::std::os::raw::c_void)>;
pub const LLVMRemarkType_LLVMRemarkTypeUnknown: LLVMRemarkType = 0;
pub const LLVMRemarkType_LLVMRemarkTypePassed: LLVMRemarkType = 1;
pub const LLVMRemarkType_LLVMRemarkTypeMissed: LLVMRemarkType = 2;
pub const LLVMRemarkType_LLVMRemarkTypeAnalysis: LLVMRemarkType = 3;
pub const LLVMRemarkType_LLVMRemarkTypeAnalysisFPCommute: LLVMRemarkType = 4;
pub const LLVMRemarkType_LLVMRemarkTypeAnalysisAliasing: LLVMRemarkType = 5;
pub const LLVMRemarkType_LLVMRemarkTypeFailure: LLVMRemarkType = 6;
#[doc = " The type of the emitted remark."]
pub type LLVMRemarkType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMRemarkOpaqueString {
    _unused: [u8; 0],
}
#[doc = " String containing a buffer and a length. The buffer is not guaranteed to be\n zero-terminated.\n\n \\since REMARKS_API_VERSION=0"]
pub type LLVMRemarkStringRef = *mut LLVMRemarkOpaqueString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMRemarkOpaqueDebugLoc {
    _unused: [u8; 0],
}
#[doc = " DebugLoc containing File, Line and Column.\n\n \\since REMARKS_API_VERSION=0"]
pub type LLVMRemarkDebugLocRef = *mut LLVMRemarkOpaqueDebugLoc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMRemarkOpaqueArg {
    _unused: [u8; 0],
}
#[doc = " Element of the \"Args\" list. The key might give more information about what\n the semantics of the value are, e.g. \"Callee\" will tell you that the value\n is a symbol that names a function.\n\n \\since REMARKS_API_VERSION=0"]
pub type LLVMRemarkArgRef = *mut LLVMRemarkOpaqueArg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMRemarkOpaqueEntry {
    _unused: [u8; 0],
}
#[doc = " A remark emitted by the compiler.\n\n \\since REMARKS_API_VERSION=0"]
pub type LLVMRemarkEntryRef = *mut LLVMRemarkOpaqueEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LLVMRemarkOpaqueParser {
    _unused: [u8; 0],
}
pub type LLVMRemarkParserRef = *mut LLVMRemarkOpaqueParser;
extern crate libloading;
pub struct llvm {
    __library: ::libloading::Library,
    pub LLVMVerifyModule: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Action: LLVMVerifierFailureAction,
            OutMessage: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMVerifyFunction: Result<
        unsafe extern "C" fn(Fn: LLVMValueRef, Action: LLVMVerifierFailureAction) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMViewFunctionCFG: Result<unsafe extern "C" fn(Fn: LLVMValueRef), ::libloading::Error>,
    pub LLVMViewFunctionCFGOnly:
        Result<unsafe extern "C" fn(Fn: LLVMValueRef), ::libloading::Error>,
    pub LLVMParseBitcode: Result<
        unsafe extern "C" fn(
            MemBuf: LLVMMemoryBufferRef,
            OutModule: *mut LLVMModuleRef,
            OutMessage: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMParseBitcode2: Result<
        unsafe extern "C" fn(
            MemBuf: LLVMMemoryBufferRef,
            OutModule: *mut LLVMModuleRef,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMParseBitcodeInContext: Result<
        unsafe extern "C" fn(
            ContextRef: LLVMContextRef,
            MemBuf: LLVMMemoryBufferRef,
            OutModule: *mut LLVMModuleRef,
            OutMessage: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMParseBitcodeInContext2: Result<
        unsafe extern "C" fn(
            ContextRef: LLVMContextRef,
            MemBuf: LLVMMemoryBufferRef,
            OutModule: *mut LLVMModuleRef,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMGetBitcodeModuleInContext: Result<
        unsafe extern "C" fn(
            ContextRef: LLVMContextRef,
            MemBuf: LLVMMemoryBufferRef,
            OutM: *mut LLVMModuleRef,
            OutMessage: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMGetBitcodeModuleInContext2: Result<
        unsafe extern "C" fn(
            ContextRef: LLVMContextRef,
            MemBuf: LLVMMemoryBufferRef,
            OutM: *mut LLVMModuleRef,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMGetBitcodeModule: Result<
        unsafe extern "C" fn(
            MemBuf: LLVMMemoryBufferRef,
            OutM: *mut LLVMModuleRef,
            OutMessage: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMGetBitcodeModule2: Result<
        unsafe extern "C" fn(MemBuf: LLVMMemoryBufferRef, OutM: *mut LLVMModuleRef) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMWriteBitcodeToFile: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Path: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub LLVMWriteBitcodeToFD: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            FD: ::std::os::raw::c_int,
            ShouldClose: ::std::os::raw::c_int,
            Unbuffered: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub LLVMWriteBitcodeToFileHandle: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Handle: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub LLVMWriteBitcodeToMemoryBuffer:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMMemoryBufferRef, ::libloading::Error>,
    pub LLVMGetOrInsertComdat: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMComdatRef,
        ::libloading::Error,
    >,
    pub LLVMGetComdat:
        Result<unsafe extern "C" fn(V: LLVMValueRef) -> LLVMComdatRef, ::libloading::Error>,
    pub LLVMSetComdat:
        Result<unsafe extern "C" fn(V: LLVMValueRef, C: LLVMComdatRef), ::libloading::Error>,
    pub LLVMGetComdatSelectionKind: Result<
        unsafe extern "C" fn(C: LLVMComdatRef) -> LLVMComdatSelectionKind,
        ::libloading::Error,
    >,
    pub LLVMSetComdatSelectionKind: Result<
        unsafe extern "C" fn(C: LLVMComdatRef, Kind: LLVMComdatSelectionKind),
        ::libloading::Error,
    >,
    pub LLVMInstallFatalErrorHandler:
        Result<unsafe extern "C" fn(Handler: LLVMFatalErrorHandler), ::libloading::Error>,
    pub LLVMResetFatalErrorHandler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMEnablePrettyStackTrace: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMShutdown: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMGetVersion: Result<
        unsafe extern "C" fn(
            Major: *mut ::std::os::raw::c_uint,
            Minor: *mut ::std::os::raw::c_uint,
            Patch: *mut ::std::os::raw::c_uint,
        ),
        ::libloading::Error,
    >,
    pub LLVMCreateMessage: Result<
        unsafe extern "C" fn(Message: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMDisposeMessage:
        Result<unsafe extern "C" fn(Message: *mut ::std::os::raw::c_char), ::libloading::Error>,
    pub LLVMContextCreate: Result<unsafe extern "C" fn() -> LLVMContextRef, ::libloading::Error>,
    pub LLVMGetGlobalContext: Result<unsafe extern "C" fn() -> LLVMContextRef, ::libloading::Error>,
    pub LLVMContextSetDiagnosticHandler: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            Handler: LLVMDiagnosticHandler,
            DiagnosticContext: *mut ::std::os::raw::c_void,
        ),
        ::libloading::Error,
    >,
    pub LLVMContextGetDiagnosticHandler: Result<
        unsafe extern "C" fn(C: LLVMContextRef) -> LLVMDiagnosticHandler,
        ::libloading::Error,
    >,
    pub LLVMContextGetDiagnosticContext: Result<
        unsafe extern "C" fn(C: LLVMContextRef) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub LLVMContextSetYieldCallback: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            Callback: LLVMYieldCallback,
            OpaqueHandle: *mut ::std::os::raw::c_void,
        ),
        ::libloading::Error,
    >,
    pub LLVMContextShouldDiscardValueNames:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMContextSetDiscardValueNames:
        Result<unsafe extern "C" fn(C: LLVMContextRef, Discard: LLVMBool), ::libloading::Error>,
    pub LLVMContextDispose: Result<unsafe extern "C" fn(C: LLVMContextRef), ::libloading::Error>,
    pub LLVMGetDiagInfoDescription: Result<
        unsafe extern "C" fn(DI: LLVMDiagnosticInfoRef) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetDiagInfoSeverity: Result<
        unsafe extern "C" fn(DI: LLVMDiagnosticInfoRef) -> LLVMDiagnosticSeverity,
        ::libloading::Error,
    >,
    pub LLVMGetMDKindIDInContext: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            Name: *const ::std::os::raw::c_char,
            SLen: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetMDKindID: Result<
        unsafe extern "C" fn(
            Name: *const ::std::os::raw::c_char,
            SLen: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetEnumAttributeKindForName: Result<
        unsafe extern "C" fn(
            Name: *const ::std::os::raw::c_char,
            SLen: usize,
        ) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetLastEnumAttributeKind:
        Result<unsafe extern "C" fn() -> ::std::os::raw::c_uint, ::libloading::Error>,
    pub LLVMCreateEnumAttribute: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            KindID: ::std::os::raw::c_uint,
            Val: u64,
        ) -> LLVMAttributeRef,
        ::libloading::Error,
    >,
    pub LLVMGetEnumAttributeKind: Result<
        unsafe extern "C" fn(A: LLVMAttributeRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetEnumAttributeValue:
        Result<unsafe extern "C" fn(A: LLVMAttributeRef) -> u64, ::libloading::Error>,
    pub LLVMCreateTypeAttribute: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            KindID: ::std::os::raw::c_uint,
            type_ref: LLVMTypeRef,
        ) -> LLVMAttributeRef,
        ::libloading::Error,
    >,
    pub LLVMGetTypeAttributeValue:
        Result<unsafe extern "C" fn(A: LLVMAttributeRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMCreateStringAttribute: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            K: *const ::std::os::raw::c_char,
            KLength: ::std::os::raw::c_uint,
            V: *const ::std::os::raw::c_char,
            VLength: ::std::os::raw::c_uint,
        ) -> LLVMAttributeRef,
        ::libloading::Error,
    >,
    pub LLVMGetStringAttributeKind: Result<
        unsafe extern "C" fn(
            A: LLVMAttributeRef,
            Length: *mut ::std::os::raw::c_uint,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetStringAttributeValue: Result<
        unsafe extern "C" fn(
            A: LLVMAttributeRef,
            Length: *mut ::std::os::raw::c_uint,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMIsEnumAttribute:
        Result<unsafe extern "C" fn(A: LLVMAttributeRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMIsStringAttribute:
        Result<unsafe extern "C" fn(A: LLVMAttributeRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMIsTypeAttribute:
        Result<unsafe extern "C" fn(A: LLVMAttributeRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMGetTypeByName2: Result<
        unsafe extern "C" fn(C: LLVMContextRef, Name: *const ::std::os::raw::c_char) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMModuleCreateWithName: Result<
        unsafe extern "C" fn(ModuleID: *const ::std::os::raw::c_char) -> LLVMModuleRef,
        ::libloading::Error,
    >,
    pub LLVMModuleCreateWithNameInContext: Result<
        unsafe extern "C" fn(
            ModuleID: *const ::std::os::raw::c_char,
            C: LLVMContextRef,
        ) -> LLVMModuleRef,
        ::libloading::Error,
    >,
    pub LLVMCloneModule:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMModuleRef, ::libloading::Error>,
    pub LLVMDisposeModule: Result<unsafe extern "C" fn(M: LLVMModuleRef), ::libloading::Error>,
    pub LLVMGetModuleIdentifier: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, Len: *mut usize) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMSetModuleIdentifier: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, Ident: *const ::std::os::raw::c_char, Len: usize),
        ::libloading::Error,
    >,
    pub LLVMGetSourceFileName: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, Len: *mut usize) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMSetSourceFileName: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, Name: *const ::std::os::raw::c_char, Len: usize),
        ::libloading::Error,
    >,
    pub LLVMGetDataLayoutStr: Result<
        unsafe extern "C" fn(M: LLVMModuleRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetDataLayout: Result<
        unsafe extern "C" fn(M: LLVMModuleRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMSetDataLayout: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, DataLayoutStr: *const ::std::os::raw::c_char),
        ::libloading::Error,
    >,
    pub LLVMGetTarget: Result<
        unsafe extern "C" fn(M: LLVMModuleRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMSetTarget: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, Triple: *const ::std::os::raw::c_char),
        ::libloading::Error,
    >,
    pub LLVMCopyModuleFlagsMetadata: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, Len: *mut usize) -> *mut LLVMModuleFlagEntry,
        ::libloading::Error,
    >,
    pub LLVMDisposeModuleFlagsMetadata:
        Result<unsafe extern "C" fn(Entries: *mut LLVMModuleFlagEntry), ::libloading::Error>,
    pub LLVMModuleFlagEntriesGetFlagBehavior: Result<
        unsafe extern "C" fn(
            Entries: *mut LLVMModuleFlagEntry,
            Index: ::std::os::raw::c_uint,
        ) -> LLVMModuleFlagBehavior,
        ::libloading::Error,
    >,
    pub LLVMModuleFlagEntriesGetKey: Result<
        unsafe extern "C" fn(
            Entries: *mut LLVMModuleFlagEntry,
            Index: ::std::os::raw::c_uint,
            Len: *mut usize,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMModuleFlagEntriesGetMetadata: Result<
        unsafe extern "C" fn(
            Entries: *mut LLVMModuleFlagEntry,
            Index: ::std::os::raw::c_uint,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMGetModuleFlag: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Key: *const ::std::os::raw::c_char,
            KeyLen: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMAddModuleFlag: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Behavior: LLVMModuleFlagBehavior,
            Key: *const ::std::os::raw::c_char,
            KeyLen: usize,
            Val: LLVMMetadataRef,
        ),
        ::libloading::Error,
    >,
    pub LLVMDumpModule: Result<unsafe extern "C" fn(M: LLVMModuleRef), ::libloading::Error>,
    pub LLVMPrintModuleToFile: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Filename: *const ::std::os::raw::c_char,
            ErrorMessage: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMPrintModuleToString: Result<
        unsafe extern "C" fn(M: LLVMModuleRef) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetModuleInlineAsm: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, Len: *mut usize) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMSetModuleInlineAsm2: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, Asm: *const ::std::os::raw::c_char, Len: usize),
        ::libloading::Error,
    >,
    pub LLVMAppendModuleInlineAsm: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, Asm: *const ::std::os::raw::c_char, Len: usize),
        ::libloading::Error,
    >,
    pub LLVMGetInlineAsm: Result<
        unsafe extern "C" fn(
            Ty: LLVMTypeRef,
            AsmString: *mut ::std::os::raw::c_char,
            AsmStringSize: usize,
            Constraints: *mut ::std::os::raw::c_char,
            ConstraintsSize: usize,
            HasSideEffects: LLVMBool,
            IsAlignStack: LLVMBool,
            Dialect: LLVMInlineAsmDialect,
            CanThrow: LLVMBool,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetModuleContext:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMContextRef, ::libloading::Error>,
    pub LLVMGetTypeByName: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, Name: *const ::std::os::raw::c_char) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMGetFirstNamedMetadata:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMNamedMDNodeRef, ::libloading::Error>,
    pub LLVMGetLastNamedMetadata:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMNamedMDNodeRef, ::libloading::Error>,
    pub LLVMGetNextNamedMetadata: Result<
        unsafe extern "C" fn(NamedMDNode: LLVMNamedMDNodeRef) -> LLVMNamedMDNodeRef,
        ::libloading::Error,
    >,
    pub LLVMGetPreviousNamedMetadata: Result<
        unsafe extern "C" fn(NamedMDNode: LLVMNamedMDNodeRef) -> LLVMNamedMDNodeRef,
        ::libloading::Error,
    >,
    pub LLVMGetNamedMetadata: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
        ) -> LLVMNamedMDNodeRef,
        ::libloading::Error,
    >,
    pub LLVMGetOrInsertNamedMetadata: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
        ) -> LLVMNamedMDNodeRef,
        ::libloading::Error,
    >,
    pub LLVMGetNamedMetadataName: Result<
        unsafe extern "C" fn(
            NamedMD: LLVMNamedMDNodeRef,
            NameLen: *mut usize,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetNamedMetadataNumOperands: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Name: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetNamedMetadataOperands: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Name: *const ::std::os::raw::c_char,
            Dest: *mut LLVMValueRef,
        ),
        ::libloading::Error,
    >,
    pub LLVMAddNamedMetadataOperand: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Name: *const ::std::os::raw::c_char,
            Val: LLVMValueRef,
        ),
        ::libloading::Error,
    >,
    pub LLVMGetDebugLocDirectory: Result<
        unsafe extern "C" fn(
            Val: LLVMValueRef,
            Length: *mut ::std::os::raw::c_uint,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetDebugLocFilename: Result<
        unsafe extern "C" fn(
            Val: LLVMValueRef,
            Length: *mut ::std::os::raw::c_uint,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetDebugLocLine: Result<
        unsafe extern "C" fn(Val: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetDebugLocColumn: Result<
        unsafe extern "C" fn(Val: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMAddFunction: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Name: *const ::std::os::raw::c_char,
            FunctionTy: LLVMTypeRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetNamedFunction: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, Name: *const ::std::os::raw::c_char) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetFirstFunction:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetLastFunction:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetNextFunction:
        Result<unsafe extern "C" fn(Fn: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetPreviousFunction:
        Result<unsafe extern "C" fn(Fn: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMSetModuleInlineAsm: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, Asm: *const ::std::os::raw::c_char),
        ::libloading::Error,
    >,
    pub LLVMGetTypeKind:
        Result<unsafe extern "C" fn(Ty: LLVMTypeRef) -> LLVMTypeKind, ::libloading::Error>,
    pub LLVMTypeIsSized:
        Result<unsafe extern "C" fn(Ty: LLVMTypeRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMGetTypeContext:
        Result<unsafe extern "C" fn(Ty: LLVMTypeRef) -> LLVMContextRef, ::libloading::Error>,
    pub LLVMDumpType: Result<unsafe extern "C" fn(Val: LLVMTypeRef), ::libloading::Error>,
    pub LLVMPrintTypeToString: Result<
        unsafe extern "C" fn(Val: LLVMTypeRef) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMInt1TypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMInt8TypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMInt16TypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMInt32TypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMInt64TypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMInt128TypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMIntTypeInContext: Result<
        unsafe extern "C" fn(C: LLVMContextRef, NumBits: ::std::os::raw::c_uint) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMInt1Type: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMInt8Type: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMInt16Type: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMInt32Type: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMInt64Type: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMInt128Type: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMIntType: Result<
        unsafe extern "C" fn(NumBits: ::std::os::raw::c_uint) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMGetIntTypeWidth: Result<
        unsafe extern "C" fn(IntegerTy: LLVMTypeRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMHalfTypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMBFloatTypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMFloatTypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMDoubleTypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMX86FP80TypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMFP128TypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMPPCFP128TypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMHalfType: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMBFloatType: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMFloatType: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMDoubleType: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMX86FP80Type: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMFP128Type: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMPPCFP128Type: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMFunctionType: Result<
        unsafe extern "C" fn(
            ReturnType: LLVMTypeRef,
            ParamTypes: *mut LLVMTypeRef,
            ParamCount: ::std::os::raw::c_uint,
            IsVarArg: LLVMBool,
        ) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMIsFunctionVarArg:
        Result<unsafe extern "C" fn(FunctionTy: LLVMTypeRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMGetReturnType:
        Result<unsafe extern "C" fn(FunctionTy: LLVMTypeRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMCountParamTypes: Result<
        unsafe extern "C" fn(FunctionTy: LLVMTypeRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetParamTypes: Result<
        unsafe extern "C" fn(FunctionTy: LLVMTypeRef, Dest: *mut LLVMTypeRef),
        ::libloading::Error,
    >,
    pub LLVMStructTypeInContext: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            ElementTypes: *mut LLVMTypeRef,
            ElementCount: ::std::os::raw::c_uint,
            Packed: LLVMBool,
        ) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMStructType: Result<
        unsafe extern "C" fn(
            ElementTypes: *mut LLVMTypeRef,
            ElementCount: ::std::os::raw::c_uint,
            Packed: LLVMBool,
        ) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMStructCreateNamed: Result<
        unsafe extern "C" fn(C: LLVMContextRef, Name: *const ::std::os::raw::c_char) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMGetStructName: Result<
        unsafe extern "C" fn(Ty: LLVMTypeRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMStructSetBody: Result<
        unsafe extern "C" fn(
            StructTy: LLVMTypeRef,
            ElementTypes: *mut LLVMTypeRef,
            ElementCount: ::std::os::raw::c_uint,
            Packed: LLVMBool,
        ),
        ::libloading::Error,
    >,
    pub LLVMCountStructElementTypes: Result<
        unsafe extern "C" fn(StructTy: LLVMTypeRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetStructElementTypes: Result<
        unsafe extern "C" fn(StructTy: LLVMTypeRef, Dest: *mut LLVMTypeRef),
        ::libloading::Error,
    >,
    pub LLVMStructGetTypeAtIndex: Result<
        unsafe extern "C" fn(StructTy: LLVMTypeRef, i: ::std::os::raw::c_uint) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMIsPackedStruct:
        Result<unsafe extern "C" fn(StructTy: LLVMTypeRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMIsOpaqueStruct:
        Result<unsafe extern "C" fn(StructTy: LLVMTypeRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMIsLiteralStruct:
        Result<unsafe extern "C" fn(StructTy: LLVMTypeRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMGetElementType:
        Result<unsafe extern "C" fn(Ty: LLVMTypeRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMGetSubtypes:
        Result<unsafe extern "C" fn(Tp: LLVMTypeRef, Arr: *mut LLVMTypeRef), ::libloading::Error>,
    pub LLVMGetNumContainedTypes: Result<
        unsafe extern "C" fn(Tp: LLVMTypeRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMArrayType: Result<
        unsafe extern "C" fn(
            ElementType: LLVMTypeRef,
            ElementCount: ::std::os::raw::c_uint,
        ) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMArrayType2: Result<
        unsafe extern "C" fn(ElementType: LLVMTypeRef, ElementCount: u64) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMGetArrayLength: Result<
        unsafe extern "C" fn(ArrayTy: LLVMTypeRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetArrayLength2:
        Result<unsafe extern "C" fn(ArrayTy: LLVMTypeRef) -> u64, ::libloading::Error>,
    pub LLVMPointerType: Result<
        unsafe extern "C" fn(
            ElementType: LLVMTypeRef,
            AddressSpace: ::std::os::raw::c_uint,
        ) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMPointerTypeIsOpaque:
        Result<unsafe extern "C" fn(Ty: LLVMTypeRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMPointerTypeInContext: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            AddressSpace: ::std::os::raw::c_uint,
        ) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMGetPointerAddressSpace: Result<
        unsafe extern "C" fn(PointerTy: LLVMTypeRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMVectorType: Result<
        unsafe extern "C" fn(
            ElementType: LLVMTypeRef,
            ElementCount: ::std::os::raw::c_uint,
        ) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMScalableVectorType: Result<
        unsafe extern "C" fn(
            ElementType: LLVMTypeRef,
            ElementCount: ::std::os::raw::c_uint,
        ) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMGetVectorSize: Result<
        unsafe extern "C" fn(VectorTy: LLVMTypeRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMVoidTypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMLabelTypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMX86MMXTypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMX86AMXTypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMTokenTypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMMetadataTypeInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMVoidType: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMLabelType: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMX86MMXType: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMX86AMXType: Result<unsafe extern "C" fn() -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMTargetExtTypeInContext: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            Name: *const ::std::os::raw::c_char,
            TypeParams: *mut LLVMTypeRef,
            TypeParamCount: ::std::os::raw::c_uint,
            IntParams: *mut ::std::os::raw::c_uint,
            IntParamCount: ::std::os::raw::c_uint,
        ) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMTypeOf:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMGetValueKind:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueKind, ::libloading::Error>,
    pub LLVMGetValueName2: Result<
        unsafe extern "C" fn(
            Val: LLVMValueRef,
            Length: *mut usize,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMSetValueName2: Result<
        unsafe extern "C" fn(
            Val: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
        ),
        ::libloading::Error,
    >,
    pub LLVMDumpValue: Result<unsafe extern "C" fn(Val: LLVMValueRef), ::libloading::Error>,
    pub LLVMPrintValueToString: Result<
        unsafe extern "C" fn(Val: LLVMValueRef) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMReplaceAllUsesWith: Result<
        unsafe extern "C" fn(OldVal: LLVMValueRef, NewVal: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMIsConstant:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMIsUndef:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMIsPoison:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMIsAArgument:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsABasicBlock:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAInlineAsm:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAUser:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAConstant:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsABlockAddress:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAConstantAggregateZero:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAConstantArray:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAConstantDataSequential:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAConstantDataArray:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAConstantDataVector:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAConstantExpr:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAConstantFP:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAConstantInt:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAConstantPointerNull:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAConstantStruct:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAConstantTokenNone:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAConstantVector:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAGlobalValue:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAGlobalAlias:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAGlobalObject:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAFunction:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAGlobalVariable:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAGlobalIFunc:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAUndefValue:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAPoisonValue:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAInstruction:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAUnaryOperator:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsABinaryOperator:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsACallInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAIntrinsicInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsADbgInfoIntrinsic:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsADbgVariableIntrinsic:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsADbgDeclareInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsADbgLabelInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAMemIntrinsic:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAMemCpyInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAMemMoveInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAMemSetInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsACmpInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAFCmpInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAICmpInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAExtractElementInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAGetElementPtrInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAInsertElementInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAInsertValueInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsALandingPadInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAPHINode:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsASelectInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAShuffleVectorInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAStoreInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsABranchInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAIndirectBrInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAInvokeInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAReturnInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsASwitchInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAUnreachableInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAResumeInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsACleanupReturnInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsACatchReturnInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsACatchSwitchInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsACallBrInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAFuncletPadInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsACatchPadInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsACleanupPadInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAUnaryInstruction:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAAllocaInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsACastInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAAddrSpaceCastInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsABitCastInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAFPExtInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAFPToSIInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAFPToUIInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAFPTruncInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAIntToPtrInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAPtrToIntInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsASExtInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsASIToFPInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsATruncInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAUIToFPInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAZExtInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAExtractValueInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsALoadInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAVAArgInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAFreezeInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAAtomicCmpXchgInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAAtomicRMWInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAFenceInst:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAMDNode:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAValueAsMetadata:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsAMDString:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetValueName: Result<
        unsafe extern "C" fn(Val: LLVMValueRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMSetValueName: Result<
        unsafe extern "C" fn(Val: LLVMValueRef, Name: *const ::std::os::raw::c_char),
        ::libloading::Error,
    >,
    pub LLVMGetFirstUse:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMUseRef, ::libloading::Error>,
    pub LLVMGetNextUse:
        Result<unsafe extern "C" fn(U: LLVMUseRef) -> LLVMUseRef, ::libloading::Error>,
    pub LLVMGetUser:
        Result<unsafe extern "C" fn(U: LLVMUseRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetUsedValue:
        Result<unsafe extern "C" fn(U: LLVMUseRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetOperand: Result<
        unsafe extern "C" fn(Val: LLVMValueRef, Index: ::std::os::raw::c_uint) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetOperandUse: Result<
        unsafe extern "C" fn(Val: LLVMValueRef, Index: ::std::os::raw::c_uint) -> LLVMUseRef,
        ::libloading::Error,
    >,
    pub LLVMSetOperand: Result<
        unsafe extern "C" fn(User: LLVMValueRef, Index: ::std::os::raw::c_uint, Val: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMGetNumOperands: Result<
        unsafe extern "C" fn(Val: LLVMValueRef) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub LLVMConstNull:
        Result<unsafe extern "C" fn(Ty: LLVMTypeRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMConstAllOnes:
        Result<unsafe extern "C" fn(Ty: LLVMTypeRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetUndef:
        Result<unsafe extern "C" fn(Ty: LLVMTypeRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetPoison:
        Result<unsafe extern "C" fn(Ty: LLVMTypeRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsNull:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMConstPointerNull:
        Result<unsafe extern "C" fn(Ty: LLVMTypeRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMConstInt: Result<
        unsafe extern "C" fn(
            IntTy: LLVMTypeRef,
            N: ::std::os::raw::c_ulonglong,
            SignExtend: LLVMBool,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstIntOfArbitraryPrecision: Result<
        unsafe extern "C" fn(
            IntTy: LLVMTypeRef,
            NumWords: ::std::os::raw::c_uint,
            Words: *const u64,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstIntOfString: Result<
        unsafe extern "C" fn(
            IntTy: LLVMTypeRef,
            Text: *const ::std::os::raw::c_char,
            Radix: u8,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstIntOfStringAndSize: Result<
        unsafe extern "C" fn(
            IntTy: LLVMTypeRef,
            Text: *const ::std::os::raw::c_char,
            SLen: ::std::os::raw::c_uint,
            Radix: u8,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstReal: Result<
        unsafe extern "C" fn(RealTy: LLVMTypeRef, N: f64) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstRealOfString: Result<
        unsafe extern "C" fn(
            RealTy: LLVMTypeRef,
            Text: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstRealOfStringAndSize: Result<
        unsafe extern "C" fn(
            RealTy: LLVMTypeRef,
            Text: *const ::std::os::raw::c_char,
            SLen: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstIntGetZExtValue: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub LLVMConstIntGetSExtValue: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef) -> ::std::os::raw::c_longlong,
        ::libloading::Error,
    >,
    pub LLVMConstRealGetDouble: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, losesInfo: *mut LLVMBool) -> f64,
        ::libloading::Error,
    >,
    pub LLVMConstStringInContext: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            Str: *const ::std::os::raw::c_char,
            Length: ::std::os::raw::c_uint,
            DontNullTerminate: LLVMBool,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstString: Result<
        unsafe extern "C" fn(
            Str: *const ::std::os::raw::c_char,
            Length: ::std::os::raw::c_uint,
            DontNullTerminate: LLVMBool,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMIsConstantString:
        Result<unsafe extern "C" fn(c: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMGetAsString: Result<
        unsafe extern "C" fn(c: LLVMValueRef, Length: *mut usize) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMConstStructInContext: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            ConstantVals: *mut LLVMValueRef,
            Count: ::std::os::raw::c_uint,
            Packed: LLVMBool,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstStruct: Result<
        unsafe extern "C" fn(
            ConstantVals: *mut LLVMValueRef,
            Count: ::std::os::raw::c_uint,
            Packed: LLVMBool,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstArray: Result<
        unsafe extern "C" fn(
            ElementTy: LLVMTypeRef,
            ConstantVals: *mut LLVMValueRef,
            Length: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstArray2: Result<
        unsafe extern "C" fn(
            ElementTy: LLVMTypeRef,
            ConstantVals: *mut LLVMValueRef,
            Length: u64,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstNamedStruct: Result<
        unsafe extern "C" fn(
            StructTy: LLVMTypeRef,
            ConstantVals: *mut LLVMValueRef,
            Count: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetAggregateElement: Result<
        unsafe extern "C" fn(C: LLVMValueRef, Idx: ::std::os::raw::c_uint) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetElementAsConstant: Result<
        unsafe extern "C" fn(C: LLVMValueRef, idx: ::std::os::raw::c_uint) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstVector: Result<
        unsafe extern "C" fn(
            ScalarConstantVals: *mut LLVMValueRef,
            Size: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetConstOpcode:
        Result<unsafe extern "C" fn(ConstantVal: LLVMValueRef) -> LLVMOpcode, ::libloading::Error>,
    pub LLVMAlignOf:
        Result<unsafe extern "C" fn(Ty: LLVMTypeRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMSizeOf:
        Result<unsafe extern "C" fn(Ty: LLVMTypeRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMConstNeg: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstNSWNeg: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstNUWNeg: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstNot: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstAdd: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstNSWAdd: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstNUWAdd: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstSub: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstNSWSub: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstNUWSub: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstMul: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstNSWMul: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstNUWMul: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstAnd: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstOr: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstXor: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstICmp: Result<
        unsafe extern "C" fn(
            Predicate: LLVMIntPredicate,
            LHSConstant: LLVMValueRef,
            RHSConstant: LLVMValueRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstFCmp: Result<
        unsafe extern "C" fn(
            Predicate: LLVMRealPredicate,
            LHSConstant: LLVMValueRef,
            RHSConstant: LLVMValueRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstShl: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstLShr: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstAShr: Result<
        unsafe extern "C" fn(LHSConstant: LLVMValueRef, RHSConstant: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstGEP2: Result<
        unsafe extern "C" fn(
            Ty: LLVMTypeRef,
            ConstantVal: LLVMValueRef,
            ConstantIndices: *mut LLVMValueRef,
            NumIndices: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstInBoundsGEP2: Result<
        unsafe extern "C" fn(
            Ty: LLVMTypeRef,
            ConstantVal: LLVMValueRef,
            ConstantIndices: *mut LLVMValueRef,
            NumIndices: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstTrunc: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstSExt: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstZExt: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstFPTrunc: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstFPExt: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstUIToFP: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstSIToFP: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstFPToUI: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstFPToSI: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstPtrToInt: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstIntToPtr: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstBitCast: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstAddrSpaceCast: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstZExtOrBitCast: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstSExtOrBitCast: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstTruncOrBitCast: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstPointerCast: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstIntCast: Result<
        unsafe extern "C" fn(
            ConstantVal: LLVMValueRef,
            ToType: LLVMTypeRef,
            isSigned: LLVMBool,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstFPCast: Result<
        unsafe extern "C" fn(ConstantVal: LLVMValueRef, ToType: LLVMTypeRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstExtractElement: Result<
        unsafe extern "C" fn(
            VectorConstant: LLVMValueRef,
            IndexConstant: LLVMValueRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstInsertElement: Result<
        unsafe extern "C" fn(
            VectorConstant: LLVMValueRef,
            ElementValueConstant: LLVMValueRef,
            IndexConstant: LLVMValueRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstShuffleVector: Result<
        unsafe extern "C" fn(
            VectorAConstant: LLVMValueRef,
            VectorBConstant: LLVMValueRef,
            MaskConstant: LLVMValueRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBlockAddress: Result<
        unsafe extern "C" fn(F: LLVMValueRef, BB: LLVMBasicBlockRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMConstInlineAsm: Result<
        unsafe extern "C" fn(
            Ty: LLVMTypeRef,
            AsmString: *const ::std::os::raw::c_char,
            Constraints: *const ::std::os::raw::c_char,
            HasSideEffects: LLVMBool,
            IsAlignStack: LLVMBool,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetGlobalParent:
        Result<unsafe extern "C" fn(Global: LLVMValueRef) -> LLVMModuleRef, ::libloading::Error>,
    pub LLVMIsDeclaration:
        Result<unsafe extern "C" fn(Global: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMGetLinkage:
        Result<unsafe extern "C" fn(Global: LLVMValueRef) -> LLVMLinkage, ::libloading::Error>,
    pub LLVMSetLinkage: Result<
        unsafe extern "C" fn(Global: LLVMValueRef, Linkage: LLVMLinkage),
        ::libloading::Error,
    >,
    pub LLVMGetSection: Result<
        unsafe extern "C" fn(Global: LLVMValueRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMSetSection: Result<
        unsafe extern "C" fn(Global: LLVMValueRef, Section: *const ::std::os::raw::c_char),
        ::libloading::Error,
    >,
    pub LLVMGetVisibility:
        Result<unsafe extern "C" fn(Global: LLVMValueRef) -> LLVMVisibility, ::libloading::Error>,
    pub LLVMSetVisibility: Result<
        unsafe extern "C" fn(Global: LLVMValueRef, Viz: LLVMVisibility),
        ::libloading::Error,
    >,
    pub LLVMGetDLLStorageClass: Result<
        unsafe extern "C" fn(Global: LLVMValueRef) -> LLVMDLLStorageClass,
        ::libloading::Error,
    >,
    pub LLVMSetDLLStorageClass: Result<
        unsafe extern "C" fn(Global: LLVMValueRef, Class: LLVMDLLStorageClass),
        ::libloading::Error,
    >,
    pub LLVMGetUnnamedAddress:
        Result<unsafe extern "C" fn(Global: LLVMValueRef) -> LLVMUnnamedAddr, ::libloading::Error>,
    pub LLVMSetUnnamedAddress: Result<
        unsafe extern "C" fn(Global: LLVMValueRef, UnnamedAddr: LLVMUnnamedAddr),
        ::libloading::Error,
    >,
    pub LLVMGlobalGetValueType:
        Result<unsafe extern "C" fn(Global: LLVMValueRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMHasUnnamedAddr:
        Result<unsafe extern "C" fn(Global: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMSetUnnamedAddr: Result<
        unsafe extern "C" fn(Global: LLVMValueRef, HasUnnamedAddr: LLVMBool),
        ::libloading::Error,
    >,
    pub LLVMGetAlignment: Result<
        unsafe extern "C" fn(V: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMSetAlignment: Result<
        unsafe extern "C" fn(V: LLVMValueRef, Bytes: ::std::os::raw::c_uint),
        ::libloading::Error,
    >,
    pub LLVMGlobalSetMetadata: Result<
        unsafe extern "C" fn(
            Global: LLVMValueRef,
            Kind: ::std::os::raw::c_uint,
            MD: LLVMMetadataRef,
        ),
        ::libloading::Error,
    >,
    pub LLVMGlobalEraseMetadata: Result<
        unsafe extern "C" fn(Global: LLVMValueRef, Kind: ::std::os::raw::c_uint),
        ::libloading::Error,
    >,
    pub LLVMGlobalClearMetadata:
        Result<unsafe extern "C" fn(Global: LLVMValueRef), ::libloading::Error>,
    pub LLVMGlobalCopyAllMetadata: Result<
        unsafe extern "C" fn(
            Value: LLVMValueRef,
            NumEntries: *mut usize,
        ) -> *mut LLVMValueMetadataEntry,
        ::libloading::Error,
    >,
    pub LLVMDisposeValueMetadataEntries:
        Result<unsafe extern "C" fn(Entries: *mut LLVMValueMetadataEntry), ::libloading::Error>,
    pub LLVMValueMetadataEntriesGetKind: Result<
        unsafe extern "C" fn(
            Entries: *mut LLVMValueMetadataEntry,
            Index: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMValueMetadataEntriesGetMetadata: Result<
        unsafe extern "C" fn(
            Entries: *mut LLVMValueMetadataEntry,
            Index: ::std::os::raw::c_uint,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMAddGlobal: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Ty: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMAddGlobalInAddressSpace: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Ty: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
            AddressSpace: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetNamedGlobal: Result<
        unsafe extern "C" fn(M: LLVMModuleRef, Name: *const ::std::os::raw::c_char) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetFirstGlobal:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetLastGlobal:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetNextGlobal:
        Result<unsafe extern "C" fn(GlobalVar: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetPreviousGlobal:
        Result<unsafe extern "C" fn(GlobalVar: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMDeleteGlobal:
        Result<unsafe extern "C" fn(GlobalVar: LLVMValueRef), ::libloading::Error>,
    pub LLVMGetInitializer:
        Result<unsafe extern "C" fn(GlobalVar: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMSetInitializer: Result<
        unsafe extern "C" fn(GlobalVar: LLVMValueRef, ConstantVal: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMIsThreadLocal:
        Result<unsafe extern "C" fn(GlobalVar: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMSetThreadLocal: Result<
        unsafe extern "C" fn(GlobalVar: LLVMValueRef, IsThreadLocal: LLVMBool),
        ::libloading::Error,
    >,
    pub LLVMIsGlobalConstant:
        Result<unsafe extern "C" fn(GlobalVar: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMSetGlobalConstant: Result<
        unsafe extern "C" fn(GlobalVar: LLVMValueRef, IsConstant: LLVMBool),
        ::libloading::Error,
    >,
    pub LLVMGetThreadLocalMode: Result<
        unsafe extern "C" fn(GlobalVar: LLVMValueRef) -> LLVMThreadLocalMode,
        ::libloading::Error,
    >,
    pub LLVMSetThreadLocalMode: Result<
        unsafe extern "C" fn(GlobalVar: LLVMValueRef, Mode: LLVMThreadLocalMode),
        ::libloading::Error,
    >,
    pub LLVMIsExternallyInitialized:
        Result<unsafe extern "C" fn(GlobalVar: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMSetExternallyInitialized: Result<
        unsafe extern "C" fn(GlobalVar: LLVMValueRef, IsExtInit: LLVMBool),
        ::libloading::Error,
    >,
    pub LLVMAddAlias2: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            ValueTy: LLVMTypeRef,
            AddrSpace: ::std::os::raw::c_uint,
            Aliasee: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetNamedGlobalAlias: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetFirstGlobalAlias:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetLastGlobalAlias:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetNextGlobalAlias:
        Result<unsafe extern "C" fn(GA: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetPreviousGlobalAlias:
        Result<unsafe extern "C" fn(GA: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMAliasGetAliasee:
        Result<unsafe extern "C" fn(Alias: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMAliasSetAliasee: Result<
        unsafe extern "C" fn(Alias: LLVMValueRef, Aliasee: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMDeleteFunction: Result<unsafe extern "C" fn(Fn: LLVMValueRef), ::libloading::Error>,
    pub LLVMHasPersonalityFn:
        Result<unsafe extern "C" fn(Fn: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMGetPersonalityFn:
        Result<unsafe extern "C" fn(Fn: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMSetPersonalityFn: Result<
        unsafe extern "C" fn(Fn: LLVMValueRef, PersonalityFn: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMLookupIntrinsicID: Result<
        unsafe extern "C" fn(
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
        ) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetIntrinsicID: Result<
        unsafe extern "C" fn(Fn: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetIntrinsicDeclaration: Result<
        unsafe extern "C" fn(
            Mod: LLVMModuleRef,
            ID: ::std::os::raw::c_uint,
            ParamTypes: *mut LLVMTypeRef,
            ParamCount: usize,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMIntrinsicGetType: Result<
        unsafe extern "C" fn(
            Ctx: LLVMContextRef,
            ID: ::std::os::raw::c_uint,
            ParamTypes: *mut LLVMTypeRef,
            ParamCount: usize,
        ) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMIntrinsicGetName: Result<
        unsafe extern "C" fn(
            ID: ::std::os::raw::c_uint,
            NameLength: *mut usize,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMIntrinsicCopyOverloadedName: Result<
        unsafe extern "C" fn(
            ID: ::std::os::raw::c_uint,
            ParamTypes: *mut LLVMTypeRef,
            ParamCount: usize,
            NameLength: *mut usize,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMIntrinsicCopyOverloadedName2: Result<
        unsafe extern "C" fn(
            Mod: LLVMModuleRef,
            ID: ::std::os::raw::c_uint,
            ParamTypes: *mut LLVMTypeRef,
            ParamCount: usize,
            NameLength: *mut usize,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMIntrinsicIsOverloaded:
        Result<unsafe extern "C" fn(ID: ::std::os::raw::c_uint) -> LLVMBool, ::libloading::Error>,
    pub LLVMGetFunctionCallConv: Result<
        unsafe extern "C" fn(Fn: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMSetFunctionCallConv: Result<
        unsafe extern "C" fn(Fn: LLVMValueRef, CC: ::std::os::raw::c_uint),
        ::libloading::Error,
    >,
    pub LLVMGetGC: Result<
        unsafe extern "C" fn(Fn: LLVMValueRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMSetGC: Result<
        unsafe extern "C" fn(Fn: LLVMValueRef, Name: *const ::std::os::raw::c_char),
        ::libloading::Error,
    >,
    pub LLVMAddAttributeAtIndex: Result<
        unsafe extern "C" fn(F: LLVMValueRef, Idx: LLVMAttributeIndex, A: LLVMAttributeRef),
        ::libloading::Error,
    >,
    pub LLVMGetAttributeCountAtIndex: Result<
        unsafe extern "C" fn(F: LLVMValueRef, Idx: LLVMAttributeIndex) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetAttributesAtIndex: Result<
        unsafe extern "C" fn(
            F: LLVMValueRef,
            Idx: LLVMAttributeIndex,
            Attrs: *mut LLVMAttributeRef,
        ),
        ::libloading::Error,
    >,
    pub LLVMGetEnumAttributeAtIndex: Result<
        unsafe extern "C" fn(
            F: LLVMValueRef,
            Idx: LLVMAttributeIndex,
            KindID: ::std::os::raw::c_uint,
        ) -> LLVMAttributeRef,
        ::libloading::Error,
    >,
    pub LLVMGetStringAttributeAtIndex: Result<
        unsafe extern "C" fn(
            F: LLVMValueRef,
            Idx: LLVMAttributeIndex,
            K: *const ::std::os::raw::c_char,
            KLen: ::std::os::raw::c_uint,
        ) -> LLVMAttributeRef,
        ::libloading::Error,
    >,
    pub LLVMRemoveEnumAttributeAtIndex: Result<
        unsafe extern "C" fn(
            F: LLVMValueRef,
            Idx: LLVMAttributeIndex,
            KindID: ::std::os::raw::c_uint,
        ),
        ::libloading::Error,
    >,
    pub LLVMRemoveStringAttributeAtIndex: Result<
        unsafe extern "C" fn(
            F: LLVMValueRef,
            Idx: LLVMAttributeIndex,
            K: *const ::std::os::raw::c_char,
            KLen: ::std::os::raw::c_uint,
        ),
        ::libloading::Error,
    >,
    pub LLVMAddTargetDependentFunctionAttr: Result<
        unsafe extern "C" fn(
            Fn: LLVMValueRef,
            A: *const ::std::os::raw::c_char,
            V: *const ::std::os::raw::c_char,
        ),
        ::libloading::Error,
    >,
    pub LLVMCountParams: Result<
        unsafe extern "C" fn(Fn: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetParams: Result<
        unsafe extern "C" fn(Fn: LLVMValueRef, Params: *mut LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMGetParam: Result<
        unsafe extern "C" fn(Fn: LLVMValueRef, Index: ::std::os::raw::c_uint) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetParamParent:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetFirstParam:
        Result<unsafe extern "C" fn(Fn: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetLastParam:
        Result<unsafe extern "C" fn(Fn: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetNextParam:
        Result<unsafe extern "C" fn(Arg: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetPreviousParam:
        Result<unsafe extern "C" fn(Arg: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMSetParamAlignment: Result<
        unsafe extern "C" fn(Arg: LLVMValueRef, Align: ::std::os::raw::c_uint),
        ::libloading::Error,
    >,
    pub LLVMAddGlobalIFunc: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            Ty: LLVMTypeRef,
            AddrSpace: ::std::os::raw::c_uint,
            Resolver: LLVMValueRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetNamedGlobalIFunc: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetFirstGlobalIFunc:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetLastGlobalIFunc:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetNextGlobalIFunc:
        Result<unsafe extern "C" fn(IFunc: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetPreviousGlobalIFunc:
        Result<unsafe extern "C" fn(IFunc: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetGlobalIFuncResolver:
        Result<unsafe extern "C" fn(IFunc: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMSetGlobalIFuncResolver: Result<
        unsafe extern "C" fn(IFunc: LLVMValueRef, Resolver: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMEraseGlobalIFunc:
        Result<unsafe extern "C" fn(IFunc: LLVMValueRef), ::libloading::Error>,
    pub LLVMRemoveGlobalIFunc:
        Result<unsafe extern "C" fn(IFunc: LLVMValueRef), ::libloading::Error>,
    pub LLVMMDStringInContext2: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            Str: *const ::std::os::raw::c_char,
            SLen: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMMDNodeInContext2: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            MDs: *mut LLVMMetadataRef,
            Count: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMMetadataAsValue: Result<
        unsafe extern "C" fn(C: LLVMContextRef, MD: LLVMMetadataRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMValueAsMetadata:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMMetadataRef, ::libloading::Error>,
    pub LLVMGetMDString: Result<
        unsafe extern "C" fn(
            V: LLVMValueRef,
            Length: *mut ::std::os::raw::c_uint,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetMDNodeNumOperands: Result<
        unsafe extern "C" fn(V: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetMDNodeOperands:
        Result<unsafe extern "C" fn(V: LLVMValueRef, Dest: *mut LLVMValueRef), ::libloading::Error>,
    pub LLVMReplaceMDNodeOperandWith: Result<
        unsafe extern "C" fn(
            V: LLVMValueRef,
            Index: ::std::os::raw::c_uint,
            Replacement: LLVMMetadataRef,
        ),
        ::libloading::Error,
    >,
    pub LLVMMDStringInContext: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            Str: *const ::std::os::raw::c_char,
            SLen: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMMDString: Result<
        unsafe extern "C" fn(
            Str: *const ::std::os::raw::c_char,
            SLen: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMMDNodeInContext: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            Vals: *mut LLVMValueRef,
            Count: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMMDNode: Result<
        unsafe extern "C" fn(
            Vals: *mut LLVMValueRef,
            Count: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBasicBlockAsValue:
        Result<unsafe extern "C" fn(BB: LLVMBasicBlockRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMValueIsBasicBlock:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMValueAsBasicBlock:
        Result<unsafe extern "C" fn(Val: LLVMValueRef) -> LLVMBasicBlockRef, ::libloading::Error>,
    pub LLVMGetBasicBlockName: Result<
        unsafe extern "C" fn(BB: LLVMBasicBlockRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetBasicBlockParent:
        Result<unsafe extern "C" fn(BB: LLVMBasicBlockRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetBasicBlockTerminator:
        Result<unsafe extern "C" fn(BB: LLVMBasicBlockRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMCountBasicBlocks: Result<
        unsafe extern "C" fn(Fn: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetBasicBlocks: Result<
        unsafe extern "C" fn(Fn: LLVMValueRef, BasicBlocks: *mut LLVMBasicBlockRef),
        ::libloading::Error,
    >,
    pub LLVMGetFirstBasicBlock:
        Result<unsafe extern "C" fn(Fn: LLVMValueRef) -> LLVMBasicBlockRef, ::libloading::Error>,
    pub LLVMGetLastBasicBlock:
        Result<unsafe extern "C" fn(Fn: LLVMValueRef) -> LLVMBasicBlockRef, ::libloading::Error>,
    pub LLVMGetNextBasicBlock: Result<
        unsafe extern "C" fn(BB: LLVMBasicBlockRef) -> LLVMBasicBlockRef,
        ::libloading::Error,
    >,
    pub LLVMGetPreviousBasicBlock: Result<
        unsafe extern "C" fn(BB: LLVMBasicBlockRef) -> LLVMBasicBlockRef,
        ::libloading::Error,
    >,
    pub LLVMGetEntryBasicBlock:
        Result<unsafe extern "C" fn(Fn: LLVMValueRef) -> LLVMBasicBlockRef, ::libloading::Error>,
    pub LLVMInsertExistingBasicBlockAfterInsertBlock: Result<
        unsafe extern "C" fn(Builder: LLVMBuilderRef, BB: LLVMBasicBlockRef),
        ::libloading::Error,
    >,
    pub LLVMAppendExistingBasicBlock:
        Result<unsafe extern "C" fn(Fn: LLVMValueRef, BB: LLVMBasicBlockRef), ::libloading::Error>,
    pub LLVMCreateBasicBlockInContext: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMBasicBlockRef,
        ::libloading::Error,
    >,
    pub LLVMAppendBasicBlockInContext: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            Fn: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMBasicBlockRef,
        ::libloading::Error,
    >,
    pub LLVMAppendBasicBlock: Result<
        unsafe extern "C" fn(
            Fn: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMBasicBlockRef,
        ::libloading::Error,
    >,
    pub LLVMInsertBasicBlockInContext: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            BB: LLVMBasicBlockRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMBasicBlockRef,
        ::libloading::Error,
    >,
    pub LLVMInsertBasicBlock: Result<
        unsafe extern "C" fn(
            InsertBeforeBB: LLVMBasicBlockRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMBasicBlockRef,
        ::libloading::Error,
    >,
    pub LLVMDeleteBasicBlock:
        Result<unsafe extern "C" fn(BB: LLVMBasicBlockRef), ::libloading::Error>,
    pub LLVMRemoveBasicBlockFromParent:
        Result<unsafe extern "C" fn(BB: LLVMBasicBlockRef), ::libloading::Error>,
    pub LLVMMoveBasicBlockBefore: Result<
        unsafe extern "C" fn(BB: LLVMBasicBlockRef, MovePos: LLVMBasicBlockRef),
        ::libloading::Error,
    >,
    pub LLVMMoveBasicBlockAfter: Result<
        unsafe extern "C" fn(BB: LLVMBasicBlockRef, MovePos: LLVMBasicBlockRef),
        ::libloading::Error,
    >,
    pub LLVMGetFirstInstruction:
        Result<unsafe extern "C" fn(BB: LLVMBasicBlockRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetLastInstruction:
        Result<unsafe extern "C" fn(BB: LLVMBasicBlockRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMHasMetadata: Result<
        unsafe extern "C" fn(Val: LLVMValueRef) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub LLVMGetMetadata: Result<
        unsafe extern "C" fn(Val: LLVMValueRef, KindID: ::std::os::raw::c_uint) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMSetMetadata: Result<
        unsafe extern "C" fn(Val: LLVMValueRef, KindID: ::std::os::raw::c_uint, Node: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMInstructionGetAllMetadataOtherThanDebugLoc: Result<
        unsafe extern "C" fn(
            Instr: LLVMValueRef,
            NumEntries: *mut usize,
        ) -> *mut LLVMValueMetadataEntry,
        ::libloading::Error,
    >,
    pub LLVMGetInstructionParent:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef) -> LLVMBasicBlockRef, ::libloading::Error>,
    pub LLVMGetNextInstruction:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetPreviousInstruction:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMInstructionRemoveFromParent:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef), ::libloading::Error>,
    pub LLVMInstructionEraseFromParent:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef), ::libloading::Error>,
    pub LLVMDeleteInstruction:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef), ::libloading::Error>,
    pub LLVMGetInstructionOpcode:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef) -> LLVMOpcode, ::libloading::Error>,
    pub LLVMGetICmpPredicate:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef) -> LLVMIntPredicate, ::libloading::Error>,
    pub LLVMGetFCmpPredicate:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef) -> LLVMRealPredicate, ::libloading::Error>,
    pub LLVMInstructionClone:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsATerminatorInst:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMGetNumArgOperands: Result<
        unsafe extern "C" fn(Instr: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMSetInstructionCallConv: Result<
        unsafe extern "C" fn(Instr: LLVMValueRef, CC: ::std::os::raw::c_uint),
        ::libloading::Error,
    >,
    pub LLVMGetInstructionCallConv: Result<
        unsafe extern "C" fn(Instr: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMSetInstrParamAlignment: Result<
        unsafe extern "C" fn(
            Instr: LLVMValueRef,
            Idx: LLVMAttributeIndex,
            Align: ::std::os::raw::c_uint,
        ),
        ::libloading::Error,
    >,
    pub LLVMAddCallSiteAttribute: Result<
        unsafe extern "C" fn(C: LLVMValueRef, Idx: LLVMAttributeIndex, A: LLVMAttributeRef),
        ::libloading::Error,
    >,
    pub LLVMGetCallSiteAttributeCount: Result<
        unsafe extern "C" fn(C: LLVMValueRef, Idx: LLVMAttributeIndex) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetCallSiteAttributes: Result<
        unsafe extern "C" fn(
            C: LLVMValueRef,
            Idx: LLVMAttributeIndex,
            Attrs: *mut LLVMAttributeRef,
        ),
        ::libloading::Error,
    >,
    pub LLVMGetCallSiteEnumAttribute: Result<
        unsafe extern "C" fn(
            C: LLVMValueRef,
            Idx: LLVMAttributeIndex,
            KindID: ::std::os::raw::c_uint,
        ) -> LLVMAttributeRef,
        ::libloading::Error,
    >,
    pub LLVMGetCallSiteStringAttribute: Result<
        unsafe extern "C" fn(
            C: LLVMValueRef,
            Idx: LLVMAttributeIndex,
            K: *const ::std::os::raw::c_char,
            KLen: ::std::os::raw::c_uint,
        ) -> LLVMAttributeRef,
        ::libloading::Error,
    >,
    pub LLVMRemoveCallSiteEnumAttribute: Result<
        unsafe extern "C" fn(
            C: LLVMValueRef,
            Idx: LLVMAttributeIndex,
            KindID: ::std::os::raw::c_uint,
        ),
        ::libloading::Error,
    >,
    pub LLVMRemoveCallSiteStringAttribute: Result<
        unsafe extern "C" fn(
            C: LLVMValueRef,
            Idx: LLVMAttributeIndex,
            K: *const ::std::os::raw::c_char,
            KLen: ::std::os::raw::c_uint,
        ),
        ::libloading::Error,
    >,
    pub LLVMGetCalledFunctionType:
        Result<unsafe extern "C" fn(C: LLVMValueRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMGetCalledValue:
        Result<unsafe extern "C" fn(Instr: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMIsTailCall:
        Result<unsafe extern "C" fn(CallInst: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMSetTailCall: Result<
        unsafe extern "C" fn(CallInst: LLVMValueRef, IsTailCall: LLVMBool),
        ::libloading::Error,
    >,
    pub LLVMGetNormalDest: Result<
        unsafe extern "C" fn(InvokeInst: LLVMValueRef) -> LLVMBasicBlockRef,
        ::libloading::Error,
    >,
    pub LLVMGetUnwindDest: Result<
        unsafe extern "C" fn(InvokeInst: LLVMValueRef) -> LLVMBasicBlockRef,
        ::libloading::Error,
    >,
    pub LLVMSetNormalDest: Result<
        unsafe extern "C" fn(InvokeInst: LLVMValueRef, B: LLVMBasicBlockRef),
        ::libloading::Error,
    >,
    pub LLVMSetUnwindDest: Result<
        unsafe extern "C" fn(InvokeInst: LLVMValueRef, B: LLVMBasicBlockRef),
        ::libloading::Error,
    >,
    pub LLVMGetNumSuccessors: Result<
        unsafe extern "C" fn(Term: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetSuccessor: Result<
        unsafe extern "C" fn(Term: LLVMValueRef, i: ::std::os::raw::c_uint) -> LLVMBasicBlockRef,
        ::libloading::Error,
    >,
    pub LLVMSetSuccessor: Result<
        unsafe extern "C" fn(
            Term: LLVMValueRef,
            i: ::std::os::raw::c_uint,
            block: LLVMBasicBlockRef,
        ),
        ::libloading::Error,
    >,
    pub LLVMIsConditional:
        Result<unsafe extern "C" fn(Branch: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMGetCondition:
        Result<unsafe extern "C" fn(Branch: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMSetCondition:
        Result<unsafe extern "C" fn(Branch: LLVMValueRef, Cond: LLVMValueRef), ::libloading::Error>,
    pub LLVMGetSwitchDefaultDest: Result<
        unsafe extern "C" fn(SwitchInstr: LLVMValueRef) -> LLVMBasicBlockRef,
        ::libloading::Error,
    >,
    pub LLVMGetAllocatedType:
        Result<unsafe extern "C" fn(Alloca: LLVMValueRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMIsInBounds:
        Result<unsafe extern "C" fn(GEP: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMSetIsInBounds:
        Result<unsafe extern "C" fn(GEP: LLVMValueRef, InBounds: LLVMBool), ::libloading::Error>,
    pub LLVMGetGEPSourceElementType:
        Result<unsafe extern "C" fn(GEP: LLVMValueRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMAddIncoming: Result<
        unsafe extern "C" fn(
            PhiNode: LLVMValueRef,
            IncomingValues: *mut LLVMValueRef,
            IncomingBlocks: *mut LLVMBasicBlockRef,
            Count: ::std::os::raw::c_uint,
        ),
        ::libloading::Error,
    >,
    pub LLVMCountIncoming: Result<
        unsafe extern "C" fn(PhiNode: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetIncomingValue: Result<
        unsafe extern "C" fn(PhiNode: LLVMValueRef, Index: ::std::os::raw::c_uint) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetIncomingBlock: Result<
        unsafe extern "C" fn(
            PhiNode: LLVMValueRef,
            Index: ::std::os::raw::c_uint,
        ) -> LLVMBasicBlockRef,
        ::libloading::Error,
    >,
    pub LLVMGetNumIndices: Result<
        unsafe extern "C" fn(Inst: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetIndices: Result<
        unsafe extern "C" fn(Inst: LLVMValueRef) -> *const ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMCreateBuilderInContext:
        Result<unsafe extern "C" fn(C: LLVMContextRef) -> LLVMBuilderRef, ::libloading::Error>,
    pub LLVMCreateBuilder: Result<unsafe extern "C" fn() -> LLVMBuilderRef, ::libloading::Error>,
    pub LLVMPositionBuilder: Result<
        unsafe extern "C" fn(
            Builder: LLVMBuilderRef,
            Block: LLVMBasicBlockRef,
            Instr: LLVMValueRef,
        ),
        ::libloading::Error,
    >,
    pub LLVMPositionBuilderBefore: Result<
        unsafe extern "C" fn(Builder: LLVMBuilderRef, Instr: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMPositionBuilderAtEnd: Result<
        unsafe extern "C" fn(Builder: LLVMBuilderRef, Block: LLVMBasicBlockRef),
        ::libloading::Error,
    >,
    pub LLVMGetInsertBlock: Result<
        unsafe extern "C" fn(Builder: LLVMBuilderRef) -> LLVMBasicBlockRef,
        ::libloading::Error,
    >,
    pub LLVMClearInsertionPosition:
        Result<unsafe extern "C" fn(Builder: LLVMBuilderRef), ::libloading::Error>,
    pub LLVMInsertIntoBuilder: Result<
        unsafe extern "C" fn(Builder: LLVMBuilderRef, Instr: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMInsertIntoBuilderWithName: Result<
        unsafe extern "C" fn(
            Builder: LLVMBuilderRef,
            Instr: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ),
        ::libloading::Error,
    >,
    pub LLVMDisposeBuilder:
        Result<unsafe extern "C" fn(Builder: LLVMBuilderRef), ::libloading::Error>,
    pub LLVMGetCurrentDebugLocation2: Result<
        unsafe extern "C" fn(Builder: LLVMBuilderRef) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMSetCurrentDebugLocation2: Result<
        unsafe extern "C" fn(Builder: LLVMBuilderRef, Loc: LLVMMetadataRef),
        ::libloading::Error,
    >,
    pub LLVMSetInstDebugLocation: Result<
        unsafe extern "C" fn(Builder: LLVMBuilderRef, Inst: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMAddMetadataToInst: Result<
        unsafe extern "C" fn(Builder: LLVMBuilderRef, Inst: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMBuilderGetDefaultFPMathTag: Result<
        unsafe extern "C" fn(Builder: LLVMBuilderRef) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMBuilderSetDefaultFPMathTag: Result<
        unsafe extern "C" fn(Builder: LLVMBuilderRef, FPMathTag: LLVMMetadataRef),
        ::libloading::Error,
    >,
    pub LLVMSetCurrentDebugLocation:
        Result<unsafe extern "C" fn(Builder: LLVMBuilderRef, L: LLVMValueRef), ::libloading::Error>,
    pub LLVMGetCurrentDebugLocation:
        Result<unsafe extern "C" fn(Builder: LLVMBuilderRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMBuildRetVoid:
        Result<unsafe extern "C" fn(arg1: LLVMBuilderRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMBuildRet: Result<
        unsafe extern "C" fn(arg1: LLVMBuilderRef, V: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildAggregateRet: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            RetVals: *mut LLVMValueRef,
            N: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildBr: Result<
        unsafe extern "C" fn(arg1: LLVMBuilderRef, Dest: LLVMBasicBlockRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildCondBr: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            If: LLVMValueRef,
            Then: LLVMBasicBlockRef,
            Else: LLVMBasicBlockRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildSwitch: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            V: LLVMValueRef,
            Else: LLVMBasicBlockRef,
            NumCases: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildIndirectBr: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            Addr: LLVMValueRef,
            NumDests: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildInvoke2: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Ty: LLVMTypeRef,
            Fn: LLVMValueRef,
            Args: *mut LLVMValueRef,
            NumArgs: ::std::os::raw::c_uint,
            Then: LLVMBasicBlockRef,
            Catch: LLVMBasicBlockRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildUnreachable:
        Result<unsafe extern "C" fn(arg1: LLVMBuilderRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMBuildResume: Result<
        unsafe extern "C" fn(B: LLVMBuilderRef, Exn: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildLandingPad: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            Ty: LLVMTypeRef,
            PersFn: LLVMValueRef,
            NumClauses: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildCleanupRet: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            CatchPad: LLVMValueRef,
            BB: LLVMBasicBlockRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildCatchRet: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            CatchPad: LLVMValueRef,
            BB: LLVMBasicBlockRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildCatchPad: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            ParentPad: LLVMValueRef,
            Args: *mut LLVMValueRef,
            NumArgs: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildCleanupPad: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            ParentPad: LLVMValueRef,
            Args: *mut LLVMValueRef,
            NumArgs: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildCatchSwitch: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            ParentPad: LLVMValueRef,
            UnwindBB: LLVMBasicBlockRef,
            NumHandlers: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMAddCase: Result<
        unsafe extern "C" fn(Switch: LLVMValueRef, OnVal: LLVMValueRef, Dest: LLVMBasicBlockRef),
        ::libloading::Error,
    >,
    pub LLVMAddDestination: Result<
        unsafe extern "C" fn(IndirectBr: LLVMValueRef, Dest: LLVMBasicBlockRef),
        ::libloading::Error,
    >,
    pub LLVMGetNumClauses: Result<
        unsafe extern "C" fn(LandingPad: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetClause: Result<
        unsafe extern "C" fn(LandingPad: LLVMValueRef, Idx: ::std::os::raw::c_uint) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMAddClause: Result<
        unsafe extern "C" fn(LandingPad: LLVMValueRef, ClauseVal: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMIsCleanup:
        Result<unsafe extern "C" fn(LandingPad: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMSetCleanup:
        Result<unsafe extern "C" fn(LandingPad: LLVMValueRef, Val: LLVMBool), ::libloading::Error>,
    pub LLVMAddHandler: Result<
        unsafe extern "C" fn(CatchSwitch: LLVMValueRef, Dest: LLVMBasicBlockRef),
        ::libloading::Error,
    >,
    pub LLVMGetNumHandlers: Result<
        unsafe extern "C" fn(CatchSwitch: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetHandlers: Result<
        unsafe extern "C" fn(CatchSwitch: LLVMValueRef, Handlers: *mut LLVMBasicBlockRef),
        ::libloading::Error,
    >,
    pub LLVMGetArgOperand: Result<
        unsafe extern "C" fn(Funclet: LLVMValueRef, i: ::std::os::raw::c_uint) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMSetArgOperand: Result<
        unsafe extern "C" fn(Funclet: LLVMValueRef, i: ::std::os::raw::c_uint, value: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMGetParentCatchSwitch:
        Result<unsafe extern "C" fn(CatchPad: LLVMValueRef) -> LLVMValueRef, ::libloading::Error>,
    pub LLVMSetParentCatchSwitch: Result<
        unsafe extern "C" fn(CatchPad: LLVMValueRef, CatchSwitch: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMBuildAdd: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildNSWAdd: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildNUWAdd: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFAdd: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildSub: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildNSWSub: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildNUWSub: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFSub: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildMul: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildNSWMul: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildNUWMul: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFMul: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildUDiv: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildExactUDiv: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildSDiv: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildExactSDiv: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFDiv: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildURem: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildSRem: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFRem: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildShl: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildLShr: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildAShr: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildAnd: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildOr: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildXor: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildBinOp: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            Op: LLVMOpcode,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildNeg: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            V: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildNSWNeg: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            V: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildNUWNeg: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            V: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFNeg: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            V: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildNot: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            V: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetNUW:
        Result<unsafe extern "C" fn(ArithInst: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMSetNUW: Result<
        unsafe extern "C" fn(ArithInst: LLVMValueRef, HasNUW: LLVMBool),
        ::libloading::Error,
    >,
    pub LLVMGetNSW:
        Result<unsafe extern "C" fn(ArithInst: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMSetNSW: Result<
        unsafe extern "C" fn(ArithInst: LLVMValueRef, HasNSW: LLVMBool),
        ::libloading::Error,
    >,
    pub LLVMGetExact:
        Result<unsafe extern "C" fn(DivOrShrInst: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMSetExact: Result<
        unsafe extern "C" fn(DivOrShrInst: LLVMValueRef, IsExact: LLVMBool),
        ::libloading::Error,
    >,
    pub LLVMBuildMalloc: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Ty: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildArrayMalloc: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Ty: LLVMTypeRef,
            Val: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildMemSet: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            Ptr: LLVMValueRef,
            Val: LLVMValueRef,
            Len: LLVMValueRef,
            Align: ::std::os::raw::c_uint,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildMemCpy: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            Dst: LLVMValueRef,
            DstAlign: ::std::os::raw::c_uint,
            Src: LLVMValueRef,
            SrcAlign: ::std::os::raw::c_uint,
            Size: LLVMValueRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildMemMove: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            Dst: LLVMValueRef,
            DstAlign: ::std::os::raw::c_uint,
            Src: LLVMValueRef,
            SrcAlign: ::std::os::raw::c_uint,
            Size: LLVMValueRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildAlloca: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Ty: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildArrayAlloca: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Ty: LLVMTypeRef,
            Val: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFree: Result<
        unsafe extern "C" fn(arg1: LLVMBuilderRef, PointerVal: LLVMValueRef) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildLoad2: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Ty: LLVMTypeRef,
            PointerVal: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildStore: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            Ptr: LLVMValueRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildGEP2: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            Ty: LLVMTypeRef,
            Pointer: LLVMValueRef,
            Indices: *mut LLVMValueRef,
            NumIndices: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildInBoundsGEP2: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            Ty: LLVMTypeRef,
            Pointer: LLVMValueRef,
            Indices: *mut LLVMValueRef,
            NumIndices: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildStructGEP2: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            Ty: LLVMTypeRef,
            Pointer: LLVMValueRef,
            Idx: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildGlobalString: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            Str: *const ::std::os::raw::c_char,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildGlobalStringPtr: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            Str: *const ::std::os::raw::c_char,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetVolatile: Result<
        unsafe extern "C" fn(MemoryAccessInst: LLVMValueRef) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMSetVolatile: Result<
        unsafe extern "C" fn(MemoryAccessInst: LLVMValueRef, IsVolatile: LLVMBool),
        ::libloading::Error,
    >,
    pub LLVMGetWeak:
        Result<unsafe extern "C" fn(CmpXchgInst: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMSetWeak: Result<
        unsafe extern "C" fn(CmpXchgInst: LLVMValueRef, IsWeak: LLVMBool),
        ::libloading::Error,
    >,
    pub LLVMGetOrdering: Result<
        unsafe extern "C" fn(MemoryAccessInst: LLVMValueRef) -> LLVMAtomicOrdering,
        ::libloading::Error,
    >,
    pub LLVMSetOrdering: Result<
        unsafe extern "C" fn(MemoryAccessInst: LLVMValueRef, Ordering: LLVMAtomicOrdering),
        ::libloading::Error,
    >,
    pub LLVMGetAtomicRMWBinOp: Result<
        unsafe extern "C" fn(AtomicRMWInst: LLVMValueRef) -> LLVMAtomicRMWBinOp,
        ::libloading::Error,
    >,
    pub LLVMSetAtomicRMWBinOp: Result<
        unsafe extern "C" fn(AtomicRMWInst: LLVMValueRef, BinOp: LLVMAtomicRMWBinOp),
        ::libloading::Error,
    >,
    pub LLVMBuildTrunc: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildZExt: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildSExt: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFPToUI: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFPToSI: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildUIToFP: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildSIToFP: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFPTrunc: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFPExt: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildPtrToInt: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildIntToPtr: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildBitCast: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildAddrSpaceCast: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildZExtOrBitCast: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildSExtOrBitCast: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildTruncOrBitCast: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildCast: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            Op: LLVMOpcode,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildPointerCast: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildIntCast2: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            IsSigned: LLVMBool,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFPCast: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildIntCast: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            DestTy: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetCastOpcode: Result<
        unsafe extern "C" fn(
            Src: LLVMValueRef,
            SrcIsSigned: LLVMBool,
            DestTy: LLVMTypeRef,
            DestIsSigned: LLVMBool,
        ) -> LLVMOpcode,
        ::libloading::Error,
    >,
    pub LLVMBuildICmp: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Op: LLVMIntPredicate,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFCmp: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Op: LLVMRealPredicate,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildPhi: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Ty: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildCall2: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            arg2: LLVMTypeRef,
            Fn: LLVMValueRef,
            Args: *mut LLVMValueRef,
            NumArgs: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildSelect: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            If: LLVMValueRef,
            Then: LLVMValueRef,
            Else: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildVAArg: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            List: LLVMValueRef,
            Ty: LLVMTypeRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildExtractElement: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            VecVal: LLVMValueRef,
            Index: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildInsertElement: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            VecVal: LLVMValueRef,
            EltVal: LLVMValueRef,
            Index: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildShuffleVector: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            V1: LLVMValueRef,
            V2: LLVMValueRef,
            Mask: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildExtractValue: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            AggVal: LLVMValueRef,
            Index: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildInsertValue: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            AggVal: LLVMValueRef,
            EltVal: LLVMValueRef,
            Index: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFreeze: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildIsNull: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildIsNotNull: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            Val: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildPtrDiff2: Result<
        unsafe extern "C" fn(
            arg1: LLVMBuilderRef,
            ElemTy: LLVMTypeRef,
            LHS: LLVMValueRef,
            RHS: LLVMValueRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildFence: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            ordering: LLVMAtomicOrdering,
            singleThread: LLVMBool,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildAtomicRMW: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            op: LLVMAtomicRMWBinOp,
            PTR: LLVMValueRef,
            Val: LLVMValueRef,
            ordering: LLVMAtomicOrdering,
            singleThread: LLVMBool,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMBuildAtomicCmpXchg: Result<
        unsafe extern "C" fn(
            B: LLVMBuilderRef,
            Ptr: LLVMValueRef,
            Cmp: LLVMValueRef,
            New: LLVMValueRef,
            SuccessOrdering: LLVMAtomicOrdering,
            FailureOrdering: LLVMAtomicOrdering,
            SingleThread: LLVMBool,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMGetNumMaskElements: Result<
        unsafe extern "C" fn(ShuffleVectorInst: LLVMValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGetUndefMaskElem:
        Result<unsafe extern "C" fn() -> ::std::os::raw::c_int, ::libloading::Error>,
    pub LLVMGetMaskValue: Result<
        unsafe extern "C" fn(
            ShuffleVectorInst: LLVMValueRef,
            Elt: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub LLVMIsAtomicSingleThread:
        Result<unsafe extern "C" fn(AtomicInst: LLVMValueRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMSetAtomicSingleThread: Result<
        unsafe extern "C" fn(AtomicInst: LLVMValueRef, SingleThread: LLVMBool),
        ::libloading::Error,
    >,
    pub LLVMGetCmpXchgSuccessOrdering: Result<
        unsafe extern "C" fn(CmpXchgInst: LLVMValueRef) -> LLVMAtomicOrdering,
        ::libloading::Error,
    >,
    pub LLVMSetCmpXchgSuccessOrdering: Result<
        unsafe extern "C" fn(CmpXchgInst: LLVMValueRef, Ordering: LLVMAtomicOrdering),
        ::libloading::Error,
    >,
    pub LLVMGetCmpXchgFailureOrdering: Result<
        unsafe extern "C" fn(CmpXchgInst: LLVMValueRef) -> LLVMAtomicOrdering,
        ::libloading::Error,
    >,
    pub LLVMSetCmpXchgFailureOrdering: Result<
        unsafe extern "C" fn(CmpXchgInst: LLVMValueRef, Ordering: LLVMAtomicOrdering),
        ::libloading::Error,
    >,
    pub LLVMCreateModuleProviderForExistingModule: Result<
        unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMModuleProviderRef,
        ::libloading::Error,
    >,
    pub LLVMDisposeModuleProvider:
        Result<unsafe extern "C" fn(M: LLVMModuleProviderRef), ::libloading::Error>,
    pub LLVMCreateMemoryBufferWithContentsOfFile: Result<
        unsafe extern "C" fn(
            Path: *const ::std::os::raw::c_char,
            OutMemBuf: *mut LLVMMemoryBufferRef,
            OutMessage: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMCreateMemoryBufferWithSTDIN: Result<
        unsafe extern "C" fn(
            OutMemBuf: *mut LLVMMemoryBufferRef,
            OutMessage: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMCreateMemoryBufferWithMemoryRange: Result<
        unsafe extern "C" fn(
            InputData: *const ::std::os::raw::c_char,
            InputDataLength: usize,
            BufferName: *const ::std::os::raw::c_char,
            RequiresNullTerminator: LLVMBool,
        ) -> LLVMMemoryBufferRef,
        ::libloading::Error,
    >,
    pub LLVMCreateMemoryBufferWithMemoryRangeCopy: Result<
        unsafe extern "C" fn(
            InputData: *const ::std::os::raw::c_char,
            InputDataLength: usize,
            BufferName: *const ::std::os::raw::c_char,
        ) -> LLVMMemoryBufferRef,
        ::libloading::Error,
    >,
    pub LLVMGetBufferStart: Result<
        unsafe extern "C" fn(MemBuf: LLVMMemoryBufferRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetBufferSize:
        Result<unsafe extern "C" fn(MemBuf: LLVMMemoryBufferRef) -> usize, ::libloading::Error>,
    pub LLVMDisposeMemoryBuffer:
        Result<unsafe extern "C" fn(MemBuf: LLVMMemoryBufferRef), ::libloading::Error>,
    pub LLVMCreatePassManager:
        Result<unsafe extern "C" fn() -> LLVMPassManagerRef, ::libloading::Error>,
    pub LLVMCreateFunctionPassManagerForModule:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMPassManagerRef, ::libloading::Error>,
    pub LLVMCreateFunctionPassManager: Result<
        unsafe extern "C" fn(MP: LLVMModuleProviderRef) -> LLVMPassManagerRef,
        ::libloading::Error,
    >,
    pub LLVMRunPassManager: Result<
        unsafe extern "C" fn(PM: LLVMPassManagerRef, M: LLVMModuleRef) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMInitializeFunctionPassManager:
        Result<unsafe extern "C" fn(FPM: LLVMPassManagerRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMRunFunctionPassManager: Result<
        unsafe extern "C" fn(FPM: LLVMPassManagerRef, F: LLVMValueRef) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMFinalizeFunctionPassManager:
        Result<unsafe extern "C" fn(FPM: LLVMPassManagerRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMDisposePassManager:
        Result<unsafe extern "C" fn(PM: LLVMPassManagerRef), ::libloading::Error>,
    pub LLVMStartMultithreaded: Result<unsafe extern "C" fn() -> LLVMBool, ::libloading::Error>,
    pub LLVMStopMultithreaded: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMIsMultithreaded: Result<unsafe extern "C" fn() -> LLVMBool, ::libloading::Error>,
    pub LLVMDebugMetadataVersion:
        Result<unsafe extern "C" fn() -> ::std::os::raw::c_uint, ::libloading::Error>,
    pub LLVMGetModuleDebugMetadataVersion: Result<
        unsafe extern "C" fn(Module: LLVMModuleRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMStripModuleDebugInfo:
        Result<unsafe extern "C" fn(Module: LLVMModuleRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMCreateDIBuilderDisallowUnresolved:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMDIBuilderRef, ::libloading::Error>,
    pub LLVMCreateDIBuilder:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMDIBuilderRef, ::libloading::Error>,
    pub LLVMDisposeDIBuilder:
        Result<unsafe extern "C" fn(Builder: LLVMDIBuilderRef), ::libloading::Error>,
    pub LLVMDIBuilderFinalize:
        Result<unsafe extern "C" fn(Builder: LLVMDIBuilderRef), ::libloading::Error>,
    pub LLVMDIBuilderFinalizeSubprogram: Result<
        unsafe extern "C" fn(Builder: LLVMDIBuilderRef, Subprogram: LLVMMetadataRef),
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateCompileUnit: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Lang: LLVMDWARFSourceLanguage,
            FileRef: LLVMMetadataRef,
            Producer: *const ::std::os::raw::c_char,
            ProducerLen: usize,
            isOptimized: LLVMBool,
            Flags: *const ::std::os::raw::c_char,
            FlagsLen: usize,
            RuntimeVer: ::std::os::raw::c_uint,
            SplitName: *const ::std::os::raw::c_char,
            SplitNameLen: usize,
            Kind: LLVMDWARFEmissionKind,
            DWOId: ::std::os::raw::c_uint,
            SplitDebugInlining: LLVMBool,
            DebugInfoForProfiling: LLVMBool,
            SysRoot: *const ::std::os::raw::c_char,
            SysRootLen: usize,
            SDK: *const ::std::os::raw::c_char,
            SDKLen: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateFile: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Filename: *const ::std::os::raw::c_char,
            FilenameLen: usize,
            Directory: *const ::std::os::raw::c_char,
            DirectoryLen: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateModule: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            ParentScope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            ConfigMacros: *const ::std::os::raw::c_char,
            ConfigMacrosLen: usize,
            IncludePath: *const ::std::os::raw::c_char,
            IncludePathLen: usize,
            APINotesFile: *const ::std::os::raw::c_char,
            APINotesFileLen: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateNameSpace: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            ParentScope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            ExportSymbols: LLVMBool,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateFunction: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            LinkageName: *const ::std::os::raw::c_char,
            LinkageNameLen: usize,
            File: LLVMMetadataRef,
            LineNo: ::std::os::raw::c_uint,
            Ty: LLVMMetadataRef,
            IsLocalToUnit: LLVMBool,
            IsDefinition: LLVMBool,
            ScopeLine: ::std::os::raw::c_uint,
            Flags: LLVMDIFlags,
            IsOptimized: LLVMBool,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateLexicalBlock: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            File: LLVMMetadataRef,
            Line: ::std::os::raw::c_uint,
            Column: ::std::os::raw::c_uint,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateLexicalBlockFile: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            File: LLVMMetadataRef,
            Discriminator: ::std::os::raw::c_uint,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateImportedModuleFromNamespace: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            NS: LLVMMetadataRef,
            File: LLVMMetadataRef,
            Line: ::std::os::raw::c_uint,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateImportedModuleFromAlias: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            ImportedEntity: LLVMMetadataRef,
            File: LLVMMetadataRef,
            Line: ::std::os::raw::c_uint,
            Elements: *mut LLVMMetadataRef,
            NumElements: ::std::os::raw::c_uint,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateImportedModuleFromModule: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            M: LLVMMetadataRef,
            File: LLVMMetadataRef,
            Line: ::std::os::raw::c_uint,
            Elements: *mut LLVMMetadataRef,
            NumElements: ::std::os::raw::c_uint,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateImportedDeclaration: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            Decl: LLVMMetadataRef,
            File: LLVMMetadataRef,
            Line: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            Elements: *mut LLVMMetadataRef,
            NumElements: ::std::os::raw::c_uint,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateDebugLocation: Result<
        unsafe extern "C" fn(
            Ctx: LLVMContextRef,
            Line: ::std::os::raw::c_uint,
            Column: ::std::os::raw::c_uint,
            Scope: LLVMMetadataRef,
            InlinedAt: LLVMMetadataRef,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDILocationGetLine: Result<
        unsafe extern "C" fn(Location: LLVMMetadataRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMDILocationGetColumn: Result<
        unsafe extern "C" fn(Location: LLVMMetadataRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMDILocationGetScope: Result<
        unsafe extern "C" fn(Location: LLVMMetadataRef) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDILocationGetInlinedAt: Result<
        unsafe extern "C" fn(Location: LLVMMetadataRef) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIScopeGetFile: Result<
        unsafe extern "C" fn(Scope: LLVMMetadataRef) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIFileGetDirectory: Result<
        unsafe extern "C" fn(
            File: LLVMMetadataRef,
            Len: *mut ::std::os::raw::c_uint,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMDIFileGetFilename: Result<
        unsafe extern "C" fn(
            File: LLVMMetadataRef,
            Len: *mut ::std::os::raw::c_uint,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMDIFileGetSource: Result<
        unsafe extern "C" fn(
            File: LLVMMetadataRef,
            Len: *mut ::std::os::raw::c_uint,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderGetOrCreateTypeArray: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Data: *mut LLVMMetadataRef,
            NumElements: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateSubroutineType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            File: LLVMMetadataRef,
            ParameterTypes: *mut LLVMMetadataRef,
            NumParameterTypes: ::std::os::raw::c_uint,
            Flags: LLVMDIFlags,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateMacro: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            ParentMacroFile: LLVMMetadataRef,
            Line: ::std::os::raw::c_uint,
            RecordType: LLVMDWARFMacinfoRecordType,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            Value: *const ::std::os::raw::c_char,
            ValueLen: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateTempMacroFile: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            ParentMacroFile: LLVMMetadataRef,
            Line: ::std::os::raw::c_uint,
            File: LLVMMetadataRef,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateEnumerator: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            Value: i64,
            IsUnsigned: LLVMBool,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateEnumerationType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            File: LLVMMetadataRef,
            LineNumber: ::std::os::raw::c_uint,
            SizeInBits: u64,
            AlignInBits: u32,
            Elements: *mut LLVMMetadataRef,
            NumElements: ::std::os::raw::c_uint,
            ClassTy: LLVMMetadataRef,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateUnionType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            File: LLVMMetadataRef,
            LineNumber: ::std::os::raw::c_uint,
            SizeInBits: u64,
            AlignInBits: u32,
            Flags: LLVMDIFlags,
            Elements: *mut LLVMMetadataRef,
            NumElements: ::std::os::raw::c_uint,
            RunTimeLang: ::std::os::raw::c_uint,
            UniqueId: *const ::std::os::raw::c_char,
            UniqueIdLen: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateArrayType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Size: u64,
            AlignInBits: u32,
            Ty: LLVMMetadataRef,
            Subscripts: *mut LLVMMetadataRef,
            NumSubscripts: ::std::os::raw::c_uint,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateVectorType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Size: u64,
            AlignInBits: u32,
            Ty: LLVMMetadataRef,
            Subscripts: *mut LLVMMetadataRef,
            NumSubscripts: ::std::os::raw::c_uint,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateUnspecifiedType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateBasicType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            SizeInBits: u64,
            Encoding: LLVMDWARFTypeEncoding,
            Flags: LLVMDIFlags,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreatePointerType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            PointeeTy: LLVMMetadataRef,
            SizeInBits: u64,
            AlignInBits: u32,
            AddressSpace: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateStructType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            File: LLVMMetadataRef,
            LineNumber: ::std::os::raw::c_uint,
            SizeInBits: u64,
            AlignInBits: u32,
            Flags: LLVMDIFlags,
            DerivedFrom: LLVMMetadataRef,
            Elements: *mut LLVMMetadataRef,
            NumElements: ::std::os::raw::c_uint,
            RunTimeLang: ::std::os::raw::c_uint,
            VTableHolder: LLVMMetadataRef,
            UniqueId: *const ::std::os::raw::c_char,
            UniqueIdLen: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateMemberType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            File: LLVMMetadataRef,
            LineNo: ::std::os::raw::c_uint,
            SizeInBits: u64,
            AlignInBits: u32,
            OffsetInBits: u64,
            Flags: LLVMDIFlags,
            Ty: LLVMMetadataRef,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateStaticMemberType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            File: LLVMMetadataRef,
            LineNumber: ::std::os::raw::c_uint,
            Type: LLVMMetadataRef,
            Flags: LLVMDIFlags,
            ConstantVal: LLVMValueRef,
            AlignInBits: u32,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateMemberPointerType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            PointeeType: LLVMMetadataRef,
            ClassType: LLVMMetadataRef,
            SizeInBits: u64,
            AlignInBits: u32,
            Flags: LLVMDIFlags,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateObjCIVar: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            File: LLVMMetadataRef,
            LineNo: ::std::os::raw::c_uint,
            SizeInBits: u64,
            AlignInBits: u32,
            OffsetInBits: u64,
            Flags: LLVMDIFlags,
            Ty: LLVMMetadataRef,
            PropertyNode: LLVMMetadataRef,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateObjCProperty: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            File: LLVMMetadataRef,
            LineNo: ::std::os::raw::c_uint,
            GetterName: *const ::std::os::raw::c_char,
            GetterNameLen: usize,
            SetterName: *const ::std::os::raw::c_char,
            SetterNameLen: usize,
            PropertyAttributes: ::std::os::raw::c_uint,
            Ty: LLVMMetadataRef,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateObjectPointerType: Result<
        unsafe extern "C" fn(Builder: LLVMDIBuilderRef, Type: LLVMMetadataRef) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateQualifiedType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Tag: ::std::os::raw::c_uint,
            Type: LLVMMetadataRef,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateReferenceType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Tag: ::std::os::raw::c_uint,
            Type: LLVMMetadataRef,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateNullPtrType: Result<
        unsafe extern "C" fn(Builder: LLVMDIBuilderRef) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateTypedef: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Type: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            File: LLVMMetadataRef,
            LineNo: ::std::os::raw::c_uint,
            Scope: LLVMMetadataRef,
            AlignInBits: u32,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateInheritance: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Ty: LLVMMetadataRef,
            BaseTy: LLVMMetadataRef,
            BaseOffset: u64,
            VBPtrOffset: u32,
            Flags: LLVMDIFlags,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateForwardDecl: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Tag: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            Scope: LLVMMetadataRef,
            File: LLVMMetadataRef,
            Line: ::std::os::raw::c_uint,
            RuntimeLang: ::std::os::raw::c_uint,
            SizeInBits: u64,
            AlignInBits: u32,
            UniqueIdentifier: *const ::std::os::raw::c_char,
            UniqueIdentifierLen: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateReplaceableCompositeType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Tag: ::std::os::raw::c_uint,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            Scope: LLVMMetadataRef,
            File: LLVMMetadataRef,
            Line: ::std::os::raw::c_uint,
            RuntimeLang: ::std::os::raw::c_uint,
            SizeInBits: u64,
            AlignInBits: u32,
            Flags: LLVMDIFlags,
            UniqueIdentifier: *const ::std::os::raw::c_char,
            UniqueIdentifierLen: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateBitFieldMemberType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            File: LLVMMetadataRef,
            LineNumber: ::std::os::raw::c_uint,
            SizeInBits: u64,
            OffsetInBits: u64,
            StorageOffsetInBits: u64,
            Flags: LLVMDIFlags,
            Type: LLVMMetadataRef,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateClassType: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            File: LLVMMetadataRef,
            LineNumber: ::std::os::raw::c_uint,
            SizeInBits: u64,
            AlignInBits: u32,
            OffsetInBits: u64,
            Flags: LLVMDIFlags,
            DerivedFrom: LLVMMetadataRef,
            Elements: *mut LLVMMetadataRef,
            NumElements: ::std::os::raw::c_uint,
            VTableHolder: LLVMMetadataRef,
            TemplateParamsNode: LLVMMetadataRef,
            UniqueIdentifier: *const ::std::os::raw::c_char,
            UniqueIdentifierLen: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateArtificialType: Result<
        unsafe extern "C" fn(Builder: LLVMDIBuilderRef, Type: LLVMMetadataRef) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDITypeGetName: Result<
        unsafe extern "C" fn(
            DType: LLVMMetadataRef,
            Length: *mut usize,
        ) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMDITypeGetSizeInBits:
        Result<unsafe extern "C" fn(DType: LLVMMetadataRef) -> u64, ::libloading::Error>,
    pub LLVMDITypeGetOffsetInBits:
        Result<unsafe extern "C" fn(DType: LLVMMetadataRef) -> u64, ::libloading::Error>,
    pub LLVMDITypeGetAlignInBits:
        Result<unsafe extern "C" fn(DType: LLVMMetadataRef) -> u32, ::libloading::Error>,
    pub LLVMDITypeGetLine: Result<
        unsafe extern "C" fn(DType: LLVMMetadataRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMDITypeGetFlags:
        Result<unsafe extern "C" fn(DType: LLVMMetadataRef) -> LLVMDIFlags, ::libloading::Error>,
    pub LLVMDIBuilderGetOrCreateSubrange: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            LowerBound: i64,
            Count: i64,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderGetOrCreateArray: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Data: *mut LLVMMetadataRef,
            NumElements: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateExpression: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Addr: *mut u64,
            Length: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateConstantValueExpression: Result<
        unsafe extern "C" fn(Builder: LLVMDIBuilderRef, Value: u64) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateGlobalVariableExpression: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            Linkage: *const ::std::os::raw::c_char,
            LinkLen: usize,
            File: LLVMMetadataRef,
            LineNo: ::std::os::raw::c_uint,
            Ty: LLVMMetadataRef,
            LocalToUnit: LLVMBool,
            Expr: LLVMMetadataRef,
            Decl: LLVMMetadataRef,
            AlignInBits: u32,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMGetDINodeTag:
        Result<unsafe extern "C" fn(MD: LLVMMetadataRef) -> u16, ::libloading::Error>,
    pub LLVMDIGlobalVariableExpressionGetVariable:
        Result<unsafe extern "C" fn(GVE: LLVMMetadataRef) -> LLVMMetadataRef, ::libloading::Error>,
    pub LLVMDIGlobalVariableExpressionGetExpression:
        Result<unsafe extern "C" fn(GVE: LLVMMetadataRef) -> LLVMMetadataRef, ::libloading::Error>,
    pub LLVMDIVariableGetFile:
        Result<unsafe extern "C" fn(Var: LLVMMetadataRef) -> LLVMMetadataRef, ::libloading::Error>,
    pub LLVMDIVariableGetScope:
        Result<unsafe extern "C" fn(Var: LLVMMetadataRef) -> LLVMMetadataRef, ::libloading::Error>,
    pub LLVMDIVariableGetLine: Result<
        unsafe extern "C" fn(Var: LLVMMetadataRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMTemporaryMDNode: Result<
        unsafe extern "C" fn(
            Ctx: LLVMContextRef,
            Data: *mut LLVMMetadataRef,
            NumElements: usize,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDisposeTemporaryMDNode:
        Result<unsafe extern "C" fn(TempNode: LLVMMetadataRef), ::libloading::Error>,
    pub LLVMMetadataReplaceAllUsesWith: Result<
        unsafe extern "C" fn(TempTargetMetadata: LLVMMetadataRef, Replacement: LLVMMetadataRef),
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateTempGlobalVariableFwdDecl: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            Linkage: *const ::std::os::raw::c_char,
            LnkLen: usize,
            File: LLVMMetadataRef,
            LineNo: ::std::os::raw::c_uint,
            Ty: LLVMMetadataRef,
            LocalToUnit: LLVMBool,
            Decl: LLVMMetadataRef,
            AlignInBits: u32,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderInsertDeclareBefore: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Storage: LLVMValueRef,
            VarInfo: LLVMMetadataRef,
            Expr: LLVMMetadataRef,
            DebugLoc: LLVMMetadataRef,
            Instr: LLVMValueRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderInsertDeclareAtEnd: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Storage: LLVMValueRef,
            VarInfo: LLVMMetadataRef,
            Expr: LLVMMetadataRef,
            DebugLoc: LLVMMetadataRef,
            Block: LLVMBasicBlockRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderInsertDbgValueBefore: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Val: LLVMValueRef,
            VarInfo: LLVMMetadataRef,
            Expr: LLVMMetadataRef,
            DebugLoc: LLVMMetadataRef,
            Instr: LLVMValueRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderInsertDbgValueAtEnd: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Val: LLVMValueRef,
            VarInfo: LLVMMetadataRef,
            Expr: LLVMMetadataRef,
            DebugLoc: LLVMMetadataRef,
            Block: LLVMBasicBlockRef,
        ) -> LLVMValueRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateAutoVariable: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            File: LLVMMetadataRef,
            LineNo: ::std::os::raw::c_uint,
            Ty: LLVMMetadataRef,
            AlwaysPreserve: LLVMBool,
            Flags: LLVMDIFlags,
            AlignInBits: u32,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMDIBuilderCreateParameterVariable: Result<
        unsafe extern "C" fn(
            Builder: LLVMDIBuilderRef,
            Scope: LLVMMetadataRef,
            Name: *const ::std::os::raw::c_char,
            NameLen: usize,
            ArgNo: ::std::os::raw::c_uint,
            File: LLVMMetadataRef,
            LineNo: ::std::os::raw::c_uint,
            Ty: LLVMMetadataRef,
            AlwaysPreserve: LLVMBool,
            Flags: LLVMDIFlags,
        ) -> LLVMMetadataRef,
        ::libloading::Error,
    >,
    pub LLVMGetSubprogram:
        Result<unsafe extern "C" fn(Func: LLVMValueRef) -> LLVMMetadataRef, ::libloading::Error>,
    pub LLVMSetSubprogram:
        Result<unsafe extern "C" fn(Func: LLVMValueRef, SP: LLVMMetadataRef), ::libloading::Error>,
    pub LLVMDISubprogramGetLine: Result<
        unsafe extern "C" fn(Subprogram: LLVMMetadataRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMInstructionGetDebugLoc:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef) -> LLVMMetadataRef, ::libloading::Error>,
    pub LLVMInstructionSetDebugLoc:
        Result<unsafe extern "C" fn(Inst: LLVMValueRef, Loc: LLVMMetadataRef), ::libloading::Error>,
    pub LLVMGetMetadataKind: Result<
        unsafe extern "C" fn(Metadata: LLVMMetadataRef) -> LLVMMetadataKind,
        ::libloading::Error,
    >,
    pub LLVMCreateDisasm: Result<
        unsafe extern "C" fn(
            TripleName: *const ::std::os::raw::c_char,
            DisInfo: *mut ::std::os::raw::c_void,
            TagType: ::std::os::raw::c_int,
            GetOpInfo: LLVMOpInfoCallback,
            SymbolLookUp: LLVMSymbolLookupCallback,
        ) -> LLVMDisasmContextRef,
        ::libloading::Error,
    >,
    pub LLVMCreateDisasmCPU: Result<
        unsafe extern "C" fn(
            Triple: *const ::std::os::raw::c_char,
            CPU: *const ::std::os::raw::c_char,
            DisInfo: *mut ::std::os::raw::c_void,
            TagType: ::std::os::raw::c_int,
            GetOpInfo: LLVMOpInfoCallback,
            SymbolLookUp: LLVMSymbolLookupCallback,
        ) -> LLVMDisasmContextRef,
        ::libloading::Error,
    >,
    pub LLVMCreateDisasmCPUFeatures: Result<
        unsafe extern "C" fn(
            Triple: *const ::std::os::raw::c_char,
            CPU: *const ::std::os::raw::c_char,
            Features: *const ::std::os::raw::c_char,
            DisInfo: *mut ::std::os::raw::c_void,
            TagType: ::std::os::raw::c_int,
            GetOpInfo: LLVMOpInfoCallback,
            SymbolLookUp: LLVMSymbolLookupCallback,
        ) -> LLVMDisasmContextRef,
        ::libloading::Error,
    >,
    pub LLVMSetDisasmOptions: Result<
        unsafe extern "C" fn(DC: LLVMDisasmContextRef, Options: u64) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub LLVMDisasmDispose:
        Result<unsafe extern "C" fn(DC: LLVMDisasmContextRef), ::libloading::Error>,
    pub LLVMDisasmInstruction: Result<
        unsafe extern "C" fn(
            DC: LLVMDisasmContextRef,
            Bytes: *mut u8,
            BytesSize: u64,
            PC: u64,
            OutString: *mut ::std::os::raw::c_char,
            OutStringSize: usize,
        ) -> usize,
        ::libloading::Error,
    >,
    pub LLVMGetErrorTypeId:
        Result<unsafe extern "C" fn(err: LLVMErrorRef) -> LLVMErrorTypeId, ::libloading::Error>,
    pub LLVMConsumeError: Result<unsafe extern "C" fn(err: LLVMErrorRef), ::libloading::Error>,
    pub LLVMGetErrorMessage: Result<
        unsafe extern "C" fn(err: LLVMErrorRef) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMDisposeErrorMessage:
        Result<unsafe extern "C" fn(ErrMsg: *mut ::std::os::raw::c_char), ::libloading::Error>,
    pub LLVMGetStringErrorTypeId:
        Result<unsafe extern "C" fn() -> LLVMErrorTypeId, ::libloading::Error>,
    pub LLVMCreateStringError: Result<
        unsafe extern "C" fn(ErrMsg: *const ::std::os::raw::c_char) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMInitializeAArch64TargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAMDGPUTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeARMTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAVRTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeBPFTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeHexagonTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeLanaiTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeLoongArchTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeMipsTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeMSP430TargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeNVPTXTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializePowerPCTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeRISCVTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeSparcTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeSystemZTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeVETargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeWebAssemblyTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeX86TargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeXCoreTargetInfo: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAArch64Target: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAMDGPUTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeARMTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAVRTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeBPFTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeHexagonTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeLanaiTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeLoongArchTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeMipsTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeMSP430Target: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeNVPTXTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializePowerPCTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeRISCVTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeSparcTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeSystemZTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeVETarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeWebAssemblyTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeX86Target: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeXCoreTarget: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAArch64TargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAMDGPUTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeARMTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAVRTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeBPFTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeHexagonTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeLanaiTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeLoongArchTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeMipsTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeMSP430TargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeNVPTXTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializePowerPCTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeRISCVTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeSparcTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeSystemZTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeVETargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeWebAssemblyTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeX86TargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeXCoreTargetMC: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAArch64AsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAMDGPUAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeARMAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAVRAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeBPFAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeHexagonAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeLanaiAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeLoongArchAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeMipsAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeMSP430AsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeNVPTXAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializePowerPCAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeRISCVAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeSparcAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeSystemZAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeVEAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeWebAssemblyAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeX86AsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeXCoreAsmPrinter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAArch64AsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAMDGPUAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeARMAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAVRAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeBPFAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeHexagonAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeLanaiAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeLoongArchAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeMipsAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeMSP430AsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializePowerPCAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeRISCVAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeSparcAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeSystemZAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeVEAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeWebAssemblyAsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeX86AsmParser: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAArch64Disassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAMDGPUDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeARMDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeAVRDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeBPFDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeHexagonDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeLanaiDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeLoongArchDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeMipsDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeMSP430Disassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializePowerPCDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeRISCVDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeSparcDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeSystemZDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeVEDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeWebAssemblyDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeX86Disassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMInitializeXCoreDisassembler: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMGetModuleDataLayout:
        Result<unsafe extern "C" fn(M: LLVMModuleRef) -> LLVMTargetDataRef, ::libloading::Error>,
    pub LLVMSetModuleDataLayout:
        Result<unsafe extern "C" fn(M: LLVMModuleRef, DL: LLVMTargetDataRef), ::libloading::Error>,
    pub LLVMCreateTargetData: Result<
        unsafe extern "C" fn(StringRep: *const ::std::os::raw::c_char) -> LLVMTargetDataRef,
        ::libloading::Error,
    >,
    pub LLVMDisposeTargetData:
        Result<unsafe extern "C" fn(TD: LLVMTargetDataRef), ::libloading::Error>,
    pub LLVMAddTargetLibraryInfo: Result<
        unsafe extern "C" fn(TLI: LLVMTargetLibraryInfoRef, PM: LLVMPassManagerRef),
        ::libloading::Error,
    >,
    pub LLVMCopyStringRepOfTargetData: Result<
        unsafe extern "C" fn(TD: LLVMTargetDataRef) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMByteOrder: Result<
        unsafe extern "C" fn(TD: LLVMTargetDataRef) -> LLVMByteOrdering,
        ::libloading::Error,
    >,
    pub LLVMPointerSize: Result<
        unsafe extern "C" fn(TD: LLVMTargetDataRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMPointerSizeForAS: Result<
        unsafe extern "C" fn(
            TD: LLVMTargetDataRef,
            AS: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMIntPtrType:
        Result<unsafe extern "C" fn(TD: LLVMTargetDataRef) -> LLVMTypeRef, ::libloading::Error>,
    pub LLVMIntPtrTypeForAS: Result<
        unsafe extern "C" fn(TD: LLVMTargetDataRef, AS: ::std::os::raw::c_uint) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMIntPtrTypeInContext: Result<
        unsafe extern "C" fn(C: LLVMContextRef, TD: LLVMTargetDataRef) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMIntPtrTypeForASInContext: Result<
        unsafe extern "C" fn(
            C: LLVMContextRef,
            TD: LLVMTargetDataRef,
            AS: ::std::os::raw::c_uint,
        ) -> LLVMTypeRef,
        ::libloading::Error,
    >,
    pub LLVMSizeOfTypeInBits: Result<
        unsafe extern "C" fn(TD: LLVMTargetDataRef, Ty: LLVMTypeRef) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub LLVMStoreSizeOfType: Result<
        unsafe extern "C" fn(TD: LLVMTargetDataRef, Ty: LLVMTypeRef) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub LLVMABISizeOfType: Result<
        unsafe extern "C" fn(TD: LLVMTargetDataRef, Ty: LLVMTypeRef) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub LLVMABIAlignmentOfType: Result<
        unsafe extern "C" fn(TD: LLVMTargetDataRef, Ty: LLVMTypeRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMCallFrameAlignmentOfType: Result<
        unsafe extern "C" fn(TD: LLVMTargetDataRef, Ty: LLVMTypeRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMPreferredAlignmentOfType: Result<
        unsafe extern "C" fn(TD: LLVMTargetDataRef, Ty: LLVMTypeRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMPreferredAlignmentOfGlobal: Result<
        unsafe extern "C" fn(
            TD: LLVMTargetDataRef,
            GlobalVar: LLVMValueRef,
        ) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMElementAtOffset: Result<
        unsafe extern "C" fn(
            TD: LLVMTargetDataRef,
            StructTy: LLVMTypeRef,
            Offset: ::std::os::raw::c_ulonglong,
        ) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMOffsetOfElement: Result<
        unsafe extern "C" fn(
            TD: LLVMTargetDataRef,
            StructTy: LLVMTypeRef,
            Element: ::std::os::raw::c_uint,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub LLVMGetFirstTarget: Result<unsafe extern "C" fn() -> LLVMTargetRef, ::libloading::Error>,
    pub LLVMGetNextTarget:
        Result<unsafe extern "C" fn(T: LLVMTargetRef) -> LLVMTargetRef, ::libloading::Error>,
    pub LLVMGetTargetFromName: Result<
        unsafe extern "C" fn(Name: *const ::std::os::raw::c_char) -> LLVMTargetRef,
        ::libloading::Error,
    >,
    pub LLVMGetTargetFromTriple: Result<
        unsafe extern "C" fn(
            Triple: *const ::std::os::raw::c_char,
            T: *mut LLVMTargetRef,
            ErrorMessage: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMGetTargetName: Result<
        unsafe extern "C" fn(T: LLVMTargetRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetTargetDescription: Result<
        unsafe extern "C" fn(T: LLVMTargetRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMTargetHasJIT:
        Result<unsafe extern "C" fn(T: LLVMTargetRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMTargetHasTargetMachine:
        Result<unsafe extern "C" fn(T: LLVMTargetRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMTargetHasAsmBackend:
        Result<unsafe extern "C" fn(T: LLVMTargetRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMCreateTargetMachine: Result<
        unsafe extern "C" fn(
            T: LLVMTargetRef,
            Triple: *const ::std::os::raw::c_char,
            CPU: *const ::std::os::raw::c_char,
            Features: *const ::std::os::raw::c_char,
            Level: LLVMCodeGenOptLevel,
            Reloc: LLVMRelocMode,
            CodeModel: LLVMCodeModel,
        ) -> LLVMTargetMachineRef,
        ::libloading::Error,
    >,
    pub LLVMDisposeTargetMachine:
        Result<unsafe extern "C" fn(T: LLVMTargetMachineRef), ::libloading::Error>,
    pub LLVMGetTargetMachineTarget:
        Result<unsafe extern "C" fn(T: LLVMTargetMachineRef) -> LLVMTargetRef, ::libloading::Error>,
    pub LLVMGetTargetMachineTriple: Result<
        unsafe extern "C" fn(T: LLVMTargetMachineRef) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetTargetMachineCPU: Result<
        unsafe extern "C" fn(T: LLVMTargetMachineRef) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetTargetMachineFeatureString: Result<
        unsafe extern "C" fn(T: LLVMTargetMachineRef) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMCreateTargetDataLayout: Result<
        unsafe extern "C" fn(T: LLVMTargetMachineRef) -> LLVMTargetDataRef,
        ::libloading::Error,
    >,
    pub LLVMSetTargetMachineAsmVerbosity: Result<
        unsafe extern "C" fn(T: LLVMTargetMachineRef, VerboseAsm: LLVMBool),
        ::libloading::Error,
    >,
    pub LLVMTargetMachineEmitToFile: Result<
        unsafe extern "C" fn(
            T: LLVMTargetMachineRef,
            M: LLVMModuleRef,
            Filename: *const ::std::os::raw::c_char,
            codegen: LLVMCodeGenFileType,
            ErrorMessage: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMTargetMachineEmitToMemoryBuffer: Result<
        unsafe extern "C" fn(
            T: LLVMTargetMachineRef,
            M: LLVMModuleRef,
            codegen: LLVMCodeGenFileType,
            ErrorMessage: *mut *mut ::std::os::raw::c_char,
            OutMemBuf: *mut LLVMMemoryBufferRef,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMGetDefaultTargetTriple:
        Result<unsafe extern "C" fn() -> *mut ::std::os::raw::c_char, ::libloading::Error>,
    pub LLVMNormalizeTargetTriple: Result<
        unsafe extern "C" fn(triple: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetHostCPUName:
        Result<unsafe extern "C" fn() -> *mut ::std::os::raw::c_char, ::libloading::Error>,
    pub LLVMGetHostCPUFeatures:
        Result<unsafe extern "C" fn() -> *mut ::std::os::raw::c_char, ::libloading::Error>,
    pub LLVMAddAnalysisPasses: Result<
        unsafe extern "C" fn(T: LLVMTargetMachineRef, PM: LLVMPassManagerRef),
        ::libloading::Error,
    >,
    pub LLVMLinkInMCJIT: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMLinkInInterpreter: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub LLVMCreateGenericValueOfInt: Result<
        unsafe extern "C" fn(
            Ty: LLVMTypeRef,
            N: ::std::os::raw::c_ulonglong,
            IsSigned: LLVMBool,
        ) -> LLVMGenericValueRef,
        ::libloading::Error,
    >,
    pub LLVMCreateGenericValueOfPointer: Result<
        unsafe extern "C" fn(P: *mut ::std::os::raw::c_void) -> LLVMGenericValueRef,
        ::libloading::Error,
    >,
    pub LLVMCreateGenericValueOfFloat: Result<
        unsafe extern "C" fn(Ty: LLVMTypeRef, N: f64) -> LLVMGenericValueRef,
        ::libloading::Error,
    >,
    pub LLVMGenericValueIntWidth: Result<
        unsafe extern "C" fn(GenValRef: LLVMGenericValueRef) -> ::std::os::raw::c_uint,
        ::libloading::Error,
    >,
    pub LLVMGenericValueToInt: Result<
        unsafe extern "C" fn(
            GenVal: LLVMGenericValueRef,
            IsSigned: LLVMBool,
        ) -> ::std::os::raw::c_ulonglong,
        ::libloading::Error,
    >,
    pub LLVMGenericValueToPointer: Result<
        unsafe extern "C" fn(GenVal: LLVMGenericValueRef) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub LLVMGenericValueToFloat: Result<
        unsafe extern "C" fn(TyRef: LLVMTypeRef, GenVal: LLVMGenericValueRef) -> f64,
        ::libloading::Error,
    >,
    pub LLVMDisposeGenericValue:
        Result<unsafe extern "C" fn(GenVal: LLVMGenericValueRef), ::libloading::Error>,
    pub LLVMCreateExecutionEngineForModule: Result<
        unsafe extern "C" fn(
            OutEE: *mut LLVMExecutionEngineRef,
            M: LLVMModuleRef,
            OutError: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMCreateInterpreterForModule: Result<
        unsafe extern "C" fn(
            OutInterp: *mut LLVMExecutionEngineRef,
            M: LLVMModuleRef,
            OutError: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMCreateJITCompilerForModule: Result<
        unsafe extern "C" fn(
            OutJIT: *mut LLVMExecutionEngineRef,
            M: LLVMModuleRef,
            OptLevel: ::std::os::raw::c_uint,
            OutError: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMInitializeMCJITCompilerOptions: Result<
        unsafe extern "C" fn(Options: *mut LLVMMCJITCompilerOptions, SizeOfOptions: usize),
        ::libloading::Error,
    >,
    pub LLVMCreateMCJITCompilerForModule: Result<
        unsafe extern "C" fn(
            OutJIT: *mut LLVMExecutionEngineRef,
            M: LLVMModuleRef,
            Options: *mut LLVMMCJITCompilerOptions,
            SizeOfOptions: usize,
            OutError: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMDisposeExecutionEngine:
        Result<unsafe extern "C" fn(EE: LLVMExecutionEngineRef), ::libloading::Error>,
    pub LLVMRunStaticConstructors:
        Result<unsafe extern "C" fn(EE: LLVMExecutionEngineRef), ::libloading::Error>,
    pub LLVMRunStaticDestructors:
        Result<unsafe extern "C" fn(EE: LLVMExecutionEngineRef), ::libloading::Error>,
    pub LLVMRunFunctionAsMain: Result<
        unsafe extern "C" fn(
            EE: LLVMExecutionEngineRef,
            F: LLVMValueRef,
            ArgC: ::std::os::raw::c_uint,
            ArgV: *const *const ::std::os::raw::c_char,
            EnvP: *const *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
        ::libloading::Error,
    >,
    pub LLVMRunFunction: Result<
        unsafe extern "C" fn(
            EE: LLVMExecutionEngineRef,
            F: LLVMValueRef,
            NumArgs: ::std::os::raw::c_uint,
            Args: *mut LLVMGenericValueRef,
        ) -> LLVMGenericValueRef,
        ::libloading::Error,
    >,
    pub LLVMFreeMachineCodeForFunction: Result<
        unsafe extern "C" fn(EE: LLVMExecutionEngineRef, F: LLVMValueRef),
        ::libloading::Error,
    >,
    pub LLVMAddModule: Result<
        unsafe extern "C" fn(EE: LLVMExecutionEngineRef, M: LLVMModuleRef),
        ::libloading::Error,
    >,
    pub LLVMRemoveModule: Result<
        unsafe extern "C" fn(
            EE: LLVMExecutionEngineRef,
            M: LLVMModuleRef,
            OutMod: *mut LLVMModuleRef,
            OutError: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMFindFunction: Result<
        unsafe extern "C" fn(
            EE: LLVMExecutionEngineRef,
            Name: *const ::std::os::raw::c_char,
            OutFn: *mut LLVMValueRef,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMRecompileAndRelinkFunction: Result<
        unsafe extern "C" fn(
            EE: LLVMExecutionEngineRef,
            Fn: LLVMValueRef,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub LLVMGetExecutionEngineTargetData: Result<
        unsafe extern "C" fn(EE: LLVMExecutionEngineRef) -> LLVMTargetDataRef,
        ::libloading::Error,
    >,
    pub LLVMGetExecutionEngineTargetMachine: Result<
        unsafe extern "C" fn(EE: LLVMExecutionEngineRef) -> LLVMTargetMachineRef,
        ::libloading::Error,
    >,
    pub LLVMAddGlobalMapping: Result<
        unsafe extern "C" fn(
            EE: LLVMExecutionEngineRef,
            Global: LLVMValueRef,
            Addr: *mut ::std::os::raw::c_void,
        ),
        ::libloading::Error,
    >,
    pub LLVMGetPointerToGlobal: Result<
        unsafe extern "C" fn(
            EE: LLVMExecutionEngineRef,
            Global: LLVMValueRef,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub LLVMGetGlobalValueAddress: Result<
        unsafe extern "C" fn(
            EE: LLVMExecutionEngineRef,
            Name: *const ::std::os::raw::c_char,
        ) -> u64,
        ::libloading::Error,
    >,
    pub LLVMGetFunctionAddress: Result<
        unsafe extern "C" fn(
            EE: LLVMExecutionEngineRef,
            Name: *const ::std::os::raw::c_char,
        ) -> u64,
        ::libloading::Error,
    >,
    pub LLVMExecutionEngineGetErrMsg: Result<
        unsafe extern "C" fn(
            EE: LLVMExecutionEngineRef,
            OutError: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMCreateSimpleMCJITMemoryManager: Result<
        unsafe extern "C" fn(
            Opaque: *mut ::std::os::raw::c_void,
            AllocateCodeSection: LLVMMemoryManagerAllocateCodeSectionCallback,
            AllocateDataSection: LLVMMemoryManagerAllocateDataSectionCallback,
            FinalizeMemory: LLVMMemoryManagerFinalizeMemoryCallback,
            Destroy: LLVMMemoryManagerDestroyCallback,
        ) -> LLVMMCJITMemoryManagerRef,
        ::libloading::Error,
    >,
    pub LLVMDisposeMCJITMemoryManager:
        Result<unsafe extern "C" fn(MM: LLVMMCJITMemoryManagerRef), ::libloading::Error>,
    pub LLVMCreateGDBRegistrationListener:
        Result<unsafe extern "C" fn() -> LLVMJITEventListenerRef, ::libloading::Error>,
    pub LLVMCreateIntelJITEventListener:
        Result<unsafe extern "C" fn() -> LLVMJITEventListenerRef, ::libloading::Error>,
    pub LLVMCreateOProfileJITEventListener:
        Result<unsafe extern "C" fn() -> LLVMJITEventListenerRef, ::libloading::Error>,
    pub LLVMCreatePerfJITEventListener:
        Result<unsafe extern "C" fn() -> LLVMJITEventListenerRef, ::libloading::Error>,
    pub LLVMParseIRInContext: Result<
        unsafe extern "C" fn(
            ContextRef: LLVMContextRef,
            MemBuf: LLVMMemoryBufferRef,
            OutM: *mut LLVMModuleRef,
            OutMessage: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMLinkModules2: Result<
        unsafe extern "C" fn(Dest: LLVMModuleRef, Src: LLVMModuleRef) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMOrcExecutionSessionSetErrorReporter: Result<
        unsafe extern "C" fn(
            ES: LLVMOrcExecutionSessionRef,
            ReportError: LLVMOrcErrorReporterFunction,
            Ctx: *mut ::std::os::raw::c_void,
        ),
        ::libloading::Error,
    >,
    pub LLVMOrcExecutionSessionGetSymbolStringPool: Result<
        unsafe extern "C" fn(ES: LLVMOrcExecutionSessionRef) -> LLVMOrcSymbolStringPoolRef,
        ::libloading::Error,
    >,
    pub LLVMOrcSymbolStringPoolClearDeadEntries:
        Result<unsafe extern "C" fn(SSP: LLVMOrcSymbolStringPoolRef), ::libloading::Error>,
    pub LLVMOrcExecutionSessionIntern: Result<
        unsafe extern "C" fn(
            ES: LLVMOrcExecutionSessionRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMOrcSymbolStringPoolEntryRef,
        ::libloading::Error,
    >,
    pub LLVMOrcExecutionSessionLookup: Result<
        unsafe extern "C" fn(
            ES: LLVMOrcExecutionSessionRef,
            K: LLVMOrcLookupKind,
            SearchOrder: LLVMOrcCJITDylibSearchOrder,
            SearchOrderSize: usize,
            Symbols: LLVMOrcCLookupSet,
            SymbolsSize: usize,
            HandleResult: LLVMOrcExecutionSessionLookupHandleResultFunction,
            Ctx: *mut ::std::os::raw::c_void,
        ),
        ::libloading::Error,
    >,
    pub LLVMOrcRetainSymbolStringPoolEntry:
        Result<unsafe extern "C" fn(S: LLVMOrcSymbolStringPoolEntryRef), ::libloading::Error>,
    pub LLVMOrcReleaseSymbolStringPoolEntry:
        Result<unsafe extern "C" fn(S: LLVMOrcSymbolStringPoolEntryRef), ::libloading::Error>,
    pub LLVMOrcSymbolStringPoolEntryStr: Result<
        unsafe extern "C" fn(S: LLVMOrcSymbolStringPoolEntryRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMOrcReleaseResourceTracker:
        Result<unsafe extern "C" fn(RT: LLVMOrcResourceTrackerRef), ::libloading::Error>,
    pub LLVMOrcResourceTrackerTransferTo: Result<
        unsafe extern "C" fn(SrcRT: LLVMOrcResourceTrackerRef, DstRT: LLVMOrcResourceTrackerRef),
        ::libloading::Error,
    >,
    pub LLVMOrcResourceTrackerRemove: Result<
        unsafe extern "C" fn(RT: LLVMOrcResourceTrackerRef) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcDisposeDefinitionGenerator:
        Result<unsafe extern "C" fn(DG: LLVMOrcDefinitionGeneratorRef), ::libloading::Error>,
    pub LLVMOrcDisposeMaterializationUnit:
        Result<unsafe extern "C" fn(MU: LLVMOrcMaterializationUnitRef), ::libloading::Error>,
    pub LLVMOrcCreateCustomMaterializationUnit: Result<
        unsafe extern "C" fn(
            Name: *const ::std::os::raw::c_char,
            Ctx: *mut ::std::os::raw::c_void,
            Syms: LLVMOrcCSymbolFlagsMapPairs,
            NumSyms: usize,
            InitSym: LLVMOrcSymbolStringPoolEntryRef,
            Materialize: LLVMOrcMaterializationUnitMaterializeFunction,
            Discard: LLVMOrcMaterializationUnitDiscardFunction,
            Destroy: LLVMOrcMaterializationUnitDestroyFunction,
        ) -> LLVMOrcMaterializationUnitRef,
        ::libloading::Error,
    >,
    pub LLVMOrcAbsoluteSymbols: Result<
        unsafe extern "C" fn(
            Syms: LLVMOrcCSymbolMapPairs,
            NumPairs: usize,
        ) -> LLVMOrcMaterializationUnitRef,
        ::libloading::Error,
    >,
    pub LLVMOrcLazyReexports: Result<
        unsafe extern "C" fn(
            LCTM: LLVMOrcLazyCallThroughManagerRef,
            ISM: LLVMOrcIndirectStubsManagerRef,
            SourceRef: LLVMOrcJITDylibRef,
            CallableAliases: LLVMOrcCSymbolAliasMapPairs,
            NumPairs: usize,
        ) -> LLVMOrcMaterializationUnitRef,
        ::libloading::Error,
    >,
    pub LLVMOrcDisposeMaterializationResponsibility: Result<
        unsafe extern "C" fn(MR: LLVMOrcMaterializationResponsibilityRef),
        ::libloading::Error,
    >,
    pub LLVMOrcMaterializationResponsibilityGetTargetDylib: Result<
        unsafe extern "C" fn(MR: LLVMOrcMaterializationResponsibilityRef) -> LLVMOrcJITDylibRef,
        ::libloading::Error,
    >,
    pub LLVMOrcMaterializationResponsibilityGetExecutionSession: Result<
        unsafe extern "C" fn(
            MR: LLVMOrcMaterializationResponsibilityRef,
        ) -> LLVMOrcExecutionSessionRef,
        ::libloading::Error,
    >,
    pub LLVMOrcMaterializationResponsibilityGetSymbols: Result<
        unsafe extern "C" fn(
            MR: LLVMOrcMaterializationResponsibilityRef,
            NumPairs: *mut usize,
        ) -> LLVMOrcCSymbolFlagsMapPairs,
        ::libloading::Error,
    >,
    pub LLVMOrcDisposeCSymbolFlagsMap:
        Result<unsafe extern "C" fn(Pairs: LLVMOrcCSymbolFlagsMapPairs), ::libloading::Error>,
    pub LLVMOrcMaterializationResponsibilityGetInitializerSymbol: Result<
        unsafe extern "C" fn(
            MR: LLVMOrcMaterializationResponsibilityRef,
        ) -> LLVMOrcSymbolStringPoolEntryRef,
        ::libloading::Error,
    >,
    pub LLVMOrcMaterializationResponsibilityGetRequestedSymbols: Result<
        unsafe extern "C" fn(
            MR: LLVMOrcMaterializationResponsibilityRef,
            NumSymbols: *mut usize,
        ) -> *mut LLVMOrcSymbolStringPoolEntryRef,
        ::libloading::Error,
    >,
    pub LLVMOrcDisposeSymbols: Result<
        unsafe extern "C" fn(Symbols: *mut LLVMOrcSymbolStringPoolEntryRef),
        ::libloading::Error,
    >,
    pub LLVMOrcMaterializationResponsibilityNotifyResolved: Result<
        unsafe extern "C" fn(
            MR: LLVMOrcMaterializationResponsibilityRef,
            Symbols: LLVMOrcCSymbolMapPairs,
            NumPairs: usize,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcMaterializationResponsibilityNotifyEmitted: Result<
        unsafe extern "C" fn(MR: LLVMOrcMaterializationResponsibilityRef) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcMaterializationResponsibilityDefineMaterializing: Result<
        unsafe extern "C" fn(
            MR: LLVMOrcMaterializationResponsibilityRef,
            Pairs: LLVMOrcCSymbolFlagsMapPairs,
            NumPairs: usize,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcMaterializationResponsibilityFailMaterialization: Result<
        unsafe extern "C" fn(MR: LLVMOrcMaterializationResponsibilityRef),
        ::libloading::Error,
    >,
    pub LLVMOrcMaterializationResponsibilityReplace: Result<
        unsafe extern "C" fn(
            MR: LLVMOrcMaterializationResponsibilityRef,
            MU: LLVMOrcMaterializationUnitRef,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcMaterializationResponsibilityDelegate: Result<
        unsafe extern "C" fn(
            MR: LLVMOrcMaterializationResponsibilityRef,
            Symbols: *mut LLVMOrcSymbolStringPoolEntryRef,
            NumSymbols: usize,
            Result: *mut LLVMOrcMaterializationResponsibilityRef,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcMaterializationResponsibilityAddDependencies: Result<
        unsafe extern "C" fn(
            MR: LLVMOrcMaterializationResponsibilityRef,
            Name: LLVMOrcSymbolStringPoolEntryRef,
            Dependencies: LLVMOrcCDependenceMapPairs,
            NumPairs: usize,
        ),
        ::libloading::Error,
    >,
    pub LLVMOrcMaterializationResponsibilityAddDependenciesForAll: Result<
        unsafe extern "C" fn(
            MR: LLVMOrcMaterializationResponsibilityRef,
            Dependencies: LLVMOrcCDependenceMapPairs,
            NumPairs: usize,
        ),
        ::libloading::Error,
    >,
    pub LLVMOrcExecutionSessionCreateBareJITDylib: Result<
        unsafe extern "C" fn(
            ES: LLVMOrcExecutionSessionRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMOrcJITDylibRef,
        ::libloading::Error,
    >,
    pub LLVMOrcExecutionSessionCreateJITDylib: Result<
        unsafe extern "C" fn(
            ES: LLVMOrcExecutionSessionRef,
            Result: *mut LLVMOrcJITDylibRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcExecutionSessionGetJITDylibByName: Result<
        unsafe extern "C" fn(
            ES: LLVMOrcExecutionSessionRef,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMOrcJITDylibRef,
        ::libloading::Error,
    >,
    pub LLVMOrcJITDylibCreateResourceTracker: Result<
        unsafe extern "C" fn(JD: LLVMOrcJITDylibRef) -> LLVMOrcResourceTrackerRef,
        ::libloading::Error,
    >,
    pub LLVMOrcJITDylibGetDefaultResourceTracker: Result<
        unsafe extern "C" fn(JD: LLVMOrcJITDylibRef) -> LLVMOrcResourceTrackerRef,
        ::libloading::Error,
    >,
    pub LLVMOrcJITDylibDefine: Result<
        unsafe extern "C" fn(
            JD: LLVMOrcJITDylibRef,
            MU: LLVMOrcMaterializationUnitRef,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcJITDylibClear:
        Result<unsafe extern "C" fn(JD: LLVMOrcJITDylibRef) -> LLVMErrorRef, ::libloading::Error>,
    pub LLVMOrcJITDylibAddGenerator: Result<
        unsafe extern "C" fn(JD: LLVMOrcJITDylibRef, DG: LLVMOrcDefinitionGeneratorRef),
        ::libloading::Error,
    >,
    pub LLVMOrcCreateCustomCAPIDefinitionGenerator: Result<
        unsafe extern "C" fn(
            F: LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction,
            Ctx: *mut ::std::os::raw::c_void,
            Dispose: LLVMOrcDisposeCAPIDefinitionGeneratorFunction,
        ) -> LLVMOrcDefinitionGeneratorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcLookupStateContinueLookup: Result<
        unsafe extern "C" fn(S: LLVMOrcLookupStateRef, err: LLVMErrorRef),
        ::libloading::Error,
    >,
    pub LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess: Result<
        unsafe extern "C" fn(
            Result: *mut LLVMOrcDefinitionGeneratorRef,
            GlobalPrefx: ::std::os::raw::c_char,
            Filter: LLVMOrcSymbolPredicate,
            FilterCtx: *mut ::std::os::raw::c_void,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcCreateDynamicLibrarySearchGeneratorForPath: Result<
        unsafe extern "C" fn(
            Result: *mut LLVMOrcDefinitionGeneratorRef,
            FileName: *const ::std::os::raw::c_char,
            GlobalPrefix: ::std::os::raw::c_char,
            Filter: LLVMOrcSymbolPredicate,
            FilterCtx: *mut ::std::os::raw::c_void,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcCreateStaticLibrarySearchGeneratorForPath: Result<
        unsafe extern "C" fn(
            Result: *mut LLVMOrcDefinitionGeneratorRef,
            ObjLayer: LLVMOrcObjectLayerRef,
            FileName: *const ::std::os::raw::c_char,
            TargetTriple: *const ::std::os::raw::c_char,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcCreateNewThreadSafeContext:
        Result<unsafe extern "C" fn() -> LLVMOrcThreadSafeContextRef, ::libloading::Error>,
    pub LLVMOrcThreadSafeContextGetContext: Result<
        unsafe extern "C" fn(TSCtx: LLVMOrcThreadSafeContextRef) -> LLVMContextRef,
        ::libloading::Error,
    >,
    pub LLVMOrcDisposeThreadSafeContext:
        Result<unsafe extern "C" fn(TSCtx: LLVMOrcThreadSafeContextRef), ::libloading::Error>,
    pub LLVMOrcCreateNewThreadSafeModule: Result<
        unsafe extern "C" fn(
            M: LLVMModuleRef,
            TSCtx: LLVMOrcThreadSafeContextRef,
        ) -> LLVMOrcThreadSafeModuleRef,
        ::libloading::Error,
    >,
    pub LLVMOrcDisposeThreadSafeModule:
        Result<unsafe extern "C" fn(TSM: LLVMOrcThreadSafeModuleRef), ::libloading::Error>,
    pub LLVMOrcThreadSafeModuleWithModuleDo: Result<
        unsafe extern "C" fn(
            TSM: LLVMOrcThreadSafeModuleRef,
            F: LLVMOrcGenericIRModuleOperationFunction,
            Ctx: *mut ::std::os::raw::c_void,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcJITTargetMachineBuilderDetectHost: Result<
        unsafe extern "C" fn(Result: *mut LLVMOrcJITTargetMachineBuilderRef) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine: Result<
        unsafe extern "C" fn(TM: LLVMTargetMachineRef) -> LLVMOrcJITTargetMachineBuilderRef,
        ::libloading::Error,
    >,
    pub LLVMOrcDisposeJITTargetMachineBuilder:
        Result<unsafe extern "C" fn(JTMB: LLVMOrcJITTargetMachineBuilderRef), ::libloading::Error>,
    pub LLVMOrcJITTargetMachineBuilderGetTargetTriple: Result<
        unsafe extern "C" fn(
            JTMB: LLVMOrcJITTargetMachineBuilderRef,
        ) -> *mut ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMOrcJITTargetMachineBuilderSetTargetTriple: Result<
        unsafe extern "C" fn(
            JTMB: LLVMOrcJITTargetMachineBuilderRef,
            TargetTriple: *const ::std::os::raw::c_char,
        ),
        ::libloading::Error,
    >,
    pub LLVMOrcObjectLayerAddObjectFile: Result<
        unsafe extern "C" fn(
            ObjLayer: LLVMOrcObjectLayerRef,
            JD: LLVMOrcJITDylibRef,
            ObjBuffer: LLVMMemoryBufferRef,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcObjectLayerAddObjectFileWithRT: Result<
        unsafe extern "C" fn(
            ObjLayer: LLVMOrcObjectLayerRef,
            RT: LLVMOrcResourceTrackerRef,
            ObjBuffer: LLVMMemoryBufferRef,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcObjectLayerEmit: Result<
        unsafe extern "C" fn(
            ObjLayer: LLVMOrcObjectLayerRef,
            R: LLVMOrcMaterializationResponsibilityRef,
            ObjBuffer: LLVMMemoryBufferRef,
        ),
        ::libloading::Error,
    >,
    pub LLVMOrcDisposeObjectLayer:
        Result<unsafe extern "C" fn(ObjLayer: LLVMOrcObjectLayerRef), ::libloading::Error>,
    pub LLVMOrcIRTransformLayerEmit: Result<
        unsafe extern "C" fn(
            IRTransformLayer: LLVMOrcIRTransformLayerRef,
            MR: LLVMOrcMaterializationResponsibilityRef,
            TSM: LLVMOrcThreadSafeModuleRef,
        ),
        ::libloading::Error,
    >,
    pub LLVMOrcIRTransformLayerSetTransform: Result<
        unsafe extern "C" fn(
            IRTransformLayer: LLVMOrcIRTransformLayerRef,
            TransformFunction: LLVMOrcIRTransformLayerTransformFunction,
            Ctx: *mut ::std::os::raw::c_void,
        ),
        ::libloading::Error,
    >,
    pub LLVMOrcObjectTransformLayerSetTransform: Result<
        unsafe extern "C" fn(
            ObjTransformLayer: LLVMOrcObjectTransformLayerRef,
            TransformFunction: LLVMOrcObjectTransformLayerTransformFunction,
            Ctx: *mut ::std::os::raw::c_void,
        ),
        ::libloading::Error,
    >,
    pub LLVMOrcCreateLocalIndirectStubsManager: Result<
        unsafe extern "C" fn(
            TargetTriple: *const ::std::os::raw::c_char,
        ) -> LLVMOrcIndirectStubsManagerRef,
        ::libloading::Error,
    >,
    pub LLVMOrcDisposeIndirectStubsManager:
        Result<unsafe extern "C" fn(ISM: LLVMOrcIndirectStubsManagerRef), ::libloading::Error>,
    pub LLVMOrcCreateLocalLazyCallThroughManager: Result<
        unsafe extern "C" fn(
            TargetTriple: *const ::std::os::raw::c_char,
            ES: LLVMOrcExecutionSessionRef,
            ErrorHandlerAddr: LLVMOrcJITTargetAddress,
            LCTM: *mut LLVMOrcLazyCallThroughManagerRef,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcDisposeLazyCallThroughManager:
        Result<unsafe extern "C" fn(LCTM: LLVMOrcLazyCallThroughManagerRef), ::libloading::Error>,
    pub LLVMOrcCreateDumpObjects: Result<
        unsafe extern "C" fn(
            DumpDir: *const ::std::os::raw::c_char,
            IdentifierOverride: *const ::std::os::raw::c_char,
        ) -> LLVMOrcDumpObjectsRef,
        ::libloading::Error,
    >,
    pub LLVMOrcDisposeDumpObjects:
        Result<unsafe extern "C" fn(DumpObjects: LLVMOrcDumpObjectsRef), ::libloading::Error>,
    pub LLVMOrcDumpObjects_CallOperator: Result<
        unsafe extern "C" fn(
            DumpObjects: LLVMOrcDumpObjectsRef,
            ObjBuffer: *mut LLVMMemoryBufferRef,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcCreateLLJITBuilder:
        Result<unsafe extern "C" fn() -> LLVMOrcLLJITBuilderRef, ::libloading::Error>,
    pub LLVMOrcDisposeLLJITBuilder:
        Result<unsafe extern "C" fn(Builder: LLVMOrcLLJITBuilderRef), ::libloading::Error>,
    pub LLVMOrcLLJITBuilderSetJITTargetMachineBuilder: Result<
        unsafe extern "C" fn(
            Builder: LLVMOrcLLJITBuilderRef,
            JTMB: LLVMOrcJITTargetMachineBuilderRef,
        ),
        ::libloading::Error,
    >,
    pub LLVMOrcLLJITBuilderSetObjectLinkingLayerCreator: Result<
        unsafe extern "C" fn(
            Builder: LLVMOrcLLJITBuilderRef,
            F: LLVMOrcLLJITBuilderObjectLinkingLayerCreatorFunction,
            Ctx: *mut ::std::os::raw::c_void,
        ),
        ::libloading::Error,
    >,
    pub LLVMOrcCreateLLJIT: Result<
        unsafe extern "C" fn(
            Result: *mut LLVMOrcLLJITRef,
            Builder: LLVMOrcLLJITBuilderRef,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcDisposeLLJIT:
        Result<unsafe extern "C" fn(J: LLVMOrcLLJITRef) -> LLVMErrorRef, ::libloading::Error>,
    pub LLVMOrcLLJITGetExecutionSession: Result<
        unsafe extern "C" fn(J: LLVMOrcLLJITRef) -> LLVMOrcExecutionSessionRef,
        ::libloading::Error,
    >,
    pub LLVMOrcLLJITGetMainJITDylib:
        Result<unsafe extern "C" fn(J: LLVMOrcLLJITRef) -> LLVMOrcJITDylibRef, ::libloading::Error>,
    pub LLVMOrcLLJITGetTripleString: Result<
        unsafe extern "C" fn(J: LLVMOrcLLJITRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMOrcLLJITGetGlobalPrefix: Result<
        unsafe extern "C" fn(J: LLVMOrcLLJITRef) -> ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMOrcLLJITMangleAndIntern: Result<
        unsafe extern "C" fn(
            J: LLVMOrcLLJITRef,
            UnmangledName: *const ::std::os::raw::c_char,
        ) -> LLVMOrcSymbolStringPoolEntryRef,
        ::libloading::Error,
    >,
    pub LLVMOrcLLJITAddObjectFile: Result<
        unsafe extern "C" fn(
            J: LLVMOrcLLJITRef,
            JD: LLVMOrcJITDylibRef,
            ObjBuffer: LLVMMemoryBufferRef,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcLLJITAddObjectFileWithRT: Result<
        unsafe extern "C" fn(
            J: LLVMOrcLLJITRef,
            RT: LLVMOrcResourceTrackerRef,
            ObjBuffer: LLVMMemoryBufferRef,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcLLJITAddLLVMIRModule: Result<
        unsafe extern "C" fn(
            J: LLVMOrcLLJITRef,
            JD: LLVMOrcJITDylibRef,
            TSM: LLVMOrcThreadSafeModuleRef,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcLLJITAddLLVMIRModuleWithRT: Result<
        unsafe extern "C" fn(
            J: LLVMOrcLLJITRef,
            JD: LLVMOrcResourceTrackerRef,
            TSM: LLVMOrcThreadSafeModuleRef,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcLLJITLookup: Result<
        unsafe extern "C" fn(
            J: LLVMOrcLLJITRef,
            Result: *mut LLVMOrcExecutorAddress,
            Name: *const ::std::os::raw::c_char,
        ) -> LLVMErrorRef,
        ::libloading::Error,
    >,
    pub LLVMOrcLLJITGetObjLinkingLayer: Result<
        unsafe extern "C" fn(J: LLVMOrcLLJITRef) -> LLVMOrcObjectLayerRef,
        ::libloading::Error,
    >,
    pub LLVMOrcLLJITGetObjTransformLayer: Result<
        unsafe extern "C" fn(J: LLVMOrcLLJITRef) -> LLVMOrcObjectTransformLayerRef,
        ::libloading::Error,
    >,
    pub LLVMOrcLLJITGetIRTransformLayer: Result<
        unsafe extern "C" fn(J: LLVMOrcLLJITRef) -> LLVMOrcIRTransformLayerRef,
        ::libloading::Error,
    >,
    pub LLVMOrcLLJITGetDataLayoutStr: Result<
        unsafe extern "C" fn(J: LLVMOrcLLJITRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMCreateBinary: Result<
        unsafe extern "C" fn(
            MemBuf: LLVMMemoryBufferRef,
            Context: LLVMContextRef,
            ErrorMessage: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBinaryRef,
        ::libloading::Error,
    >,
    pub LLVMDisposeBinary: Result<unsafe extern "C" fn(BR: LLVMBinaryRef), ::libloading::Error>,
    pub LLVMBinaryCopyMemoryBuffer:
        Result<unsafe extern "C" fn(BR: LLVMBinaryRef) -> LLVMMemoryBufferRef, ::libloading::Error>,
    pub LLVMBinaryGetType:
        Result<unsafe extern "C" fn(BR: LLVMBinaryRef) -> LLVMBinaryType, ::libloading::Error>,
    pub LLVMMachOUniversalBinaryCopyObjectForArch: Result<
        unsafe extern "C" fn(
            BR: LLVMBinaryRef,
            Arch: *const ::std::os::raw::c_char,
            ArchLen: usize,
            ErrorMessage: *mut *mut ::std::os::raw::c_char,
        ) -> LLVMBinaryRef,
        ::libloading::Error,
    >,
    pub LLVMObjectFileCopySectionIterator: Result<
        unsafe extern "C" fn(BR: LLVMBinaryRef) -> LLVMSectionIteratorRef,
        ::libloading::Error,
    >,
    pub LLVMObjectFileIsSectionIteratorAtEnd: Result<
        unsafe extern "C" fn(BR: LLVMBinaryRef, SI: LLVMSectionIteratorRef) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMObjectFileCopySymbolIterator: Result<
        unsafe extern "C" fn(BR: LLVMBinaryRef) -> LLVMSymbolIteratorRef,
        ::libloading::Error,
    >,
    pub LLVMObjectFileIsSymbolIteratorAtEnd: Result<
        unsafe extern "C" fn(BR: LLVMBinaryRef, SI: LLVMSymbolIteratorRef) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMDisposeSectionIterator:
        Result<unsafe extern "C" fn(SI: LLVMSectionIteratorRef), ::libloading::Error>,
    pub LLVMMoveToNextSection:
        Result<unsafe extern "C" fn(SI: LLVMSectionIteratorRef), ::libloading::Error>,
    pub LLVMMoveToContainingSection: Result<
        unsafe extern "C" fn(Sect: LLVMSectionIteratorRef, Sym: LLVMSymbolIteratorRef),
        ::libloading::Error,
    >,
    pub LLVMDisposeSymbolIterator:
        Result<unsafe extern "C" fn(SI: LLVMSymbolIteratorRef), ::libloading::Error>,
    pub LLVMMoveToNextSymbol:
        Result<unsafe extern "C" fn(SI: LLVMSymbolIteratorRef), ::libloading::Error>,
    pub LLVMGetSectionName: Result<
        unsafe extern "C" fn(SI: LLVMSectionIteratorRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetSectionSize:
        Result<unsafe extern "C" fn(SI: LLVMSectionIteratorRef) -> u64, ::libloading::Error>,
    pub LLVMGetSectionContents: Result<
        unsafe extern "C" fn(SI: LLVMSectionIteratorRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetSectionAddress:
        Result<unsafe extern "C" fn(SI: LLVMSectionIteratorRef) -> u64, ::libloading::Error>,
    pub LLVMGetSectionContainsSymbol: Result<
        unsafe extern "C" fn(SI: LLVMSectionIteratorRef, Sym: LLVMSymbolIteratorRef) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMGetRelocations: Result<
        unsafe extern "C" fn(Section: LLVMSectionIteratorRef) -> LLVMRelocationIteratorRef,
        ::libloading::Error,
    >,
    pub LLVMDisposeRelocationIterator:
        Result<unsafe extern "C" fn(RI: LLVMRelocationIteratorRef), ::libloading::Error>,
    pub LLVMIsRelocationIteratorAtEnd: Result<
        unsafe extern "C" fn(
            Section: LLVMSectionIteratorRef,
            RI: LLVMRelocationIteratorRef,
        ) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMMoveToNextRelocation:
        Result<unsafe extern "C" fn(RI: LLVMRelocationIteratorRef), ::libloading::Error>,
    pub LLVMGetSymbolName: Result<
        unsafe extern "C" fn(SI: LLVMSymbolIteratorRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetSymbolAddress:
        Result<unsafe extern "C" fn(SI: LLVMSymbolIteratorRef) -> u64, ::libloading::Error>,
    pub LLVMGetSymbolSize:
        Result<unsafe extern "C" fn(SI: LLVMSymbolIteratorRef) -> u64, ::libloading::Error>,
    pub LLVMGetRelocationOffset:
        Result<unsafe extern "C" fn(RI: LLVMRelocationIteratorRef) -> u64, ::libloading::Error>,
    pub LLVMGetRelocationSymbol: Result<
        unsafe extern "C" fn(RI: LLVMRelocationIteratorRef) -> LLVMSymbolIteratorRef,
        ::libloading::Error,
    >,
    pub LLVMGetRelocationType:
        Result<unsafe extern "C" fn(RI: LLVMRelocationIteratorRef) -> u64, ::libloading::Error>,
    pub LLVMGetRelocationTypeName: Result<
        unsafe extern "C" fn(RI: LLVMRelocationIteratorRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMGetRelocationValueString: Result<
        unsafe extern "C" fn(RI: LLVMRelocationIteratorRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMCreateObjectFile: Result<
        unsafe extern "C" fn(MemBuf: LLVMMemoryBufferRef) -> LLVMObjectFileRef,
        ::libloading::Error,
    >,
    pub LLVMDisposeObjectFile:
        Result<unsafe extern "C" fn(ObjectFile: LLVMObjectFileRef), ::libloading::Error>,
    pub LLVMGetSections: Result<
        unsafe extern "C" fn(ObjectFile: LLVMObjectFileRef) -> LLVMSectionIteratorRef,
        ::libloading::Error,
    >,
    pub LLVMIsSectionIteratorAtEnd: Result<
        unsafe extern "C" fn(ObjectFile: LLVMObjectFileRef, SI: LLVMSectionIteratorRef) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMGetSymbols: Result<
        unsafe extern "C" fn(ObjectFile: LLVMObjectFileRef) -> LLVMSymbolIteratorRef,
        ::libloading::Error,
    >,
    pub LLVMIsSymbolIteratorAtEnd: Result<
        unsafe extern "C" fn(ObjectFile: LLVMObjectFileRef, SI: LLVMSymbolIteratorRef) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMOrcCreateRTDyldObjectLinkingLayerWithSectionMemoryManager: Result<
        unsafe extern "C" fn(ES: LLVMOrcExecutionSessionRef) -> LLVMOrcObjectLayerRef,
        ::libloading::Error,
    >,
    pub LLVMOrcCreateRTDyldObjectLinkingLayerWithMCJITMemoryManagerLikeCallbacks: Result<
        unsafe extern "C" fn(
            ES: LLVMOrcExecutionSessionRef,
            CreateContextCtx: *mut ::std::os::raw::c_void,
            CreateContext: LLVMMemoryManagerCreateContextCallback,
            NotifyTerminating: LLVMMemoryManagerNotifyTerminatingCallback,
            AllocateCodeSection: LLVMMemoryManagerAllocateCodeSectionCallback,
            AllocateDataSection: LLVMMemoryManagerAllocateDataSectionCallback,
            FinalizeMemory: LLVMMemoryManagerFinalizeMemoryCallback,
            Destroy: LLVMMemoryManagerDestroyCallback,
        ) -> LLVMOrcObjectLayerRef,
        ::libloading::Error,
    >,
    pub LLVMOrcRTDyldObjectLinkingLayerRegisterJITEventListener: Result<
        unsafe extern "C" fn(
            RTDyldObjLinkingLayer: LLVMOrcObjectLayerRef,
            Listener: LLVMJITEventListenerRef,
        ),
        ::libloading::Error,
    >,
    pub LLVMRemarkStringGetData: Result<
        unsafe extern "C" fn(String: LLVMRemarkStringRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMRemarkStringGetLen:
        Result<unsafe extern "C" fn(String: LLVMRemarkStringRef) -> u32, ::libloading::Error>,
    pub LLVMRemarkDebugLocGetSourceFilePath: Result<
        unsafe extern "C" fn(DL: LLVMRemarkDebugLocRef) -> LLVMRemarkStringRef,
        ::libloading::Error,
    >,
    pub LLVMRemarkDebugLocGetSourceLine:
        Result<unsafe extern "C" fn(DL: LLVMRemarkDebugLocRef) -> u32, ::libloading::Error>,
    pub LLVMRemarkDebugLocGetSourceColumn:
        Result<unsafe extern "C" fn(DL: LLVMRemarkDebugLocRef) -> u32, ::libloading::Error>,
    pub LLVMRemarkArgGetKey: Result<
        unsafe extern "C" fn(Arg: LLVMRemarkArgRef) -> LLVMRemarkStringRef,
        ::libloading::Error,
    >,
    pub LLVMRemarkArgGetValue: Result<
        unsafe extern "C" fn(Arg: LLVMRemarkArgRef) -> LLVMRemarkStringRef,
        ::libloading::Error,
    >,
    pub LLVMRemarkArgGetDebugLoc: Result<
        unsafe extern "C" fn(Arg: LLVMRemarkArgRef) -> LLVMRemarkDebugLocRef,
        ::libloading::Error,
    >,
    pub LLVMRemarkEntryDispose:
        Result<unsafe extern "C" fn(Remark: LLVMRemarkEntryRef), ::libloading::Error>,
    pub LLVMRemarkEntryGetType: Result<
        unsafe extern "C" fn(Remark: LLVMRemarkEntryRef) -> LLVMRemarkType,
        ::libloading::Error,
    >,
    pub LLVMRemarkEntryGetPassName: Result<
        unsafe extern "C" fn(Remark: LLVMRemarkEntryRef) -> LLVMRemarkStringRef,
        ::libloading::Error,
    >,
    pub LLVMRemarkEntryGetRemarkName: Result<
        unsafe extern "C" fn(Remark: LLVMRemarkEntryRef) -> LLVMRemarkStringRef,
        ::libloading::Error,
    >,
    pub LLVMRemarkEntryGetFunctionName: Result<
        unsafe extern "C" fn(Remark: LLVMRemarkEntryRef) -> LLVMRemarkStringRef,
        ::libloading::Error,
    >,
    pub LLVMRemarkEntryGetDebugLoc: Result<
        unsafe extern "C" fn(Remark: LLVMRemarkEntryRef) -> LLVMRemarkDebugLocRef,
        ::libloading::Error,
    >,
    pub LLVMRemarkEntryGetHotness:
        Result<unsafe extern "C" fn(Remark: LLVMRemarkEntryRef) -> u64, ::libloading::Error>,
    pub LLVMRemarkEntryGetNumArgs:
        Result<unsafe extern "C" fn(Remark: LLVMRemarkEntryRef) -> u32, ::libloading::Error>,
    pub LLVMRemarkEntryGetFirstArg: Result<
        unsafe extern "C" fn(Remark: LLVMRemarkEntryRef) -> LLVMRemarkArgRef,
        ::libloading::Error,
    >,
    pub LLVMRemarkEntryGetNextArg: Result<
        unsafe extern "C" fn(It: LLVMRemarkArgRef, Remark: LLVMRemarkEntryRef) -> LLVMRemarkArgRef,
        ::libloading::Error,
    >,
    pub LLVMRemarkParserCreateYAML: Result<
        unsafe extern "C" fn(Buf: *const ::std::os::raw::c_void, Size: u64) -> LLVMRemarkParserRef,
        ::libloading::Error,
    >,
    pub LLVMRemarkParserCreateBitstream: Result<
        unsafe extern "C" fn(Buf: *const ::std::os::raw::c_void, Size: u64) -> LLVMRemarkParserRef,
        ::libloading::Error,
    >,
    pub LLVMRemarkParserGetNext: Result<
        unsafe extern "C" fn(Parser: LLVMRemarkParserRef) -> LLVMRemarkEntryRef,
        ::libloading::Error,
    >,
    pub LLVMRemarkParserHasError:
        Result<unsafe extern "C" fn(Parser: LLVMRemarkParserRef) -> LLVMBool, ::libloading::Error>,
    pub LLVMRemarkParserGetErrorMessage: Result<
        unsafe extern "C" fn(Parser: LLVMRemarkParserRef) -> *const ::std::os::raw::c_char,
        ::libloading::Error,
    >,
    pub LLVMRemarkParserDispose:
        Result<unsafe extern "C" fn(Parser: LLVMRemarkParserRef), ::libloading::Error>,
    pub LLVMRemarkVersion: Result<unsafe extern "C" fn() -> u32, ::libloading::Error>,
    pub LLVMLoadLibraryPermanently: Result<
        unsafe extern "C" fn(Filename: *const ::std::os::raw::c_char) -> LLVMBool,
        ::libloading::Error,
    >,
    pub LLVMParseCommandLineOptions: Result<
        unsafe extern "C" fn(
            argc: ::std::os::raw::c_int,
            argv: *const *const ::std::os::raw::c_char,
            Overview: *const ::std::os::raw::c_char,
        ),
        ::libloading::Error,
    >,
    pub LLVMSearchForAddressOfSymbol: Result<
        unsafe extern "C" fn(
            symbolName: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_void,
        ::libloading::Error,
    >,
    pub LLVMAddSymbol: Result<
        unsafe extern "C" fn(
            symbolName: *const ::std::os::raw::c_char,
            symbolValue: *mut ::std::os::raw::c_void,
        ),
        ::libloading::Error,
    >,
}
impl llvm {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let LLVMVerifyModule = __library.get(b"LLVMVerifyModule\0").map(|sym| *sym);
        let LLVMVerifyFunction = __library.get(b"LLVMVerifyFunction\0").map(|sym| *sym);
        let LLVMViewFunctionCFG = __library.get(b"LLVMViewFunctionCFG\0").map(|sym| *sym);
        let LLVMViewFunctionCFGOnly = __library.get(b"LLVMViewFunctionCFGOnly\0").map(|sym| *sym);
        let LLVMParseBitcode = __library.get(b"LLVMParseBitcode\0").map(|sym| *sym);
        let LLVMParseBitcode2 = __library.get(b"LLVMParseBitcode2\0").map(|sym| *sym);
        let LLVMParseBitcodeInContext = __library
            .get(b"LLVMParseBitcodeInContext\0")
            .map(|sym| *sym);
        let LLVMParseBitcodeInContext2 = __library
            .get(b"LLVMParseBitcodeInContext2\0")
            .map(|sym| *sym);
        let LLVMGetBitcodeModuleInContext = __library
            .get(b"LLVMGetBitcodeModuleInContext\0")
            .map(|sym| *sym);
        let LLVMGetBitcodeModuleInContext2 = __library
            .get(b"LLVMGetBitcodeModuleInContext2\0")
            .map(|sym| *sym);
        let LLVMGetBitcodeModule = __library.get(b"LLVMGetBitcodeModule\0").map(|sym| *sym);
        let LLVMGetBitcodeModule2 = __library.get(b"LLVMGetBitcodeModule2\0").map(|sym| *sym);
        let LLVMWriteBitcodeToFile = __library.get(b"LLVMWriteBitcodeToFile\0").map(|sym| *sym);
        let LLVMWriteBitcodeToFD = __library.get(b"LLVMWriteBitcodeToFD\0").map(|sym| *sym);
        let LLVMWriteBitcodeToFileHandle = __library
            .get(b"LLVMWriteBitcodeToFileHandle\0")
            .map(|sym| *sym);
        let LLVMWriteBitcodeToMemoryBuffer = __library
            .get(b"LLVMWriteBitcodeToMemoryBuffer\0")
            .map(|sym| *sym);
        let LLVMGetOrInsertComdat = __library.get(b"LLVMGetOrInsertComdat\0").map(|sym| *sym);
        let LLVMGetComdat = __library.get(b"LLVMGetComdat\0").map(|sym| *sym);
        let LLVMSetComdat = __library.get(b"LLVMSetComdat\0").map(|sym| *sym);
        let LLVMGetComdatSelectionKind = __library
            .get(b"LLVMGetComdatSelectionKind\0")
            .map(|sym| *sym);
        let LLVMSetComdatSelectionKind = __library
            .get(b"LLVMSetComdatSelectionKind\0")
            .map(|sym| *sym);
        let LLVMInstallFatalErrorHandler = __library
            .get(b"LLVMInstallFatalErrorHandler\0")
            .map(|sym| *sym);
        let LLVMResetFatalErrorHandler = __library
            .get(b"LLVMResetFatalErrorHandler\0")
            .map(|sym| *sym);
        let LLVMEnablePrettyStackTrace = __library
            .get(b"LLVMEnablePrettyStackTrace\0")
            .map(|sym| *sym);
        let LLVMShutdown = __library.get(b"LLVMShutdown\0").map(|sym| *sym);
        let LLVMGetVersion = __library.get(b"LLVMGetVersion\0").map(|sym| *sym);
        let LLVMCreateMessage = __library.get(b"LLVMCreateMessage\0").map(|sym| *sym);
        let LLVMDisposeMessage = __library.get(b"LLVMDisposeMessage\0").map(|sym| *sym);
        let LLVMContextCreate = __library.get(b"LLVMContextCreate\0").map(|sym| *sym);
        let LLVMGetGlobalContext = __library.get(b"LLVMGetGlobalContext\0").map(|sym| *sym);
        let LLVMContextSetDiagnosticHandler = __library
            .get(b"LLVMContextSetDiagnosticHandler\0")
            .map(|sym| *sym);
        let LLVMContextGetDiagnosticHandler = __library
            .get(b"LLVMContextGetDiagnosticHandler\0")
            .map(|sym| *sym);
        let LLVMContextGetDiagnosticContext = __library
            .get(b"LLVMContextGetDiagnosticContext\0")
            .map(|sym| *sym);
        let LLVMContextSetYieldCallback = __library
            .get(b"LLVMContextSetYieldCallback\0")
            .map(|sym| *sym);
        let LLVMContextShouldDiscardValueNames = __library
            .get(b"LLVMContextShouldDiscardValueNames\0")
            .map(|sym| *sym);
        let LLVMContextSetDiscardValueNames = __library
            .get(b"LLVMContextSetDiscardValueNames\0")
            .map(|sym| *sym);
        let LLVMContextDispose = __library.get(b"LLVMContextDispose\0").map(|sym| *sym);
        let LLVMGetDiagInfoDescription = __library
            .get(b"LLVMGetDiagInfoDescription\0")
            .map(|sym| *sym);
        let LLVMGetDiagInfoSeverity = __library.get(b"LLVMGetDiagInfoSeverity\0").map(|sym| *sym);
        let LLVMGetMDKindIDInContext = __library.get(b"LLVMGetMDKindIDInContext\0").map(|sym| *sym);
        let LLVMGetMDKindID = __library.get(b"LLVMGetMDKindID\0").map(|sym| *sym);
        let LLVMGetEnumAttributeKindForName = __library
            .get(b"LLVMGetEnumAttributeKindForName\0")
            .map(|sym| *sym);
        let LLVMGetLastEnumAttributeKind = __library
            .get(b"LLVMGetLastEnumAttributeKind\0")
            .map(|sym| *sym);
        let LLVMCreateEnumAttribute = __library.get(b"LLVMCreateEnumAttribute\0").map(|sym| *sym);
        let LLVMGetEnumAttributeKind = __library.get(b"LLVMGetEnumAttributeKind\0").map(|sym| *sym);
        let LLVMGetEnumAttributeValue = __library
            .get(b"LLVMGetEnumAttributeValue\0")
            .map(|sym| *sym);
        let LLVMCreateTypeAttribute = __library.get(b"LLVMCreateTypeAttribute\0").map(|sym| *sym);
        let LLVMGetTypeAttributeValue = __library
            .get(b"LLVMGetTypeAttributeValue\0")
            .map(|sym| *sym);
        let LLVMCreateStringAttribute = __library
            .get(b"LLVMCreateStringAttribute\0")
            .map(|sym| *sym);
        let LLVMGetStringAttributeKind = __library
            .get(b"LLVMGetStringAttributeKind\0")
            .map(|sym| *sym);
        let LLVMGetStringAttributeValue = __library
            .get(b"LLVMGetStringAttributeValue\0")
            .map(|sym| *sym);
        let LLVMIsEnumAttribute = __library.get(b"LLVMIsEnumAttribute\0").map(|sym| *sym);
        let LLVMIsStringAttribute = __library.get(b"LLVMIsStringAttribute\0").map(|sym| *sym);
        let LLVMIsTypeAttribute = __library.get(b"LLVMIsTypeAttribute\0").map(|sym| *sym);
        let LLVMGetTypeByName2 = __library.get(b"LLVMGetTypeByName2\0").map(|sym| *sym);
        let LLVMModuleCreateWithName = __library.get(b"LLVMModuleCreateWithName\0").map(|sym| *sym);
        let LLVMModuleCreateWithNameInContext = __library
            .get(b"LLVMModuleCreateWithNameInContext\0")
            .map(|sym| *sym);
        let LLVMCloneModule = __library.get(b"LLVMCloneModule\0").map(|sym| *sym);
        let LLVMDisposeModule = __library.get(b"LLVMDisposeModule\0").map(|sym| *sym);
        let LLVMGetModuleIdentifier = __library.get(b"LLVMGetModuleIdentifier\0").map(|sym| *sym);
        let LLVMSetModuleIdentifier = __library.get(b"LLVMSetModuleIdentifier\0").map(|sym| *sym);
        let LLVMGetSourceFileName = __library.get(b"LLVMGetSourceFileName\0").map(|sym| *sym);
        let LLVMSetSourceFileName = __library.get(b"LLVMSetSourceFileName\0").map(|sym| *sym);
        let LLVMGetDataLayoutStr = __library.get(b"LLVMGetDataLayoutStr\0").map(|sym| *sym);
        let LLVMGetDataLayout = __library.get(b"LLVMGetDataLayout\0").map(|sym| *sym);
        let LLVMSetDataLayout = __library.get(b"LLVMSetDataLayout\0").map(|sym| *sym);
        let LLVMGetTarget = __library.get(b"LLVMGetTarget\0").map(|sym| *sym);
        let LLVMSetTarget = __library.get(b"LLVMSetTarget\0").map(|sym| *sym);
        let LLVMCopyModuleFlagsMetadata = __library
            .get(b"LLVMCopyModuleFlagsMetadata\0")
            .map(|sym| *sym);
        let LLVMDisposeModuleFlagsMetadata = __library
            .get(b"LLVMDisposeModuleFlagsMetadata\0")
            .map(|sym| *sym);
        let LLVMModuleFlagEntriesGetFlagBehavior = __library
            .get(b"LLVMModuleFlagEntriesGetFlagBehavior\0")
            .map(|sym| *sym);
        let LLVMModuleFlagEntriesGetKey = __library
            .get(b"LLVMModuleFlagEntriesGetKey\0")
            .map(|sym| *sym);
        let LLVMModuleFlagEntriesGetMetadata = __library
            .get(b"LLVMModuleFlagEntriesGetMetadata\0")
            .map(|sym| *sym);
        let LLVMGetModuleFlag = __library.get(b"LLVMGetModuleFlag\0").map(|sym| *sym);
        let LLVMAddModuleFlag = __library.get(b"LLVMAddModuleFlag\0").map(|sym| *sym);
        let LLVMDumpModule = __library.get(b"LLVMDumpModule\0").map(|sym| *sym);
        let LLVMPrintModuleToFile = __library.get(b"LLVMPrintModuleToFile\0").map(|sym| *sym);
        let LLVMPrintModuleToString = __library.get(b"LLVMPrintModuleToString\0").map(|sym| *sym);
        let LLVMGetModuleInlineAsm = __library.get(b"LLVMGetModuleInlineAsm\0").map(|sym| *sym);
        let LLVMSetModuleInlineAsm2 = __library.get(b"LLVMSetModuleInlineAsm2\0").map(|sym| *sym);
        let LLVMAppendModuleInlineAsm = __library
            .get(b"LLVMAppendModuleInlineAsm\0")
            .map(|sym| *sym);
        let LLVMGetInlineAsm = __library.get(b"LLVMGetInlineAsm\0").map(|sym| *sym);
        let LLVMGetModuleContext = __library.get(b"LLVMGetModuleContext\0").map(|sym| *sym);
        let LLVMGetTypeByName = __library.get(b"LLVMGetTypeByName\0").map(|sym| *sym);
        let LLVMGetFirstNamedMetadata = __library
            .get(b"LLVMGetFirstNamedMetadata\0")
            .map(|sym| *sym);
        let LLVMGetLastNamedMetadata = __library.get(b"LLVMGetLastNamedMetadata\0").map(|sym| *sym);
        let LLVMGetNextNamedMetadata = __library.get(b"LLVMGetNextNamedMetadata\0").map(|sym| *sym);
        let LLVMGetPreviousNamedMetadata = __library
            .get(b"LLVMGetPreviousNamedMetadata\0")
            .map(|sym| *sym);
        let LLVMGetNamedMetadata = __library.get(b"LLVMGetNamedMetadata\0").map(|sym| *sym);
        let LLVMGetOrInsertNamedMetadata = __library
            .get(b"LLVMGetOrInsertNamedMetadata\0")
            .map(|sym| *sym);
        let LLVMGetNamedMetadataName = __library.get(b"LLVMGetNamedMetadataName\0").map(|sym| *sym);
        let LLVMGetNamedMetadataNumOperands = __library
            .get(b"LLVMGetNamedMetadataNumOperands\0")
            .map(|sym| *sym);
        let LLVMGetNamedMetadataOperands = __library
            .get(b"LLVMGetNamedMetadataOperands\0")
            .map(|sym| *sym);
        let LLVMAddNamedMetadataOperand = __library
            .get(b"LLVMAddNamedMetadataOperand\0")
            .map(|sym| *sym);
        let LLVMGetDebugLocDirectory = __library.get(b"LLVMGetDebugLocDirectory\0").map(|sym| *sym);
        let LLVMGetDebugLocFilename = __library.get(b"LLVMGetDebugLocFilename\0").map(|sym| *sym);
        let LLVMGetDebugLocLine = __library.get(b"LLVMGetDebugLocLine\0").map(|sym| *sym);
        let LLVMGetDebugLocColumn = __library.get(b"LLVMGetDebugLocColumn\0").map(|sym| *sym);
        let LLVMAddFunction = __library.get(b"LLVMAddFunction\0").map(|sym| *sym);
        let LLVMGetNamedFunction = __library.get(b"LLVMGetNamedFunction\0").map(|sym| *sym);
        let LLVMGetFirstFunction = __library.get(b"LLVMGetFirstFunction\0").map(|sym| *sym);
        let LLVMGetLastFunction = __library.get(b"LLVMGetLastFunction\0").map(|sym| *sym);
        let LLVMGetNextFunction = __library.get(b"LLVMGetNextFunction\0").map(|sym| *sym);
        let LLVMGetPreviousFunction = __library.get(b"LLVMGetPreviousFunction\0").map(|sym| *sym);
        let LLVMSetModuleInlineAsm = __library.get(b"LLVMSetModuleInlineAsm\0").map(|sym| *sym);
        let LLVMGetTypeKind = __library.get(b"LLVMGetTypeKind\0").map(|sym| *sym);
        let LLVMTypeIsSized = __library.get(b"LLVMTypeIsSized\0").map(|sym| *sym);
        let LLVMGetTypeContext = __library.get(b"LLVMGetTypeContext\0").map(|sym| *sym);
        let LLVMDumpType = __library.get(b"LLVMDumpType\0").map(|sym| *sym);
        let LLVMPrintTypeToString = __library.get(b"LLVMPrintTypeToString\0").map(|sym| *sym);
        let LLVMInt1TypeInContext = __library.get(b"LLVMInt1TypeInContext\0").map(|sym| *sym);
        let LLVMInt8TypeInContext = __library.get(b"LLVMInt8TypeInContext\0").map(|sym| *sym);
        let LLVMInt16TypeInContext = __library.get(b"LLVMInt16TypeInContext\0").map(|sym| *sym);
        let LLVMInt32TypeInContext = __library.get(b"LLVMInt32TypeInContext\0").map(|sym| *sym);
        let LLVMInt64TypeInContext = __library.get(b"LLVMInt64TypeInContext\0").map(|sym| *sym);
        let LLVMInt128TypeInContext = __library.get(b"LLVMInt128TypeInContext\0").map(|sym| *sym);
        let LLVMIntTypeInContext = __library.get(b"LLVMIntTypeInContext\0").map(|sym| *sym);
        let LLVMInt1Type = __library.get(b"LLVMInt1Type\0").map(|sym| *sym);
        let LLVMInt8Type = __library.get(b"LLVMInt8Type\0").map(|sym| *sym);
        let LLVMInt16Type = __library.get(b"LLVMInt16Type\0").map(|sym| *sym);
        let LLVMInt32Type = __library.get(b"LLVMInt32Type\0").map(|sym| *sym);
        let LLVMInt64Type = __library.get(b"LLVMInt64Type\0").map(|sym| *sym);
        let LLVMInt128Type = __library.get(b"LLVMInt128Type\0").map(|sym| *sym);
        let LLVMIntType = __library.get(b"LLVMIntType\0").map(|sym| *sym);
        let LLVMGetIntTypeWidth = __library.get(b"LLVMGetIntTypeWidth\0").map(|sym| *sym);
        let LLVMHalfTypeInContext = __library.get(b"LLVMHalfTypeInContext\0").map(|sym| *sym);
        let LLVMBFloatTypeInContext = __library.get(b"LLVMBFloatTypeInContext\0").map(|sym| *sym);
        let LLVMFloatTypeInContext = __library.get(b"LLVMFloatTypeInContext\0").map(|sym| *sym);
        let LLVMDoubleTypeInContext = __library.get(b"LLVMDoubleTypeInContext\0").map(|sym| *sym);
        let LLVMX86FP80TypeInContext = __library.get(b"LLVMX86FP80TypeInContext\0").map(|sym| *sym);
        let LLVMFP128TypeInContext = __library.get(b"LLVMFP128TypeInContext\0").map(|sym| *sym);
        let LLVMPPCFP128TypeInContext = __library
            .get(b"LLVMPPCFP128TypeInContext\0")
            .map(|sym| *sym);
        let LLVMHalfType = __library.get(b"LLVMHalfType\0").map(|sym| *sym);
        let LLVMBFloatType = __library.get(b"LLVMBFloatType\0").map(|sym| *sym);
        let LLVMFloatType = __library.get(b"LLVMFloatType\0").map(|sym| *sym);
        let LLVMDoubleType = __library.get(b"LLVMDoubleType\0").map(|sym| *sym);
        let LLVMX86FP80Type = __library.get(b"LLVMX86FP80Type\0").map(|sym| *sym);
        let LLVMFP128Type = __library.get(b"LLVMFP128Type\0").map(|sym| *sym);
        let LLVMPPCFP128Type = __library.get(b"LLVMPPCFP128Type\0").map(|sym| *sym);
        let LLVMFunctionType = __library.get(b"LLVMFunctionType\0").map(|sym| *sym);
        let LLVMIsFunctionVarArg = __library.get(b"LLVMIsFunctionVarArg\0").map(|sym| *sym);
        let LLVMGetReturnType = __library.get(b"LLVMGetReturnType\0").map(|sym| *sym);
        let LLVMCountParamTypes = __library.get(b"LLVMCountParamTypes\0").map(|sym| *sym);
        let LLVMGetParamTypes = __library.get(b"LLVMGetParamTypes\0").map(|sym| *sym);
        let LLVMStructTypeInContext = __library.get(b"LLVMStructTypeInContext\0").map(|sym| *sym);
        let LLVMStructType = __library.get(b"LLVMStructType\0").map(|sym| *sym);
        let LLVMStructCreateNamed = __library.get(b"LLVMStructCreateNamed\0").map(|sym| *sym);
        let LLVMGetStructName = __library.get(b"LLVMGetStructName\0").map(|sym| *sym);
        let LLVMStructSetBody = __library.get(b"LLVMStructSetBody\0").map(|sym| *sym);
        let LLVMCountStructElementTypes = __library
            .get(b"LLVMCountStructElementTypes\0")
            .map(|sym| *sym);
        let LLVMGetStructElementTypes = __library
            .get(b"LLVMGetStructElementTypes\0")
            .map(|sym| *sym);
        let LLVMStructGetTypeAtIndex = __library.get(b"LLVMStructGetTypeAtIndex\0").map(|sym| *sym);
        let LLVMIsPackedStruct = __library.get(b"LLVMIsPackedStruct\0").map(|sym| *sym);
        let LLVMIsOpaqueStruct = __library.get(b"LLVMIsOpaqueStruct\0").map(|sym| *sym);
        let LLVMIsLiteralStruct = __library.get(b"LLVMIsLiteralStruct\0").map(|sym| *sym);
        let LLVMGetElementType = __library.get(b"LLVMGetElementType\0").map(|sym| *sym);
        let LLVMGetSubtypes = __library.get(b"LLVMGetSubtypes\0").map(|sym| *sym);
        let LLVMGetNumContainedTypes = __library.get(b"LLVMGetNumContainedTypes\0").map(|sym| *sym);
        let LLVMArrayType = __library.get(b"LLVMArrayType\0").map(|sym| *sym);
        let LLVMArrayType2 = __library.get(b"LLVMArrayType2\0").map(|sym| *sym);
        let LLVMGetArrayLength = __library.get(b"LLVMGetArrayLength\0").map(|sym| *sym);
        let LLVMGetArrayLength2 = __library.get(b"LLVMGetArrayLength2\0").map(|sym| *sym);
        let LLVMPointerType = __library.get(b"LLVMPointerType\0").map(|sym| *sym);
        let LLVMPointerTypeIsOpaque = __library.get(b"LLVMPointerTypeIsOpaque\0").map(|sym| *sym);
        let LLVMPointerTypeInContext = __library.get(b"LLVMPointerTypeInContext\0").map(|sym| *sym);
        let LLVMGetPointerAddressSpace = __library
            .get(b"LLVMGetPointerAddressSpace\0")
            .map(|sym| *sym);
        let LLVMVectorType = __library.get(b"LLVMVectorType\0").map(|sym| *sym);
        let LLVMScalableVectorType = __library.get(b"LLVMScalableVectorType\0").map(|sym| *sym);
        let LLVMGetVectorSize = __library.get(b"LLVMGetVectorSize\0").map(|sym| *sym);
        let LLVMVoidTypeInContext = __library.get(b"LLVMVoidTypeInContext\0").map(|sym| *sym);
        let LLVMLabelTypeInContext = __library.get(b"LLVMLabelTypeInContext\0").map(|sym| *sym);
        let LLVMX86MMXTypeInContext = __library.get(b"LLVMX86MMXTypeInContext\0").map(|sym| *sym);
        let LLVMX86AMXTypeInContext = __library.get(b"LLVMX86AMXTypeInContext\0").map(|sym| *sym);
        let LLVMTokenTypeInContext = __library.get(b"LLVMTokenTypeInContext\0").map(|sym| *sym);
        let LLVMMetadataTypeInContext = __library
            .get(b"LLVMMetadataTypeInContext\0")
            .map(|sym| *sym);
        let LLVMVoidType = __library.get(b"LLVMVoidType\0").map(|sym| *sym);
        let LLVMLabelType = __library.get(b"LLVMLabelType\0").map(|sym| *sym);
        let LLVMX86MMXType = __library.get(b"LLVMX86MMXType\0").map(|sym| *sym);
        let LLVMX86AMXType = __library.get(b"LLVMX86AMXType\0").map(|sym| *sym);
        let LLVMTargetExtTypeInContext = __library
            .get(b"LLVMTargetExtTypeInContext\0")
            .map(|sym| *sym);
        let LLVMTypeOf = __library.get(b"LLVMTypeOf\0").map(|sym| *sym);
        let LLVMGetValueKind = __library.get(b"LLVMGetValueKind\0").map(|sym| *sym);
        let LLVMGetValueName2 = __library.get(b"LLVMGetValueName2\0").map(|sym| *sym);
        let LLVMSetValueName2 = __library.get(b"LLVMSetValueName2\0").map(|sym| *sym);
        let LLVMDumpValue = __library.get(b"LLVMDumpValue\0").map(|sym| *sym);
        let LLVMPrintValueToString = __library.get(b"LLVMPrintValueToString\0").map(|sym| *sym);
        let LLVMReplaceAllUsesWith = __library.get(b"LLVMReplaceAllUsesWith\0").map(|sym| *sym);
        let LLVMIsConstant = __library.get(b"LLVMIsConstant\0").map(|sym| *sym);
        let LLVMIsUndef = __library.get(b"LLVMIsUndef\0").map(|sym| *sym);
        let LLVMIsPoison = __library.get(b"LLVMIsPoison\0").map(|sym| *sym);
        let LLVMIsAArgument = __library.get(b"LLVMIsAArgument\0").map(|sym| *sym);
        let LLVMIsABasicBlock = __library.get(b"LLVMIsABasicBlock\0").map(|sym| *sym);
        let LLVMIsAInlineAsm = __library.get(b"LLVMIsAInlineAsm\0").map(|sym| *sym);
        let LLVMIsAUser = __library.get(b"LLVMIsAUser\0").map(|sym| *sym);
        let LLVMIsAConstant = __library.get(b"LLVMIsAConstant\0").map(|sym| *sym);
        let LLVMIsABlockAddress = __library.get(b"LLVMIsABlockAddress\0").map(|sym| *sym);
        let LLVMIsAConstantAggregateZero = __library
            .get(b"LLVMIsAConstantAggregateZero\0")
            .map(|sym| *sym);
        let LLVMIsAConstantArray = __library.get(b"LLVMIsAConstantArray\0").map(|sym| *sym);
        let LLVMIsAConstantDataSequential = __library
            .get(b"LLVMIsAConstantDataSequential\0")
            .map(|sym| *sym);
        let LLVMIsAConstantDataArray = __library.get(b"LLVMIsAConstantDataArray\0").map(|sym| *sym);
        let LLVMIsAConstantDataVector = __library
            .get(b"LLVMIsAConstantDataVector\0")
            .map(|sym| *sym);
        let LLVMIsAConstantExpr = __library.get(b"LLVMIsAConstantExpr\0").map(|sym| *sym);
        let LLVMIsAConstantFP = __library.get(b"LLVMIsAConstantFP\0").map(|sym| *sym);
        let LLVMIsAConstantInt = __library.get(b"LLVMIsAConstantInt\0").map(|sym| *sym);
        let LLVMIsAConstantPointerNull = __library
            .get(b"LLVMIsAConstantPointerNull\0")
            .map(|sym| *sym);
        let LLVMIsAConstantStruct = __library.get(b"LLVMIsAConstantStruct\0").map(|sym| *sym);
        let LLVMIsAConstantTokenNone = __library.get(b"LLVMIsAConstantTokenNone\0").map(|sym| *sym);
        let LLVMIsAConstantVector = __library.get(b"LLVMIsAConstantVector\0").map(|sym| *sym);
        let LLVMIsAGlobalValue = __library.get(b"LLVMIsAGlobalValue\0").map(|sym| *sym);
        let LLVMIsAGlobalAlias = __library.get(b"LLVMIsAGlobalAlias\0").map(|sym| *sym);
        let LLVMIsAGlobalObject = __library.get(b"LLVMIsAGlobalObject\0").map(|sym| *sym);
        let LLVMIsAFunction = __library.get(b"LLVMIsAFunction\0").map(|sym| *sym);
        let LLVMIsAGlobalVariable = __library.get(b"LLVMIsAGlobalVariable\0").map(|sym| *sym);
        let LLVMIsAGlobalIFunc = __library.get(b"LLVMIsAGlobalIFunc\0").map(|sym| *sym);
        let LLVMIsAUndefValue = __library.get(b"LLVMIsAUndefValue\0").map(|sym| *sym);
        let LLVMIsAPoisonValue = __library.get(b"LLVMIsAPoisonValue\0").map(|sym| *sym);
        let LLVMIsAInstruction = __library.get(b"LLVMIsAInstruction\0").map(|sym| *sym);
        let LLVMIsAUnaryOperator = __library.get(b"LLVMIsAUnaryOperator\0").map(|sym| *sym);
        let LLVMIsABinaryOperator = __library.get(b"LLVMIsABinaryOperator\0").map(|sym| *sym);
        let LLVMIsACallInst = __library.get(b"LLVMIsACallInst\0").map(|sym| *sym);
        let LLVMIsAIntrinsicInst = __library.get(b"LLVMIsAIntrinsicInst\0").map(|sym| *sym);
        let LLVMIsADbgInfoIntrinsic = __library.get(b"LLVMIsADbgInfoIntrinsic\0").map(|sym| *sym);
        let LLVMIsADbgVariableIntrinsic = __library
            .get(b"LLVMIsADbgVariableIntrinsic\0")
            .map(|sym| *sym);
        let LLVMIsADbgDeclareInst = __library.get(b"LLVMIsADbgDeclareInst\0").map(|sym| *sym);
        let LLVMIsADbgLabelInst = __library.get(b"LLVMIsADbgLabelInst\0").map(|sym| *sym);
        let LLVMIsAMemIntrinsic = __library.get(b"LLVMIsAMemIntrinsic\0").map(|sym| *sym);
        let LLVMIsAMemCpyInst = __library.get(b"LLVMIsAMemCpyInst\0").map(|sym| *sym);
        let LLVMIsAMemMoveInst = __library.get(b"LLVMIsAMemMoveInst\0").map(|sym| *sym);
        let LLVMIsAMemSetInst = __library.get(b"LLVMIsAMemSetInst\0").map(|sym| *sym);
        let LLVMIsACmpInst = __library.get(b"LLVMIsACmpInst\0").map(|sym| *sym);
        let LLVMIsAFCmpInst = __library.get(b"LLVMIsAFCmpInst\0").map(|sym| *sym);
        let LLVMIsAICmpInst = __library.get(b"LLVMIsAICmpInst\0").map(|sym| *sym);
        let LLVMIsAExtractElementInst = __library
            .get(b"LLVMIsAExtractElementInst\0")
            .map(|sym| *sym);
        let LLVMIsAGetElementPtrInst = __library.get(b"LLVMIsAGetElementPtrInst\0").map(|sym| *sym);
        let LLVMIsAInsertElementInst = __library.get(b"LLVMIsAInsertElementInst\0").map(|sym| *sym);
        let LLVMIsAInsertValueInst = __library.get(b"LLVMIsAInsertValueInst\0").map(|sym| *sym);
        let LLVMIsALandingPadInst = __library.get(b"LLVMIsALandingPadInst\0").map(|sym| *sym);
        let LLVMIsAPHINode = __library.get(b"LLVMIsAPHINode\0").map(|sym| *sym);
        let LLVMIsASelectInst = __library.get(b"LLVMIsASelectInst\0").map(|sym| *sym);
        let LLVMIsAShuffleVectorInst = __library.get(b"LLVMIsAShuffleVectorInst\0").map(|sym| *sym);
        let LLVMIsAStoreInst = __library.get(b"LLVMIsAStoreInst\0").map(|sym| *sym);
        let LLVMIsABranchInst = __library.get(b"LLVMIsABranchInst\0").map(|sym| *sym);
        let LLVMIsAIndirectBrInst = __library.get(b"LLVMIsAIndirectBrInst\0").map(|sym| *sym);
        let LLVMIsAInvokeInst = __library.get(b"LLVMIsAInvokeInst\0").map(|sym| *sym);
        let LLVMIsAReturnInst = __library.get(b"LLVMIsAReturnInst\0").map(|sym| *sym);
        let LLVMIsASwitchInst = __library.get(b"LLVMIsASwitchInst\0").map(|sym| *sym);
        let LLVMIsAUnreachableInst = __library.get(b"LLVMIsAUnreachableInst\0").map(|sym| *sym);
        let LLVMIsAResumeInst = __library.get(b"LLVMIsAResumeInst\0").map(|sym| *sym);
        let LLVMIsACleanupReturnInst = __library.get(b"LLVMIsACleanupReturnInst\0").map(|sym| *sym);
        let LLVMIsACatchReturnInst = __library.get(b"LLVMIsACatchReturnInst\0").map(|sym| *sym);
        let LLVMIsACatchSwitchInst = __library.get(b"LLVMIsACatchSwitchInst\0").map(|sym| *sym);
        let LLVMIsACallBrInst = __library.get(b"LLVMIsACallBrInst\0").map(|sym| *sym);
        let LLVMIsAFuncletPadInst = __library.get(b"LLVMIsAFuncletPadInst\0").map(|sym| *sym);
        let LLVMIsACatchPadInst = __library.get(b"LLVMIsACatchPadInst\0").map(|sym| *sym);
        let LLVMIsACleanupPadInst = __library.get(b"LLVMIsACleanupPadInst\0").map(|sym| *sym);
        let LLVMIsAUnaryInstruction = __library.get(b"LLVMIsAUnaryInstruction\0").map(|sym| *sym);
        let LLVMIsAAllocaInst = __library.get(b"LLVMIsAAllocaInst\0").map(|sym| *sym);
        let LLVMIsACastInst = __library.get(b"LLVMIsACastInst\0").map(|sym| *sym);
        let LLVMIsAAddrSpaceCastInst = __library.get(b"LLVMIsAAddrSpaceCastInst\0").map(|sym| *sym);
        let LLVMIsABitCastInst = __library.get(b"LLVMIsABitCastInst\0").map(|sym| *sym);
        let LLVMIsAFPExtInst = __library.get(b"LLVMIsAFPExtInst\0").map(|sym| *sym);
        let LLVMIsAFPToSIInst = __library.get(b"LLVMIsAFPToSIInst\0").map(|sym| *sym);
        let LLVMIsAFPToUIInst = __library.get(b"LLVMIsAFPToUIInst\0").map(|sym| *sym);
        let LLVMIsAFPTruncInst = __library.get(b"LLVMIsAFPTruncInst\0").map(|sym| *sym);
        let LLVMIsAIntToPtrInst = __library.get(b"LLVMIsAIntToPtrInst\0").map(|sym| *sym);
        let LLVMIsAPtrToIntInst = __library.get(b"LLVMIsAPtrToIntInst\0").map(|sym| *sym);
        let LLVMIsASExtInst = __library.get(b"LLVMIsASExtInst\0").map(|sym| *sym);
        let LLVMIsASIToFPInst = __library.get(b"LLVMIsASIToFPInst\0").map(|sym| *sym);
        let LLVMIsATruncInst = __library.get(b"LLVMIsATruncInst\0").map(|sym| *sym);
        let LLVMIsAUIToFPInst = __library.get(b"LLVMIsAUIToFPInst\0").map(|sym| *sym);
        let LLVMIsAZExtInst = __library.get(b"LLVMIsAZExtInst\0").map(|sym| *sym);
        let LLVMIsAExtractValueInst = __library.get(b"LLVMIsAExtractValueInst\0").map(|sym| *sym);
        let LLVMIsALoadInst = __library.get(b"LLVMIsALoadInst\0").map(|sym| *sym);
        let LLVMIsAVAArgInst = __library.get(b"LLVMIsAVAArgInst\0").map(|sym| *sym);
        let LLVMIsAFreezeInst = __library.get(b"LLVMIsAFreezeInst\0").map(|sym| *sym);
        let LLVMIsAAtomicCmpXchgInst = __library.get(b"LLVMIsAAtomicCmpXchgInst\0").map(|sym| *sym);
        let LLVMIsAAtomicRMWInst = __library.get(b"LLVMIsAAtomicRMWInst\0").map(|sym| *sym);
        let LLVMIsAFenceInst = __library.get(b"LLVMIsAFenceInst\0").map(|sym| *sym);
        let LLVMIsAMDNode = __library.get(b"LLVMIsAMDNode\0").map(|sym| *sym);
        let LLVMIsAValueAsMetadata = __library.get(b"LLVMIsAValueAsMetadata\0").map(|sym| *sym);
        let LLVMIsAMDString = __library.get(b"LLVMIsAMDString\0").map(|sym| *sym);
        let LLVMGetValueName = __library.get(b"LLVMGetValueName\0").map(|sym| *sym);
        let LLVMSetValueName = __library.get(b"LLVMSetValueName\0").map(|sym| *sym);
        let LLVMGetFirstUse = __library.get(b"LLVMGetFirstUse\0").map(|sym| *sym);
        let LLVMGetNextUse = __library.get(b"LLVMGetNextUse\0").map(|sym| *sym);
        let LLVMGetUser = __library.get(b"LLVMGetUser\0").map(|sym| *sym);
        let LLVMGetUsedValue = __library.get(b"LLVMGetUsedValue\0").map(|sym| *sym);
        let LLVMGetOperand = __library.get(b"LLVMGetOperand\0").map(|sym| *sym);
        let LLVMGetOperandUse = __library.get(b"LLVMGetOperandUse\0").map(|sym| *sym);
        let LLVMSetOperand = __library.get(b"LLVMSetOperand\0").map(|sym| *sym);
        let LLVMGetNumOperands = __library.get(b"LLVMGetNumOperands\0").map(|sym| *sym);
        let LLVMConstNull = __library.get(b"LLVMConstNull\0").map(|sym| *sym);
        let LLVMConstAllOnes = __library.get(b"LLVMConstAllOnes\0").map(|sym| *sym);
        let LLVMGetUndef = __library.get(b"LLVMGetUndef\0").map(|sym| *sym);
        let LLVMGetPoison = __library.get(b"LLVMGetPoison\0").map(|sym| *sym);
        let LLVMIsNull = __library.get(b"LLVMIsNull\0").map(|sym| *sym);
        let LLVMConstPointerNull = __library.get(b"LLVMConstPointerNull\0").map(|sym| *sym);
        let LLVMConstInt = __library.get(b"LLVMConstInt\0").map(|sym| *sym);
        let LLVMConstIntOfArbitraryPrecision = __library
            .get(b"LLVMConstIntOfArbitraryPrecision\0")
            .map(|sym| *sym);
        let LLVMConstIntOfString = __library.get(b"LLVMConstIntOfString\0").map(|sym| *sym);
        let LLVMConstIntOfStringAndSize = __library
            .get(b"LLVMConstIntOfStringAndSize\0")
            .map(|sym| *sym);
        let LLVMConstReal = __library.get(b"LLVMConstReal\0").map(|sym| *sym);
        let LLVMConstRealOfString = __library.get(b"LLVMConstRealOfString\0").map(|sym| *sym);
        let LLVMConstRealOfStringAndSize = __library
            .get(b"LLVMConstRealOfStringAndSize\0")
            .map(|sym| *sym);
        let LLVMConstIntGetZExtValue = __library.get(b"LLVMConstIntGetZExtValue\0").map(|sym| *sym);
        let LLVMConstIntGetSExtValue = __library.get(b"LLVMConstIntGetSExtValue\0").map(|sym| *sym);
        let LLVMConstRealGetDouble = __library.get(b"LLVMConstRealGetDouble\0").map(|sym| *sym);
        let LLVMConstStringInContext = __library.get(b"LLVMConstStringInContext\0").map(|sym| *sym);
        let LLVMConstString = __library.get(b"LLVMConstString\0").map(|sym| *sym);
        let LLVMIsConstantString = __library.get(b"LLVMIsConstantString\0").map(|sym| *sym);
        let LLVMGetAsString = __library.get(b"LLVMGetAsString\0").map(|sym| *sym);
        let LLVMConstStructInContext = __library.get(b"LLVMConstStructInContext\0").map(|sym| *sym);
        let LLVMConstStruct = __library.get(b"LLVMConstStruct\0").map(|sym| *sym);
        let LLVMConstArray = __library.get(b"LLVMConstArray\0").map(|sym| *sym);
        let LLVMConstArray2 = __library.get(b"LLVMConstArray2\0").map(|sym| *sym);
        let LLVMConstNamedStruct = __library.get(b"LLVMConstNamedStruct\0").map(|sym| *sym);
        let LLVMGetAggregateElement = __library.get(b"LLVMGetAggregateElement\0").map(|sym| *sym);
        let LLVMGetElementAsConstant = __library.get(b"LLVMGetElementAsConstant\0").map(|sym| *sym);
        let LLVMConstVector = __library.get(b"LLVMConstVector\0").map(|sym| *sym);
        let LLVMGetConstOpcode = __library.get(b"LLVMGetConstOpcode\0").map(|sym| *sym);
        let LLVMAlignOf = __library.get(b"LLVMAlignOf\0").map(|sym| *sym);
        let LLVMSizeOf = __library.get(b"LLVMSizeOf\0").map(|sym| *sym);
        let LLVMConstNeg = __library.get(b"LLVMConstNeg\0").map(|sym| *sym);
        let LLVMConstNSWNeg = __library.get(b"LLVMConstNSWNeg\0").map(|sym| *sym);
        let LLVMConstNUWNeg = __library.get(b"LLVMConstNUWNeg\0").map(|sym| *sym);
        let LLVMConstNot = __library.get(b"LLVMConstNot\0").map(|sym| *sym);
        let LLVMConstAdd = __library.get(b"LLVMConstAdd\0").map(|sym| *sym);
        let LLVMConstNSWAdd = __library.get(b"LLVMConstNSWAdd\0").map(|sym| *sym);
        let LLVMConstNUWAdd = __library.get(b"LLVMConstNUWAdd\0").map(|sym| *sym);
        let LLVMConstSub = __library.get(b"LLVMConstSub\0").map(|sym| *sym);
        let LLVMConstNSWSub = __library.get(b"LLVMConstNSWSub\0").map(|sym| *sym);
        let LLVMConstNUWSub = __library.get(b"LLVMConstNUWSub\0").map(|sym| *sym);
        let LLVMConstMul = __library.get(b"LLVMConstMul\0").map(|sym| *sym);
        let LLVMConstNSWMul = __library.get(b"LLVMConstNSWMul\0").map(|sym| *sym);
        let LLVMConstNUWMul = __library.get(b"LLVMConstNUWMul\0").map(|sym| *sym);
        let LLVMConstAnd = __library.get(b"LLVMConstAnd\0").map(|sym| *sym);
        let LLVMConstOr = __library.get(b"LLVMConstOr\0").map(|sym| *sym);
        let LLVMConstXor = __library.get(b"LLVMConstXor\0").map(|sym| *sym);
        let LLVMConstICmp = __library.get(b"LLVMConstICmp\0").map(|sym| *sym);
        let LLVMConstFCmp = __library.get(b"LLVMConstFCmp\0").map(|sym| *sym);
        let LLVMConstShl = __library.get(b"LLVMConstShl\0").map(|sym| *sym);
        let LLVMConstLShr = __library.get(b"LLVMConstLShr\0").map(|sym| *sym);
        let LLVMConstAShr = __library.get(b"LLVMConstAShr\0").map(|sym| *sym);
        let LLVMConstGEP2 = __library.get(b"LLVMConstGEP2\0").map(|sym| *sym);
        let LLVMConstInBoundsGEP2 = __library.get(b"LLVMConstInBoundsGEP2\0").map(|sym| *sym);
        let LLVMConstTrunc = __library.get(b"LLVMConstTrunc\0").map(|sym| *sym);
        let LLVMConstSExt = __library.get(b"LLVMConstSExt\0").map(|sym| *sym);
        let LLVMConstZExt = __library.get(b"LLVMConstZExt\0").map(|sym| *sym);
        let LLVMConstFPTrunc = __library.get(b"LLVMConstFPTrunc\0").map(|sym| *sym);
        let LLVMConstFPExt = __library.get(b"LLVMConstFPExt\0").map(|sym| *sym);
        let LLVMConstUIToFP = __library.get(b"LLVMConstUIToFP\0").map(|sym| *sym);
        let LLVMConstSIToFP = __library.get(b"LLVMConstSIToFP\0").map(|sym| *sym);
        let LLVMConstFPToUI = __library.get(b"LLVMConstFPToUI\0").map(|sym| *sym);
        let LLVMConstFPToSI = __library.get(b"LLVMConstFPToSI\0").map(|sym| *sym);
        let LLVMConstPtrToInt = __library.get(b"LLVMConstPtrToInt\0").map(|sym| *sym);
        let LLVMConstIntToPtr = __library.get(b"LLVMConstIntToPtr\0").map(|sym| *sym);
        let LLVMConstBitCast = __library.get(b"LLVMConstBitCast\0").map(|sym| *sym);
        let LLVMConstAddrSpaceCast = __library.get(b"LLVMConstAddrSpaceCast\0").map(|sym| *sym);
        let LLVMConstZExtOrBitCast = __library.get(b"LLVMConstZExtOrBitCast\0").map(|sym| *sym);
        let LLVMConstSExtOrBitCast = __library.get(b"LLVMConstSExtOrBitCast\0").map(|sym| *sym);
        let LLVMConstTruncOrBitCast = __library.get(b"LLVMConstTruncOrBitCast\0").map(|sym| *sym);
        let LLVMConstPointerCast = __library.get(b"LLVMConstPointerCast\0").map(|sym| *sym);
        let LLVMConstIntCast = __library.get(b"LLVMConstIntCast\0").map(|sym| *sym);
        let LLVMConstFPCast = __library.get(b"LLVMConstFPCast\0").map(|sym| *sym);
        let LLVMConstExtractElement = __library.get(b"LLVMConstExtractElement\0").map(|sym| *sym);
        let LLVMConstInsertElement = __library.get(b"LLVMConstInsertElement\0").map(|sym| *sym);
        let LLVMConstShuffleVector = __library.get(b"LLVMConstShuffleVector\0").map(|sym| *sym);
        let LLVMBlockAddress = __library.get(b"LLVMBlockAddress\0").map(|sym| *sym);
        let LLVMConstInlineAsm = __library.get(b"LLVMConstInlineAsm\0").map(|sym| *sym);
        let LLVMGetGlobalParent = __library.get(b"LLVMGetGlobalParent\0").map(|sym| *sym);
        let LLVMIsDeclaration = __library.get(b"LLVMIsDeclaration\0").map(|sym| *sym);
        let LLVMGetLinkage = __library.get(b"LLVMGetLinkage\0").map(|sym| *sym);
        let LLVMSetLinkage = __library.get(b"LLVMSetLinkage\0").map(|sym| *sym);
        let LLVMGetSection = __library.get(b"LLVMGetSection\0").map(|sym| *sym);
        let LLVMSetSection = __library.get(b"LLVMSetSection\0").map(|sym| *sym);
        let LLVMGetVisibility = __library.get(b"LLVMGetVisibility\0").map(|sym| *sym);
        let LLVMSetVisibility = __library.get(b"LLVMSetVisibility\0").map(|sym| *sym);
        let LLVMGetDLLStorageClass = __library.get(b"LLVMGetDLLStorageClass\0").map(|sym| *sym);
        let LLVMSetDLLStorageClass = __library.get(b"LLVMSetDLLStorageClass\0").map(|sym| *sym);
        let LLVMGetUnnamedAddress = __library.get(b"LLVMGetUnnamedAddress\0").map(|sym| *sym);
        let LLVMSetUnnamedAddress = __library.get(b"LLVMSetUnnamedAddress\0").map(|sym| *sym);
        let LLVMGlobalGetValueType = __library.get(b"LLVMGlobalGetValueType\0").map(|sym| *sym);
        let LLVMHasUnnamedAddr = __library.get(b"LLVMHasUnnamedAddr\0").map(|sym| *sym);
        let LLVMSetUnnamedAddr = __library.get(b"LLVMSetUnnamedAddr\0").map(|sym| *sym);
        let LLVMGetAlignment = __library.get(b"LLVMGetAlignment\0").map(|sym| *sym);
        let LLVMSetAlignment = __library.get(b"LLVMSetAlignment\0").map(|sym| *sym);
        let LLVMGlobalSetMetadata = __library.get(b"LLVMGlobalSetMetadata\0").map(|sym| *sym);
        let LLVMGlobalEraseMetadata = __library.get(b"LLVMGlobalEraseMetadata\0").map(|sym| *sym);
        let LLVMGlobalClearMetadata = __library.get(b"LLVMGlobalClearMetadata\0").map(|sym| *sym);
        let LLVMGlobalCopyAllMetadata = __library
            .get(b"LLVMGlobalCopyAllMetadata\0")
            .map(|sym| *sym);
        let LLVMDisposeValueMetadataEntries = __library
            .get(b"LLVMDisposeValueMetadataEntries\0")
            .map(|sym| *sym);
        let LLVMValueMetadataEntriesGetKind = __library
            .get(b"LLVMValueMetadataEntriesGetKind\0")
            .map(|sym| *sym);
        let LLVMValueMetadataEntriesGetMetadata = __library
            .get(b"LLVMValueMetadataEntriesGetMetadata\0")
            .map(|sym| *sym);
        let LLVMAddGlobal = __library.get(b"LLVMAddGlobal\0").map(|sym| *sym);
        let LLVMAddGlobalInAddressSpace = __library
            .get(b"LLVMAddGlobalInAddressSpace\0")
            .map(|sym| *sym);
        let LLVMGetNamedGlobal = __library.get(b"LLVMGetNamedGlobal\0").map(|sym| *sym);
        let LLVMGetFirstGlobal = __library.get(b"LLVMGetFirstGlobal\0").map(|sym| *sym);
        let LLVMGetLastGlobal = __library.get(b"LLVMGetLastGlobal\0").map(|sym| *sym);
        let LLVMGetNextGlobal = __library.get(b"LLVMGetNextGlobal\0").map(|sym| *sym);
        let LLVMGetPreviousGlobal = __library.get(b"LLVMGetPreviousGlobal\0").map(|sym| *sym);
        let LLVMDeleteGlobal = __library.get(b"LLVMDeleteGlobal\0").map(|sym| *sym);
        let LLVMGetInitializer = __library.get(b"LLVMGetInitializer\0").map(|sym| *sym);
        let LLVMSetInitializer = __library.get(b"LLVMSetInitializer\0").map(|sym| *sym);
        let LLVMIsThreadLocal = __library.get(b"LLVMIsThreadLocal\0").map(|sym| *sym);
        let LLVMSetThreadLocal = __library.get(b"LLVMSetThreadLocal\0").map(|sym| *sym);
        let LLVMIsGlobalConstant = __library.get(b"LLVMIsGlobalConstant\0").map(|sym| *sym);
        let LLVMSetGlobalConstant = __library.get(b"LLVMSetGlobalConstant\0").map(|sym| *sym);
        let LLVMGetThreadLocalMode = __library.get(b"LLVMGetThreadLocalMode\0").map(|sym| *sym);
        let LLVMSetThreadLocalMode = __library.get(b"LLVMSetThreadLocalMode\0").map(|sym| *sym);
        let LLVMIsExternallyInitialized = __library
            .get(b"LLVMIsExternallyInitialized\0")
            .map(|sym| *sym);
        let LLVMSetExternallyInitialized = __library
            .get(b"LLVMSetExternallyInitialized\0")
            .map(|sym| *sym);
        let LLVMAddAlias2 = __library.get(b"LLVMAddAlias2\0").map(|sym| *sym);
        let LLVMGetNamedGlobalAlias = __library.get(b"LLVMGetNamedGlobalAlias\0").map(|sym| *sym);
        let LLVMGetFirstGlobalAlias = __library.get(b"LLVMGetFirstGlobalAlias\0").map(|sym| *sym);
        let LLVMGetLastGlobalAlias = __library.get(b"LLVMGetLastGlobalAlias\0").map(|sym| *sym);
        let LLVMGetNextGlobalAlias = __library.get(b"LLVMGetNextGlobalAlias\0").map(|sym| *sym);
        let LLVMGetPreviousGlobalAlias = __library
            .get(b"LLVMGetPreviousGlobalAlias\0")
            .map(|sym| *sym);
        let LLVMAliasGetAliasee = __library.get(b"LLVMAliasGetAliasee\0").map(|sym| *sym);
        let LLVMAliasSetAliasee = __library.get(b"LLVMAliasSetAliasee\0").map(|sym| *sym);
        let LLVMDeleteFunction = __library.get(b"LLVMDeleteFunction\0").map(|sym| *sym);
        let LLVMHasPersonalityFn = __library.get(b"LLVMHasPersonalityFn\0").map(|sym| *sym);
        let LLVMGetPersonalityFn = __library.get(b"LLVMGetPersonalityFn\0").map(|sym| *sym);
        let LLVMSetPersonalityFn = __library.get(b"LLVMSetPersonalityFn\0").map(|sym| *sym);
        let LLVMLookupIntrinsicID = __library.get(b"LLVMLookupIntrinsicID\0").map(|sym| *sym);
        let LLVMGetIntrinsicID = __library.get(b"LLVMGetIntrinsicID\0").map(|sym| *sym);
        let LLVMGetIntrinsicDeclaration = __library
            .get(b"LLVMGetIntrinsicDeclaration\0")
            .map(|sym| *sym);
        let LLVMIntrinsicGetType = __library.get(b"LLVMIntrinsicGetType\0").map(|sym| *sym);
        let LLVMIntrinsicGetName = __library.get(b"LLVMIntrinsicGetName\0").map(|sym| *sym);
        let LLVMIntrinsicCopyOverloadedName = __library
            .get(b"LLVMIntrinsicCopyOverloadedName\0")
            .map(|sym| *sym);
        let LLVMIntrinsicCopyOverloadedName2 = __library
            .get(b"LLVMIntrinsicCopyOverloadedName2\0")
            .map(|sym| *sym);
        let LLVMIntrinsicIsOverloaded = __library
            .get(b"LLVMIntrinsicIsOverloaded\0")
            .map(|sym| *sym);
        let LLVMGetFunctionCallConv = __library.get(b"LLVMGetFunctionCallConv\0").map(|sym| *sym);
        let LLVMSetFunctionCallConv = __library.get(b"LLVMSetFunctionCallConv\0").map(|sym| *sym);
        let LLVMGetGC = __library.get(b"LLVMGetGC\0").map(|sym| *sym);
        let LLVMSetGC = __library.get(b"LLVMSetGC\0").map(|sym| *sym);
        let LLVMAddAttributeAtIndex = __library.get(b"LLVMAddAttributeAtIndex\0").map(|sym| *sym);
        let LLVMGetAttributeCountAtIndex = __library
            .get(b"LLVMGetAttributeCountAtIndex\0")
            .map(|sym| *sym);
        let LLVMGetAttributesAtIndex = __library.get(b"LLVMGetAttributesAtIndex\0").map(|sym| *sym);
        let LLVMGetEnumAttributeAtIndex = __library
            .get(b"LLVMGetEnumAttributeAtIndex\0")
            .map(|sym| *sym);
        let LLVMGetStringAttributeAtIndex = __library
            .get(b"LLVMGetStringAttributeAtIndex\0")
            .map(|sym| *sym);
        let LLVMRemoveEnumAttributeAtIndex = __library
            .get(b"LLVMRemoveEnumAttributeAtIndex\0")
            .map(|sym| *sym);
        let LLVMRemoveStringAttributeAtIndex = __library
            .get(b"LLVMRemoveStringAttributeAtIndex\0")
            .map(|sym| *sym);
        let LLVMAddTargetDependentFunctionAttr = __library
            .get(b"LLVMAddTargetDependentFunctionAttr\0")
            .map(|sym| *sym);
        let LLVMCountParams = __library.get(b"LLVMCountParams\0").map(|sym| *sym);
        let LLVMGetParams = __library.get(b"LLVMGetParams\0").map(|sym| *sym);
        let LLVMGetParam = __library.get(b"LLVMGetParam\0").map(|sym| *sym);
        let LLVMGetParamParent = __library.get(b"LLVMGetParamParent\0").map(|sym| *sym);
        let LLVMGetFirstParam = __library.get(b"LLVMGetFirstParam\0").map(|sym| *sym);
        let LLVMGetLastParam = __library.get(b"LLVMGetLastParam\0").map(|sym| *sym);
        let LLVMGetNextParam = __library.get(b"LLVMGetNextParam\0").map(|sym| *sym);
        let LLVMGetPreviousParam = __library.get(b"LLVMGetPreviousParam\0").map(|sym| *sym);
        let LLVMSetParamAlignment = __library.get(b"LLVMSetParamAlignment\0").map(|sym| *sym);
        let LLVMAddGlobalIFunc = __library.get(b"LLVMAddGlobalIFunc\0").map(|sym| *sym);
        let LLVMGetNamedGlobalIFunc = __library.get(b"LLVMGetNamedGlobalIFunc\0").map(|sym| *sym);
        let LLVMGetFirstGlobalIFunc = __library.get(b"LLVMGetFirstGlobalIFunc\0").map(|sym| *sym);
        let LLVMGetLastGlobalIFunc = __library.get(b"LLVMGetLastGlobalIFunc\0").map(|sym| *sym);
        let LLVMGetNextGlobalIFunc = __library.get(b"LLVMGetNextGlobalIFunc\0").map(|sym| *sym);
        let LLVMGetPreviousGlobalIFunc = __library
            .get(b"LLVMGetPreviousGlobalIFunc\0")
            .map(|sym| *sym);
        let LLVMGetGlobalIFuncResolver = __library
            .get(b"LLVMGetGlobalIFuncResolver\0")
            .map(|sym| *sym);
        let LLVMSetGlobalIFuncResolver = __library
            .get(b"LLVMSetGlobalIFuncResolver\0")
            .map(|sym| *sym);
        let LLVMEraseGlobalIFunc = __library.get(b"LLVMEraseGlobalIFunc\0").map(|sym| *sym);
        let LLVMRemoveGlobalIFunc = __library.get(b"LLVMRemoveGlobalIFunc\0").map(|sym| *sym);
        let LLVMMDStringInContext2 = __library.get(b"LLVMMDStringInContext2\0").map(|sym| *sym);
        let LLVMMDNodeInContext2 = __library.get(b"LLVMMDNodeInContext2\0").map(|sym| *sym);
        let LLVMMetadataAsValue = __library.get(b"LLVMMetadataAsValue\0").map(|sym| *sym);
        let LLVMValueAsMetadata = __library.get(b"LLVMValueAsMetadata\0").map(|sym| *sym);
        let LLVMGetMDString = __library.get(b"LLVMGetMDString\0").map(|sym| *sym);
        let LLVMGetMDNodeNumOperands = __library.get(b"LLVMGetMDNodeNumOperands\0").map(|sym| *sym);
        let LLVMGetMDNodeOperands = __library.get(b"LLVMGetMDNodeOperands\0").map(|sym| *sym);
        let LLVMReplaceMDNodeOperandWith = __library
            .get(b"LLVMReplaceMDNodeOperandWith\0")
            .map(|sym| *sym);
        let LLVMMDStringInContext = __library.get(b"LLVMMDStringInContext\0").map(|sym| *sym);
        let LLVMMDString = __library.get(b"LLVMMDString\0").map(|sym| *sym);
        let LLVMMDNodeInContext = __library.get(b"LLVMMDNodeInContext\0").map(|sym| *sym);
        let LLVMMDNode = __library.get(b"LLVMMDNode\0").map(|sym| *sym);
        let LLVMBasicBlockAsValue = __library.get(b"LLVMBasicBlockAsValue\0").map(|sym| *sym);
        let LLVMValueIsBasicBlock = __library.get(b"LLVMValueIsBasicBlock\0").map(|sym| *sym);
        let LLVMValueAsBasicBlock = __library.get(b"LLVMValueAsBasicBlock\0").map(|sym| *sym);
        let LLVMGetBasicBlockName = __library.get(b"LLVMGetBasicBlockName\0").map(|sym| *sym);
        let LLVMGetBasicBlockParent = __library.get(b"LLVMGetBasicBlockParent\0").map(|sym| *sym);
        let LLVMGetBasicBlockTerminator = __library
            .get(b"LLVMGetBasicBlockTerminator\0")
            .map(|sym| *sym);
        let LLVMCountBasicBlocks = __library.get(b"LLVMCountBasicBlocks\0").map(|sym| *sym);
        let LLVMGetBasicBlocks = __library.get(b"LLVMGetBasicBlocks\0").map(|sym| *sym);
        let LLVMGetFirstBasicBlock = __library.get(b"LLVMGetFirstBasicBlock\0").map(|sym| *sym);
        let LLVMGetLastBasicBlock = __library.get(b"LLVMGetLastBasicBlock\0").map(|sym| *sym);
        let LLVMGetNextBasicBlock = __library.get(b"LLVMGetNextBasicBlock\0").map(|sym| *sym);
        let LLVMGetPreviousBasicBlock = __library
            .get(b"LLVMGetPreviousBasicBlock\0")
            .map(|sym| *sym);
        let LLVMGetEntryBasicBlock = __library.get(b"LLVMGetEntryBasicBlock\0").map(|sym| *sym);
        let LLVMInsertExistingBasicBlockAfterInsertBlock = __library
            .get(b"LLVMInsertExistingBasicBlockAfterInsertBlock\0")
            .map(|sym| *sym);
        let LLVMAppendExistingBasicBlock = __library
            .get(b"LLVMAppendExistingBasicBlock\0")
            .map(|sym| *sym);
        let LLVMCreateBasicBlockInContext = __library
            .get(b"LLVMCreateBasicBlockInContext\0")
            .map(|sym| *sym);
        let LLVMAppendBasicBlockInContext = __library
            .get(b"LLVMAppendBasicBlockInContext\0")
            .map(|sym| *sym);
        let LLVMAppendBasicBlock = __library.get(b"LLVMAppendBasicBlock\0").map(|sym| *sym);
        let LLVMInsertBasicBlockInContext = __library
            .get(b"LLVMInsertBasicBlockInContext\0")
            .map(|sym| *sym);
        let LLVMInsertBasicBlock = __library.get(b"LLVMInsertBasicBlock\0").map(|sym| *sym);
        let LLVMDeleteBasicBlock = __library.get(b"LLVMDeleteBasicBlock\0").map(|sym| *sym);
        let LLVMRemoveBasicBlockFromParent = __library
            .get(b"LLVMRemoveBasicBlockFromParent\0")
            .map(|sym| *sym);
        let LLVMMoveBasicBlockBefore = __library.get(b"LLVMMoveBasicBlockBefore\0").map(|sym| *sym);
        let LLVMMoveBasicBlockAfter = __library.get(b"LLVMMoveBasicBlockAfter\0").map(|sym| *sym);
        let LLVMGetFirstInstruction = __library.get(b"LLVMGetFirstInstruction\0").map(|sym| *sym);
        let LLVMGetLastInstruction = __library.get(b"LLVMGetLastInstruction\0").map(|sym| *sym);
        let LLVMHasMetadata = __library.get(b"LLVMHasMetadata\0").map(|sym| *sym);
        let LLVMGetMetadata = __library.get(b"LLVMGetMetadata\0").map(|sym| *sym);
        let LLVMSetMetadata = __library.get(b"LLVMSetMetadata\0").map(|sym| *sym);
        let LLVMInstructionGetAllMetadataOtherThanDebugLoc = __library
            .get(b"LLVMInstructionGetAllMetadataOtherThanDebugLoc\0")
            .map(|sym| *sym);
        let LLVMGetInstructionParent = __library.get(b"LLVMGetInstructionParent\0").map(|sym| *sym);
        let LLVMGetNextInstruction = __library.get(b"LLVMGetNextInstruction\0").map(|sym| *sym);
        let LLVMGetPreviousInstruction = __library
            .get(b"LLVMGetPreviousInstruction\0")
            .map(|sym| *sym);
        let LLVMInstructionRemoveFromParent = __library
            .get(b"LLVMInstructionRemoveFromParent\0")
            .map(|sym| *sym);
        let LLVMInstructionEraseFromParent = __library
            .get(b"LLVMInstructionEraseFromParent\0")
            .map(|sym| *sym);
        let LLVMDeleteInstruction = __library.get(b"LLVMDeleteInstruction\0").map(|sym| *sym);
        let LLVMGetInstructionOpcode = __library.get(b"LLVMGetInstructionOpcode\0").map(|sym| *sym);
        let LLVMGetICmpPredicate = __library.get(b"LLVMGetICmpPredicate\0").map(|sym| *sym);
        let LLVMGetFCmpPredicate = __library.get(b"LLVMGetFCmpPredicate\0").map(|sym| *sym);
        let LLVMInstructionClone = __library.get(b"LLVMInstructionClone\0").map(|sym| *sym);
        let LLVMIsATerminatorInst = __library.get(b"LLVMIsATerminatorInst\0").map(|sym| *sym);
        let LLVMGetNumArgOperands = __library.get(b"LLVMGetNumArgOperands\0").map(|sym| *sym);
        let LLVMSetInstructionCallConv = __library
            .get(b"LLVMSetInstructionCallConv\0")
            .map(|sym| *sym);
        let LLVMGetInstructionCallConv = __library
            .get(b"LLVMGetInstructionCallConv\0")
            .map(|sym| *sym);
        let LLVMSetInstrParamAlignment = __library
            .get(b"LLVMSetInstrParamAlignment\0")
            .map(|sym| *sym);
        let LLVMAddCallSiteAttribute = __library.get(b"LLVMAddCallSiteAttribute\0").map(|sym| *sym);
        let LLVMGetCallSiteAttributeCount = __library
            .get(b"LLVMGetCallSiteAttributeCount\0")
            .map(|sym| *sym);
        let LLVMGetCallSiteAttributes = __library
            .get(b"LLVMGetCallSiteAttributes\0")
            .map(|sym| *sym);
        let LLVMGetCallSiteEnumAttribute = __library
            .get(b"LLVMGetCallSiteEnumAttribute\0")
            .map(|sym| *sym);
        let LLVMGetCallSiteStringAttribute = __library
            .get(b"LLVMGetCallSiteStringAttribute\0")
            .map(|sym| *sym);
        let LLVMRemoveCallSiteEnumAttribute = __library
            .get(b"LLVMRemoveCallSiteEnumAttribute\0")
            .map(|sym| *sym);
        let LLVMRemoveCallSiteStringAttribute = __library
            .get(b"LLVMRemoveCallSiteStringAttribute\0")
            .map(|sym| *sym);
        let LLVMGetCalledFunctionType = __library
            .get(b"LLVMGetCalledFunctionType\0")
            .map(|sym| *sym);
        let LLVMGetCalledValue = __library.get(b"LLVMGetCalledValue\0").map(|sym| *sym);
        let LLVMIsTailCall = __library.get(b"LLVMIsTailCall\0").map(|sym| *sym);
        let LLVMSetTailCall = __library.get(b"LLVMSetTailCall\0").map(|sym| *sym);
        let LLVMGetNormalDest = __library.get(b"LLVMGetNormalDest\0").map(|sym| *sym);
        let LLVMGetUnwindDest = __library.get(b"LLVMGetUnwindDest\0").map(|sym| *sym);
        let LLVMSetNormalDest = __library.get(b"LLVMSetNormalDest\0").map(|sym| *sym);
        let LLVMSetUnwindDest = __library.get(b"LLVMSetUnwindDest\0").map(|sym| *sym);
        let LLVMGetNumSuccessors = __library.get(b"LLVMGetNumSuccessors\0").map(|sym| *sym);
        let LLVMGetSuccessor = __library.get(b"LLVMGetSuccessor\0").map(|sym| *sym);
        let LLVMSetSuccessor = __library.get(b"LLVMSetSuccessor\0").map(|sym| *sym);
        let LLVMIsConditional = __library.get(b"LLVMIsConditional\0").map(|sym| *sym);
        let LLVMGetCondition = __library.get(b"LLVMGetCondition\0").map(|sym| *sym);
        let LLVMSetCondition = __library.get(b"LLVMSetCondition\0").map(|sym| *sym);
        let LLVMGetSwitchDefaultDest = __library.get(b"LLVMGetSwitchDefaultDest\0").map(|sym| *sym);
        let LLVMGetAllocatedType = __library.get(b"LLVMGetAllocatedType\0").map(|sym| *sym);
        let LLVMIsInBounds = __library.get(b"LLVMIsInBounds\0").map(|sym| *sym);
        let LLVMSetIsInBounds = __library.get(b"LLVMSetIsInBounds\0").map(|sym| *sym);
        let LLVMGetGEPSourceElementType = __library
            .get(b"LLVMGetGEPSourceElementType\0")
            .map(|sym| *sym);
        let LLVMAddIncoming = __library.get(b"LLVMAddIncoming\0").map(|sym| *sym);
        let LLVMCountIncoming = __library.get(b"LLVMCountIncoming\0").map(|sym| *sym);
        let LLVMGetIncomingValue = __library.get(b"LLVMGetIncomingValue\0").map(|sym| *sym);
        let LLVMGetIncomingBlock = __library.get(b"LLVMGetIncomingBlock\0").map(|sym| *sym);
        let LLVMGetNumIndices = __library.get(b"LLVMGetNumIndices\0").map(|sym| *sym);
        let LLVMGetIndices = __library.get(b"LLVMGetIndices\0").map(|sym| *sym);
        let LLVMCreateBuilderInContext = __library
            .get(b"LLVMCreateBuilderInContext\0")
            .map(|sym| *sym);
        let LLVMCreateBuilder = __library.get(b"LLVMCreateBuilder\0").map(|sym| *sym);
        let LLVMPositionBuilder = __library.get(b"LLVMPositionBuilder\0").map(|sym| *sym);
        let LLVMPositionBuilderBefore = __library
            .get(b"LLVMPositionBuilderBefore\0")
            .map(|sym| *sym);
        let LLVMPositionBuilderAtEnd = __library.get(b"LLVMPositionBuilderAtEnd\0").map(|sym| *sym);
        let LLVMGetInsertBlock = __library.get(b"LLVMGetInsertBlock\0").map(|sym| *sym);
        let LLVMClearInsertionPosition = __library
            .get(b"LLVMClearInsertionPosition\0")
            .map(|sym| *sym);
        let LLVMInsertIntoBuilder = __library.get(b"LLVMInsertIntoBuilder\0").map(|sym| *sym);
        let LLVMInsertIntoBuilderWithName = __library
            .get(b"LLVMInsertIntoBuilderWithName\0")
            .map(|sym| *sym);
        let LLVMDisposeBuilder = __library.get(b"LLVMDisposeBuilder\0").map(|sym| *sym);
        let LLVMGetCurrentDebugLocation2 = __library
            .get(b"LLVMGetCurrentDebugLocation2\0")
            .map(|sym| *sym);
        let LLVMSetCurrentDebugLocation2 = __library
            .get(b"LLVMSetCurrentDebugLocation2\0")
            .map(|sym| *sym);
        let LLVMSetInstDebugLocation = __library.get(b"LLVMSetInstDebugLocation\0").map(|sym| *sym);
        let LLVMAddMetadataToInst = __library.get(b"LLVMAddMetadataToInst\0").map(|sym| *sym);
        let LLVMBuilderGetDefaultFPMathTag = __library
            .get(b"LLVMBuilderGetDefaultFPMathTag\0")
            .map(|sym| *sym);
        let LLVMBuilderSetDefaultFPMathTag = __library
            .get(b"LLVMBuilderSetDefaultFPMathTag\0")
            .map(|sym| *sym);
        let LLVMSetCurrentDebugLocation = __library
            .get(b"LLVMSetCurrentDebugLocation\0")
            .map(|sym| *sym);
        let LLVMGetCurrentDebugLocation = __library
            .get(b"LLVMGetCurrentDebugLocation\0")
            .map(|sym| *sym);
        let LLVMBuildRetVoid = __library.get(b"LLVMBuildRetVoid\0").map(|sym| *sym);
        let LLVMBuildRet = __library.get(b"LLVMBuildRet\0").map(|sym| *sym);
        let LLVMBuildAggregateRet = __library.get(b"LLVMBuildAggregateRet\0").map(|sym| *sym);
        let LLVMBuildBr = __library.get(b"LLVMBuildBr\0").map(|sym| *sym);
        let LLVMBuildCondBr = __library.get(b"LLVMBuildCondBr\0").map(|sym| *sym);
        let LLVMBuildSwitch = __library.get(b"LLVMBuildSwitch\0").map(|sym| *sym);
        let LLVMBuildIndirectBr = __library.get(b"LLVMBuildIndirectBr\0").map(|sym| *sym);
        let LLVMBuildInvoke2 = __library.get(b"LLVMBuildInvoke2\0").map(|sym| *sym);
        let LLVMBuildUnreachable = __library.get(b"LLVMBuildUnreachable\0").map(|sym| *sym);
        let LLVMBuildResume = __library.get(b"LLVMBuildResume\0").map(|sym| *sym);
        let LLVMBuildLandingPad = __library.get(b"LLVMBuildLandingPad\0").map(|sym| *sym);
        let LLVMBuildCleanupRet = __library.get(b"LLVMBuildCleanupRet\0").map(|sym| *sym);
        let LLVMBuildCatchRet = __library.get(b"LLVMBuildCatchRet\0").map(|sym| *sym);
        let LLVMBuildCatchPad = __library.get(b"LLVMBuildCatchPad\0").map(|sym| *sym);
        let LLVMBuildCleanupPad = __library.get(b"LLVMBuildCleanupPad\0").map(|sym| *sym);
        let LLVMBuildCatchSwitch = __library.get(b"LLVMBuildCatchSwitch\0").map(|sym| *sym);
        let LLVMAddCase = __library.get(b"LLVMAddCase\0").map(|sym| *sym);
        let LLVMAddDestination = __library.get(b"LLVMAddDestination\0").map(|sym| *sym);
        let LLVMGetNumClauses = __library.get(b"LLVMGetNumClauses\0").map(|sym| *sym);
        let LLVMGetClause = __library.get(b"LLVMGetClause\0").map(|sym| *sym);
        let LLVMAddClause = __library.get(b"LLVMAddClause\0").map(|sym| *sym);
        let LLVMIsCleanup = __library.get(b"LLVMIsCleanup\0").map(|sym| *sym);
        let LLVMSetCleanup = __library.get(b"LLVMSetCleanup\0").map(|sym| *sym);
        let LLVMAddHandler = __library.get(b"LLVMAddHandler\0").map(|sym| *sym);
        let LLVMGetNumHandlers = __library.get(b"LLVMGetNumHandlers\0").map(|sym| *sym);
        let LLVMGetHandlers = __library.get(b"LLVMGetHandlers\0").map(|sym| *sym);
        let LLVMGetArgOperand = __library.get(b"LLVMGetArgOperand\0").map(|sym| *sym);
        let LLVMSetArgOperand = __library.get(b"LLVMSetArgOperand\0").map(|sym| *sym);
        let LLVMGetParentCatchSwitch = __library.get(b"LLVMGetParentCatchSwitch\0").map(|sym| *sym);
        let LLVMSetParentCatchSwitch = __library.get(b"LLVMSetParentCatchSwitch\0").map(|sym| *sym);
        let LLVMBuildAdd = __library.get(b"LLVMBuildAdd\0").map(|sym| *sym);
        let LLVMBuildNSWAdd = __library.get(b"LLVMBuildNSWAdd\0").map(|sym| *sym);
        let LLVMBuildNUWAdd = __library.get(b"LLVMBuildNUWAdd\0").map(|sym| *sym);
        let LLVMBuildFAdd = __library.get(b"LLVMBuildFAdd\0").map(|sym| *sym);
        let LLVMBuildSub = __library.get(b"LLVMBuildSub\0").map(|sym| *sym);
        let LLVMBuildNSWSub = __library.get(b"LLVMBuildNSWSub\0").map(|sym| *sym);
        let LLVMBuildNUWSub = __library.get(b"LLVMBuildNUWSub\0").map(|sym| *sym);
        let LLVMBuildFSub = __library.get(b"LLVMBuildFSub\0").map(|sym| *sym);
        let LLVMBuildMul = __library.get(b"LLVMBuildMul\0").map(|sym| *sym);
        let LLVMBuildNSWMul = __library.get(b"LLVMBuildNSWMul\0").map(|sym| *sym);
        let LLVMBuildNUWMul = __library.get(b"LLVMBuildNUWMul\0").map(|sym| *sym);
        let LLVMBuildFMul = __library.get(b"LLVMBuildFMul\0").map(|sym| *sym);
        let LLVMBuildUDiv = __library.get(b"LLVMBuildUDiv\0").map(|sym| *sym);
        let LLVMBuildExactUDiv = __library.get(b"LLVMBuildExactUDiv\0").map(|sym| *sym);
        let LLVMBuildSDiv = __library.get(b"LLVMBuildSDiv\0").map(|sym| *sym);
        let LLVMBuildExactSDiv = __library.get(b"LLVMBuildExactSDiv\0").map(|sym| *sym);
        let LLVMBuildFDiv = __library.get(b"LLVMBuildFDiv\0").map(|sym| *sym);
        let LLVMBuildURem = __library.get(b"LLVMBuildURem\0").map(|sym| *sym);
        let LLVMBuildSRem = __library.get(b"LLVMBuildSRem\0").map(|sym| *sym);
        let LLVMBuildFRem = __library.get(b"LLVMBuildFRem\0").map(|sym| *sym);
        let LLVMBuildShl = __library.get(b"LLVMBuildShl\0").map(|sym| *sym);
        let LLVMBuildLShr = __library.get(b"LLVMBuildLShr\0").map(|sym| *sym);
        let LLVMBuildAShr = __library.get(b"LLVMBuildAShr\0").map(|sym| *sym);
        let LLVMBuildAnd = __library.get(b"LLVMBuildAnd\0").map(|sym| *sym);
        let LLVMBuildOr = __library.get(b"LLVMBuildOr\0").map(|sym| *sym);
        let LLVMBuildXor = __library.get(b"LLVMBuildXor\0").map(|sym| *sym);
        let LLVMBuildBinOp = __library.get(b"LLVMBuildBinOp\0").map(|sym| *sym);
        let LLVMBuildNeg = __library.get(b"LLVMBuildNeg\0").map(|sym| *sym);
        let LLVMBuildNSWNeg = __library.get(b"LLVMBuildNSWNeg\0").map(|sym| *sym);
        let LLVMBuildNUWNeg = __library.get(b"LLVMBuildNUWNeg\0").map(|sym| *sym);
        let LLVMBuildFNeg = __library.get(b"LLVMBuildFNeg\0").map(|sym| *sym);
        let LLVMBuildNot = __library.get(b"LLVMBuildNot\0").map(|sym| *sym);
        let LLVMGetNUW = __library.get(b"LLVMGetNUW\0").map(|sym| *sym);
        let LLVMSetNUW = __library.get(b"LLVMSetNUW\0").map(|sym| *sym);
        let LLVMGetNSW = __library.get(b"LLVMGetNSW\0").map(|sym| *sym);
        let LLVMSetNSW = __library.get(b"LLVMSetNSW\0").map(|sym| *sym);
        let LLVMGetExact = __library.get(b"LLVMGetExact\0").map(|sym| *sym);
        let LLVMSetExact = __library.get(b"LLVMSetExact\0").map(|sym| *sym);
        let LLVMBuildMalloc = __library.get(b"LLVMBuildMalloc\0").map(|sym| *sym);
        let LLVMBuildArrayMalloc = __library.get(b"LLVMBuildArrayMalloc\0").map(|sym| *sym);
        let LLVMBuildMemSet = __library.get(b"LLVMBuildMemSet\0").map(|sym| *sym);
        let LLVMBuildMemCpy = __library.get(b"LLVMBuildMemCpy\0").map(|sym| *sym);
        let LLVMBuildMemMove = __library.get(b"LLVMBuildMemMove\0").map(|sym| *sym);
        let LLVMBuildAlloca = __library.get(b"LLVMBuildAlloca\0").map(|sym| *sym);
        let LLVMBuildArrayAlloca = __library.get(b"LLVMBuildArrayAlloca\0").map(|sym| *sym);
        let LLVMBuildFree = __library.get(b"LLVMBuildFree\0").map(|sym| *sym);
        let LLVMBuildLoad2 = __library.get(b"LLVMBuildLoad2\0").map(|sym| *sym);
        let LLVMBuildStore = __library.get(b"LLVMBuildStore\0").map(|sym| *sym);
        let LLVMBuildGEP2 = __library.get(b"LLVMBuildGEP2\0").map(|sym| *sym);
        let LLVMBuildInBoundsGEP2 = __library.get(b"LLVMBuildInBoundsGEP2\0").map(|sym| *sym);
        let LLVMBuildStructGEP2 = __library.get(b"LLVMBuildStructGEP2\0").map(|sym| *sym);
        let LLVMBuildGlobalString = __library.get(b"LLVMBuildGlobalString\0").map(|sym| *sym);
        let LLVMBuildGlobalStringPtr = __library.get(b"LLVMBuildGlobalStringPtr\0").map(|sym| *sym);
        let LLVMGetVolatile = __library.get(b"LLVMGetVolatile\0").map(|sym| *sym);
        let LLVMSetVolatile = __library.get(b"LLVMSetVolatile\0").map(|sym| *sym);
        let LLVMGetWeak = __library.get(b"LLVMGetWeak\0").map(|sym| *sym);
        let LLVMSetWeak = __library.get(b"LLVMSetWeak\0").map(|sym| *sym);
        let LLVMGetOrdering = __library.get(b"LLVMGetOrdering\0").map(|sym| *sym);
        let LLVMSetOrdering = __library.get(b"LLVMSetOrdering\0").map(|sym| *sym);
        let LLVMGetAtomicRMWBinOp = __library.get(b"LLVMGetAtomicRMWBinOp\0").map(|sym| *sym);
        let LLVMSetAtomicRMWBinOp = __library.get(b"LLVMSetAtomicRMWBinOp\0").map(|sym| *sym);
        let LLVMBuildTrunc = __library.get(b"LLVMBuildTrunc\0").map(|sym| *sym);
        let LLVMBuildZExt = __library.get(b"LLVMBuildZExt\0").map(|sym| *sym);
        let LLVMBuildSExt = __library.get(b"LLVMBuildSExt\0").map(|sym| *sym);
        let LLVMBuildFPToUI = __library.get(b"LLVMBuildFPToUI\0").map(|sym| *sym);
        let LLVMBuildFPToSI = __library.get(b"LLVMBuildFPToSI\0").map(|sym| *sym);
        let LLVMBuildUIToFP = __library.get(b"LLVMBuildUIToFP\0").map(|sym| *sym);
        let LLVMBuildSIToFP = __library.get(b"LLVMBuildSIToFP\0").map(|sym| *sym);
        let LLVMBuildFPTrunc = __library.get(b"LLVMBuildFPTrunc\0").map(|sym| *sym);
        let LLVMBuildFPExt = __library.get(b"LLVMBuildFPExt\0").map(|sym| *sym);
        let LLVMBuildPtrToInt = __library.get(b"LLVMBuildPtrToInt\0").map(|sym| *sym);
        let LLVMBuildIntToPtr = __library.get(b"LLVMBuildIntToPtr\0").map(|sym| *sym);
        let LLVMBuildBitCast = __library.get(b"LLVMBuildBitCast\0").map(|sym| *sym);
        let LLVMBuildAddrSpaceCast = __library.get(b"LLVMBuildAddrSpaceCast\0").map(|sym| *sym);
        let LLVMBuildZExtOrBitCast = __library.get(b"LLVMBuildZExtOrBitCast\0").map(|sym| *sym);
        let LLVMBuildSExtOrBitCast = __library.get(b"LLVMBuildSExtOrBitCast\0").map(|sym| *sym);
        let LLVMBuildTruncOrBitCast = __library.get(b"LLVMBuildTruncOrBitCast\0").map(|sym| *sym);
        let LLVMBuildCast = __library.get(b"LLVMBuildCast\0").map(|sym| *sym);
        let LLVMBuildPointerCast = __library.get(b"LLVMBuildPointerCast\0").map(|sym| *sym);
        let LLVMBuildIntCast2 = __library.get(b"LLVMBuildIntCast2\0").map(|sym| *sym);
        let LLVMBuildFPCast = __library.get(b"LLVMBuildFPCast\0").map(|sym| *sym);
        let LLVMBuildIntCast = __library.get(b"LLVMBuildIntCast\0").map(|sym| *sym);
        let LLVMGetCastOpcode = __library.get(b"LLVMGetCastOpcode\0").map(|sym| *sym);
        let LLVMBuildICmp = __library.get(b"LLVMBuildICmp\0").map(|sym| *sym);
        let LLVMBuildFCmp = __library.get(b"LLVMBuildFCmp\0").map(|sym| *sym);
        let LLVMBuildPhi = __library.get(b"LLVMBuildPhi\0").map(|sym| *sym);
        let LLVMBuildCall2 = __library.get(b"LLVMBuildCall2\0").map(|sym| *sym);
        let LLVMBuildSelect = __library.get(b"LLVMBuildSelect\0").map(|sym| *sym);
        let LLVMBuildVAArg = __library.get(b"LLVMBuildVAArg\0").map(|sym| *sym);
        let LLVMBuildExtractElement = __library.get(b"LLVMBuildExtractElement\0").map(|sym| *sym);
        let LLVMBuildInsertElement = __library.get(b"LLVMBuildInsertElement\0").map(|sym| *sym);
        let LLVMBuildShuffleVector = __library.get(b"LLVMBuildShuffleVector\0").map(|sym| *sym);
        let LLVMBuildExtractValue = __library.get(b"LLVMBuildExtractValue\0").map(|sym| *sym);
        let LLVMBuildInsertValue = __library.get(b"LLVMBuildInsertValue\0").map(|sym| *sym);
        let LLVMBuildFreeze = __library.get(b"LLVMBuildFreeze\0").map(|sym| *sym);
        let LLVMBuildIsNull = __library.get(b"LLVMBuildIsNull\0").map(|sym| *sym);
        let LLVMBuildIsNotNull = __library.get(b"LLVMBuildIsNotNull\0").map(|sym| *sym);
        let LLVMBuildPtrDiff2 = __library.get(b"LLVMBuildPtrDiff2\0").map(|sym| *sym);
        let LLVMBuildFence = __library.get(b"LLVMBuildFence\0").map(|sym| *sym);
        let LLVMBuildAtomicRMW = __library.get(b"LLVMBuildAtomicRMW\0").map(|sym| *sym);
        let LLVMBuildAtomicCmpXchg = __library.get(b"LLVMBuildAtomicCmpXchg\0").map(|sym| *sym);
        let LLVMGetNumMaskElements = __library.get(b"LLVMGetNumMaskElements\0").map(|sym| *sym);
        let LLVMGetUndefMaskElem = __library.get(b"LLVMGetUndefMaskElem\0").map(|sym| *sym);
        let LLVMGetMaskValue = __library.get(b"LLVMGetMaskValue\0").map(|sym| *sym);
        let LLVMIsAtomicSingleThread = __library.get(b"LLVMIsAtomicSingleThread\0").map(|sym| *sym);
        let LLVMSetAtomicSingleThread = __library
            .get(b"LLVMSetAtomicSingleThread\0")
            .map(|sym| *sym);
        let LLVMGetCmpXchgSuccessOrdering = __library
            .get(b"LLVMGetCmpXchgSuccessOrdering\0")
            .map(|sym| *sym);
        let LLVMSetCmpXchgSuccessOrdering = __library
            .get(b"LLVMSetCmpXchgSuccessOrdering\0")
            .map(|sym| *sym);
        let LLVMGetCmpXchgFailureOrdering = __library
            .get(b"LLVMGetCmpXchgFailureOrdering\0")
            .map(|sym| *sym);
        let LLVMSetCmpXchgFailureOrdering = __library
            .get(b"LLVMSetCmpXchgFailureOrdering\0")
            .map(|sym| *sym);
        let LLVMCreateModuleProviderForExistingModule = __library
            .get(b"LLVMCreateModuleProviderForExistingModule\0")
            .map(|sym| *sym);
        let LLVMDisposeModuleProvider = __library
            .get(b"LLVMDisposeModuleProvider\0")
            .map(|sym| *sym);
        let LLVMCreateMemoryBufferWithContentsOfFile = __library
            .get(b"LLVMCreateMemoryBufferWithContentsOfFile\0")
            .map(|sym| *sym);
        let LLVMCreateMemoryBufferWithSTDIN = __library
            .get(b"LLVMCreateMemoryBufferWithSTDIN\0")
            .map(|sym| *sym);
        let LLVMCreateMemoryBufferWithMemoryRange = __library
            .get(b"LLVMCreateMemoryBufferWithMemoryRange\0")
            .map(|sym| *sym);
        let LLVMCreateMemoryBufferWithMemoryRangeCopy = __library
            .get(b"LLVMCreateMemoryBufferWithMemoryRangeCopy\0")
            .map(|sym| *sym);
        let LLVMGetBufferStart = __library.get(b"LLVMGetBufferStart\0").map(|sym| *sym);
        let LLVMGetBufferSize = __library.get(b"LLVMGetBufferSize\0").map(|sym| *sym);
        let LLVMDisposeMemoryBuffer = __library.get(b"LLVMDisposeMemoryBuffer\0").map(|sym| *sym);
        let LLVMCreatePassManager = __library.get(b"LLVMCreatePassManager\0").map(|sym| *sym);
        let LLVMCreateFunctionPassManagerForModule = __library
            .get(b"LLVMCreateFunctionPassManagerForModule\0")
            .map(|sym| *sym);
        let LLVMCreateFunctionPassManager = __library
            .get(b"LLVMCreateFunctionPassManager\0")
            .map(|sym| *sym);
        let LLVMRunPassManager = __library.get(b"LLVMRunPassManager\0").map(|sym| *sym);
        let LLVMInitializeFunctionPassManager = __library
            .get(b"LLVMInitializeFunctionPassManager\0")
            .map(|sym| *sym);
        let LLVMRunFunctionPassManager = __library
            .get(b"LLVMRunFunctionPassManager\0")
            .map(|sym| *sym);
        let LLVMFinalizeFunctionPassManager = __library
            .get(b"LLVMFinalizeFunctionPassManager\0")
            .map(|sym| *sym);
        let LLVMDisposePassManager = __library.get(b"LLVMDisposePassManager\0").map(|sym| *sym);
        let LLVMStartMultithreaded = __library.get(b"LLVMStartMultithreaded\0").map(|sym| *sym);
        let LLVMStopMultithreaded = __library.get(b"LLVMStopMultithreaded\0").map(|sym| *sym);
        let LLVMIsMultithreaded = __library.get(b"LLVMIsMultithreaded\0").map(|sym| *sym);
        let LLVMDebugMetadataVersion = __library.get(b"LLVMDebugMetadataVersion\0").map(|sym| *sym);
        let LLVMGetModuleDebugMetadataVersion = __library
            .get(b"LLVMGetModuleDebugMetadataVersion\0")
            .map(|sym| *sym);
        let LLVMStripModuleDebugInfo = __library.get(b"LLVMStripModuleDebugInfo\0").map(|sym| *sym);
        let LLVMCreateDIBuilderDisallowUnresolved = __library
            .get(b"LLVMCreateDIBuilderDisallowUnresolved\0")
            .map(|sym| *sym);
        let LLVMCreateDIBuilder = __library.get(b"LLVMCreateDIBuilder\0").map(|sym| *sym);
        let LLVMDisposeDIBuilder = __library.get(b"LLVMDisposeDIBuilder\0").map(|sym| *sym);
        let LLVMDIBuilderFinalize = __library.get(b"LLVMDIBuilderFinalize\0").map(|sym| *sym);
        let LLVMDIBuilderFinalizeSubprogram = __library
            .get(b"LLVMDIBuilderFinalizeSubprogram\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateCompileUnit = __library
            .get(b"LLVMDIBuilderCreateCompileUnit\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateFile = __library.get(b"LLVMDIBuilderCreateFile\0").map(|sym| *sym);
        let LLVMDIBuilderCreateModule = __library
            .get(b"LLVMDIBuilderCreateModule\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateNameSpace = __library
            .get(b"LLVMDIBuilderCreateNameSpace\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateFunction = __library
            .get(b"LLVMDIBuilderCreateFunction\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateLexicalBlock = __library
            .get(b"LLVMDIBuilderCreateLexicalBlock\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateLexicalBlockFile = __library
            .get(b"LLVMDIBuilderCreateLexicalBlockFile\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateImportedModuleFromNamespace = __library
            .get(b"LLVMDIBuilderCreateImportedModuleFromNamespace\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateImportedModuleFromAlias = __library
            .get(b"LLVMDIBuilderCreateImportedModuleFromAlias\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateImportedModuleFromModule = __library
            .get(b"LLVMDIBuilderCreateImportedModuleFromModule\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateImportedDeclaration = __library
            .get(b"LLVMDIBuilderCreateImportedDeclaration\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateDebugLocation = __library
            .get(b"LLVMDIBuilderCreateDebugLocation\0")
            .map(|sym| *sym);
        let LLVMDILocationGetLine = __library.get(b"LLVMDILocationGetLine\0").map(|sym| *sym);
        let LLVMDILocationGetColumn = __library.get(b"LLVMDILocationGetColumn\0").map(|sym| *sym);
        let LLVMDILocationGetScope = __library.get(b"LLVMDILocationGetScope\0").map(|sym| *sym);
        let LLVMDILocationGetInlinedAt = __library
            .get(b"LLVMDILocationGetInlinedAt\0")
            .map(|sym| *sym);
        let LLVMDIScopeGetFile = __library.get(b"LLVMDIScopeGetFile\0").map(|sym| *sym);
        let LLVMDIFileGetDirectory = __library.get(b"LLVMDIFileGetDirectory\0").map(|sym| *sym);
        let LLVMDIFileGetFilename = __library.get(b"LLVMDIFileGetFilename\0").map(|sym| *sym);
        let LLVMDIFileGetSource = __library.get(b"LLVMDIFileGetSource\0").map(|sym| *sym);
        let LLVMDIBuilderGetOrCreateTypeArray = __library
            .get(b"LLVMDIBuilderGetOrCreateTypeArray\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateSubroutineType = __library
            .get(b"LLVMDIBuilderCreateSubroutineType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateMacro = __library.get(b"LLVMDIBuilderCreateMacro\0").map(|sym| *sym);
        let LLVMDIBuilderCreateTempMacroFile = __library
            .get(b"LLVMDIBuilderCreateTempMacroFile\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateEnumerator = __library
            .get(b"LLVMDIBuilderCreateEnumerator\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateEnumerationType = __library
            .get(b"LLVMDIBuilderCreateEnumerationType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateUnionType = __library
            .get(b"LLVMDIBuilderCreateUnionType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateArrayType = __library
            .get(b"LLVMDIBuilderCreateArrayType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateVectorType = __library
            .get(b"LLVMDIBuilderCreateVectorType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateUnspecifiedType = __library
            .get(b"LLVMDIBuilderCreateUnspecifiedType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateBasicType = __library
            .get(b"LLVMDIBuilderCreateBasicType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreatePointerType = __library
            .get(b"LLVMDIBuilderCreatePointerType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateStructType = __library
            .get(b"LLVMDIBuilderCreateStructType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateMemberType = __library
            .get(b"LLVMDIBuilderCreateMemberType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateStaticMemberType = __library
            .get(b"LLVMDIBuilderCreateStaticMemberType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateMemberPointerType = __library
            .get(b"LLVMDIBuilderCreateMemberPointerType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateObjCIVar = __library
            .get(b"LLVMDIBuilderCreateObjCIVar\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateObjCProperty = __library
            .get(b"LLVMDIBuilderCreateObjCProperty\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateObjectPointerType = __library
            .get(b"LLVMDIBuilderCreateObjectPointerType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateQualifiedType = __library
            .get(b"LLVMDIBuilderCreateQualifiedType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateReferenceType = __library
            .get(b"LLVMDIBuilderCreateReferenceType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateNullPtrType = __library
            .get(b"LLVMDIBuilderCreateNullPtrType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateTypedef = __library
            .get(b"LLVMDIBuilderCreateTypedef\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateInheritance = __library
            .get(b"LLVMDIBuilderCreateInheritance\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateForwardDecl = __library
            .get(b"LLVMDIBuilderCreateForwardDecl\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateReplaceableCompositeType = __library
            .get(b"LLVMDIBuilderCreateReplaceableCompositeType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateBitFieldMemberType = __library
            .get(b"LLVMDIBuilderCreateBitFieldMemberType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateClassType = __library
            .get(b"LLVMDIBuilderCreateClassType\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateArtificialType = __library
            .get(b"LLVMDIBuilderCreateArtificialType\0")
            .map(|sym| *sym);
        let LLVMDITypeGetName = __library.get(b"LLVMDITypeGetName\0").map(|sym| *sym);
        let LLVMDITypeGetSizeInBits = __library.get(b"LLVMDITypeGetSizeInBits\0").map(|sym| *sym);
        let LLVMDITypeGetOffsetInBits = __library
            .get(b"LLVMDITypeGetOffsetInBits\0")
            .map(|sym| *sym);
        let LLVMDITypeGetAlignInBits = __library.get(b"LLVMDITypeGetAlignInBits\0").map(|sym| *sym);
        let LLVMDITypeGetLine = __library.get(b"LLVMDITypeGetLine\0").map(|sym| *sym);
        let LLVMDITypeGetFlags = __library.get(b"LLVMDITypeGetFlags\0").map(|sym| *sym);
        let LLVMDIBuilderGetOrCreateSubrange = __library
            .get(b"LLVMDIBuilderGetOrCreateSubrange\0")
            .map(|sym| *sym);
        let LLVMDIBuilderGetOrCreateArray = __library
            .get(b"LLVMDIBuilderGetOrCreateArray\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateExpression = __library
            .get(b"LLVMDIBuilderCreateExpression\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateConstantValueExpression = __library
            .get(b"LLVMDIBuilderCreateConstantValueExpression\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateGlobalVariableExpression = __library
            .get(b"LLVMDIBuilderCreateGlobalVariableExpression\0")
            .map(|sym| *sym);
        let LLVMGetDINodeTag = __library.get(b"LLVMGetDINodeTag\0").map(|sym| *sym);
        let LLVMDIGlobalVariableExpressionGetVariable = __library
            .get(b"LLVMDIGlobalVariableExpressionGetVariable\0")
            .map(|sym| *sym);
        let LLVMDIGlobalVariableExpressionGetExpression = __library
            .get(b"LLVMDIGlobalVariableExpressionGetExpression\0")
            .map(|sym| *sym);
        let LLVMDIVariableGetFile = __library.get(b"LLVMDIVariableGetFile\0").map(|sym| *sym);
        let LLVMDIVariableGetScope = __library.get(b"LLVMDIVariableGetScope\0").map(|sym| *sym);
        let LLVMDIVariableGetLine = __library.get(b"LLVMDIVariableGetLine\0").map(|sym| *sym);
        let LLVMTemporaryMDNode = __library.get(b"LLVMTemporaryMDNode\0").map(|sym| *sym);
        let LLVMDisposeTemporaryMDNode = __library
            .get(b"LLVMDisposeTemporaryMDNode\0")
            .map(|sym| *sym);
        let LLVMMetadataReplaceAllUsesWith = __library
            .get(b"LLVMMetadataReplaceAllUsesWith\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateTempGlobalVariableFwdDecl = __library
            .get(b"LLVMDIBuilderCreateTempGlobalVariableFwdDecl\0")
            .map(|sym| *sym);
        let LLVMDIBuilderInsertDeclareBefore = __library
            .get(b"LLVMDIBuilderInsertDeclareBefore\0")
            .map(|sym| *sym);
        let LLVMDIBuilderInsertDeclareAtEnd = __library
            .get(b"LLVMDIBuilderInsertDeclareAtEnd\0")
            .map(|sym| *sym);
        let LLVMDIBuilderInsertDbgValueBefore = __library
            .get(b"LLVMDIBuilderInsertDbgValueBefore\0")
            .map(|sym| *sym);
        let LLVMDIBuilderInsertDbgValueAtEnd = __library
            .get(b"LLVMDIBuilderInsertDbgValueAtEnd\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateAutoVariable = __library
            .get(b"LLVMDIBuilderCreateAutoVariable\0")
            .map(|sym| *sym);
        let LLVMDIBuilderCreateParameterVariable = __library
            .get(b"LLVMDIBuilderCreateParameterVariable\0")
            .map(|sym| *sym);
        let LLVMGetSubprogram = __library.get(b"LLVMGetSubprogram\0").map(|sym| *sym);
        let LLVMSetSubprogram = __library.get(b"LLVMSetSubprogram\0").map(|sym| *sym);
        let LLVMDISubprogramGetLine = __library.get(b"LLVMDISubprogramGetLine\0").map(|sym| *sym);
        let LLVMInstructionGetDebugLoc = __library
            .get(b"LLVMInstructionGetDebugLoc\0")
            .map(|sym| *sym);
        let LLVMInstructionSetDebugLoc = __library
            .get(b"LLVMInstructionSetDebugLoc\0")
            .map(|sym| *sym);
        let LLVMGetMetadataKind = __library.get(b"LLVMGetMetadataKind\0").map(|sym| *sym);
        let LLVMCreateDisasm = __library.get(b"LLVMCreateDisasm\0").map(|sym| *sym);
        let LLVMCreateDisasmCPU = __library.get(b"LLVMCreateDisasmCPU\0").map(|sym| *sym);
        let LLVMCreateDisasmCPUFeatures = __library
            .get(b"LLVMCreateDisasmCPUFeatures\0")
            .map(|sym| *sym);
        let LLVMSetDisasmOptions = __library.get(b"LLVMSetDisasmOptions\0").map(|sym| *sym);
        let LLVMDisasmDispose = __library.get(b"LLVMDisasmDispose\0").map(|sym| *sym);
        let LLVMDisasmInstruction = __library.get(b"LLVMDisasmInstruction\0").map(|sym| *sym);
        let LLVMGetErrorTypeId = __library.get(b"LLVMGetErrorTypeId\0").map(|sym| *sym);
        let LLVMConsumeError = __library.get(b"LLVMConsumeError\0").map(|sym| *sym);
        let LLVMGetErrorMessage = __library.get(b"LLVMGetErrorMessage\0").map(|sym| *sym);
        let LLVMDisposeErrorMessage = __library.get(b"LLVMDisposeErrorMessage\0").map(|sym| *sym);
        let LLVMGetStringErrorTypeId = __library.get(b"LLVMGetStringErrorTypeId\0").map(|sym| *sym);
        let LLVMCreateStringError = __library.get(b"LLVMCreateStringError\0").map(|sym| *sym);
        let LLVMInitializeAArch64TargetInfo = __library
            .get(b"LLVMInitializeAArch64TargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeAMDGPUTargetInfo = __library
            .get(b"LLVMInitializeAMDGPUTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeARMTargetInfo = __library
            .get(b"LLVMInitializeARMTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeAVRTargetInfo = __library
            .get(b"LLVMInitializeAVRTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeBPFTargetInfo = __library
            .get(b"LLVMInitializeBPFTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeHexagonTargetInfo = __library
            .get(b"LLVMInitializeHexagonTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeLanaiTargetInfo = __library
            .get(b"LLVMInitializeLanaiTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeLoongArchTargetInfo = __library
            .get(b"LLVMInitializeLoongArchTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeMipsTargetInfo = __library
            .get(b"LLVMInitializeMipsTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeMSP430TargetInfo = __library
            .get(b"LLVMInitializeMSP430TargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeNVPTXTargetInfo = __library
            .get(b"LLVMInitializeNVPTXTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializePowerPCTargetInfo = __library
            .get(b"LLVMInitializePowerPCTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeRISCVTargetInfo = __library
            .get(b"LLVMInitializeRISCVTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeSparcTargetInfo = __library
            .get(b"LLVMInitializeSparcTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeSystemZTargetInfo = __library
            .get(b"LLVMInitializeSystemZTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeVETargetInfo = __library
            .get(b"LLVMInitializeVETargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeWebAssemblyTargetInfo = __library
            .get(b"LLVMInitializeWebAssemblyTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeX86TargetInfo = __library
            .get(b"LLVMInitializeX86TargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeXCoreTargetInfo = __library
            .get(b"LLVMInitializeXCoreTargetInfo\0")
            .map(|sym| *sym);
        let LLVMInitializeAArch64Target = __library
            .get(b"LLVMInitializeAArch64Target\0")
            .map(|sym| *sym);
        let LLVMInitializeAMDGPUTarget = __library
            .get(b"LLVMInitializeAMDGPUTarget\0")
            .map(|sym| *sym);
        let LLVMInitializeARMTarget = __library.get(b"LLVMInitializeARMTarget\0").map(|sym| *sym);
        let LLVMInitializeAVRTarget = __library.get(b"LLVMInitializeAVRTarget\0").map(|sym| *sym);
        let LLVMInitializeBPFTarget = __library.get(b"LLVMInitializeBPFTarget\0").map(|sym| *sym);
        let LLVMInitializeHexagonTarget = __library
            .get(b"LLVMInitializeHexagonTarget\0")
            .map(|sym| *sym);
        let LLVMInitializeLanaiTarget = __library
            .get(b"LLVMInitializeLanaiTarget\0")
            .map(|sym| *sym);
        let LLVMInitializeLoongArchTarget = __library
            .get(b"LLVMInitializeLoongArchTarget\0")
            .map(|sym| *sym);
        let LLVMInitializeMipsTarget = __library.get(b"LLVMInitializeMipsTarget\0").map(|sym| *sym);
        let LLVMInitializeMSP430Target = __library
            .get(b"LLVMInitializeMSP430Target\0")
            .map(|sym| *sym);
        let LLVMInitializeNVPTXTarget = __library
            .get(b"LLVMInitializeNVPTXTarget\0")
            .map(|sym| *sym);
        let LLVMInitializePowerPCTarget = __library
            .get(b"LLVMInitializePowerPCTarget\0")
            .map(|sym| *sym);
        let LLVMInitializeRISCVTarget = __library
            .get(b"LLVMInitializeRISCVTarget\0")
            .map(|sym| *sym);
        let LLVMInitializeSparcTarget = __library
            .get(b"LLVMInitializeSparcTarget\0")
            .map(|sym| *sym);
        let LLVMInitializeSystemZTarget = __library
            .get(b"LLVMInitializeSystemZTarget\0")
            .map(|sym| *sym);
        let LLVMInitializeVETarget = __library.get(b"LLVMInitializeVETarget\0").map(|sym| *sym);
        let LLVMInitializeWebAssemblyTarget = __library
            .get(b"LLVMInitializeWebAssemblyTarget\0")
            .map(|sym| *sym);
        let LLVMInitializeX86Target = __library.get(b"LLVMInitializeX86Target\0").map(|sym| *sym);
        let LLVMInitializeXCoreTarget = __library
            .get(b"LLVMInitializeXCoreTarget\0")
            .map(|sym| *sym);
        let LLVMInitializeAArch64TargetMC = __library
            .get(b"LLVMInitializeAArch64TargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeAMDGPUTargetMC = __library
            .get(b"LLVMInitializeAMDGPUTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeARMTargetMC = __library
            .get(b"LLVMInitializeARMTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeAVRTargetMC = __library
            .get(b"LLVMInitializeAVRTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeBPFTargetMC = __library
            .get(b"LLVMInitializeBPFTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeHexagonTargetMC = __library
            .get(b"LLVMInitializeHexagonTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeLanaiTargetMC = __library
            .get(b"LLVMInitializeLanaiTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeLoongArchTargetMC = __library
            .get(b"LLVMInitializeLoongArchTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeMipsTargetMC = __library
            .get(b"LLVMInitializeMipsTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeMSP430TargetMC = __library
            .get(b"LLVMInitializeMSP430TargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeNVPTXTargetMC = __library
            .get(b"LLVMInitializeNVPTXTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializePowerPCTargetMC = __library
            .get(b"LLVMInitializePowerPCTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeRISCVTargetMC = __library
            .get(b"LLVMInitializeRISCVTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeSparcTargetMC = __library
            .get(b"LLVMInitializeSparcTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeSystemZTargetMC = __library
            .get(b"LLVMInitializeSystemZTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeVETargetMC = __library.get(b"LLVMInitializeVETargetMC\0").map(|sym| *sym);
        let LLVMInitializeWebAssemblyTargetMC = __library
            .get(b"LLVMInitializeWebAssemblyTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeX86TargetMC = __library
            .get(b"LLVMInitializeX86TargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeXCoreTargetMC = __library
            .get(b"LLVMInitializeXCoreTargetMC\0")
            .map(|sym| *sym);
        let LLVMInitializeAArch64AsmPrinter = __library
            .get(b"LLVMInitializeAArch64AsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeAMDGPUAsmPrinter = __library
            .get(b"LLVMInitializeAMDGPUAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeARMAsmPrinter = __library
            .get(b"LLVMInitializeARMAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeAVRAsmPrinter = __library
            .get(b"LLVMInitializeAVRAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeBPFAsmPrinter = __library
            .get(b"LLVMInitializeBPFAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeHexagonAsmPrinter = __library
            .get(b"LLVMInitializeHexagonAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeLanaiAsmPrinter = __library
            .get(b"LLVMInitializeLanaiAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeLoongArchAsmPrinter = __library
            .get(b"LLVMInitializeLoongArchAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeMipsAsmPrinter = __library
            .get(b"LLVMInitializeMipsAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeMSP430AsmPrinter = __library
            .get(b"LLVMInitializeMSP430AsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeNVPTXAsmPrinter = __library
            .get(b"LLVMInitializeNVPTXAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializePowerPCAsmPrinter = __library
            .get(b"LLVMInitializePowerPCAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeRISCVAsmPrinter = __library
            .get(b"LLVMInitializeRISCVAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeSparcAsmPrinter = __library
            .get(b"LLVMInitializeSparcAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeSystemZAsmPrinter = __library
            .get(b"LLVMInitializeSystemZAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeVEAsmPrinter = __library
            .get(b"LLVMInitializeVEAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeWebAssemblyAsmPrinter = __library
            .get(b"LLVMInitializeWebAssemblyAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeX86AsmPrinter = __library
            .get(b"LLVMInitializeX86AsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeXCoreAsmPrinter = __library
            .get(b"LLVMInitializeXCoreAsmPrinter\0")
            .map(|sym| *sym);
        let LLVMInitializeAArch64AsmParser = __library
            .get(b"LLVMInitializeAArch64AsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeAMDGPUAsmParser = __library
            .get(b"LLVMInitializeAMDGPUAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeARMAsmParser = __library
            .get(b"LLVMInitializeARMAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeAVRAsmParser = __library
            .get(b"LLVMInitializeAVRAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeBPFAsmParser = __library
            .get(b"LLVMInitializeBPFAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeHexagonAsmParser = __library
            .get(b"LLVMInitializeHexagonAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeLanaiAsmParser = __library
            .get(b"LLVMInitializeLanaiAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeLoongArchAsmParser = __library
            .get(b"LLVMInitializeLoongArchAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeMipsAsmParser = __library
            .get(b"LLVMInitializeMipsAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeMSP430AsmParser = __library
            .get(b"LLVMInitializeMSP430AsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializePowerPCAsmParser = __library
            .get(b"LLVMInitializePowerPCAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeRISCVAsmParser = __library
            .get(b"LLVMInitializeRISCVAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeSparcAsmParser = __library
            .get(b"LLVMInitializeSparcAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeSystemZAsmParser = __library
            .get(b"LLVMInitializeSystemZAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeVEAsmParser = __library
            .get(b"LLVMInitializeVEAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeWebAssemblyAsmParser = __library
            .get(b"LLVMInitializeWebAssemblyAsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeX86AsmParser = __library
            .get(b"LLVMInitializeX86AsmParser\0")
            .map(|sym| *sym);
        let LLVMInitializeAArch64Disassembler = __library
            .get(b"LLVMInitializeAArch64Disassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeAMDGPUDisassembler = __library
            .get(b"LLVMInitializeAMDGPUDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeARMDisassembler = __library
            .get(b"LLVMInitializeARMDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeAVRDisassembler = __library
            .get(b"LLVMInitializeAVRDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeBPFDisassembler = __library
            .get(b"LLVMInitializeBPFDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeHexagonDisassembler = __library
            .get(b"LLVMInitializeHexagonDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeLanaiDisassembler = __library
            .get(b"LLVMInitializeLanaiDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeLoongArchDisassembler = __library
            .get(b"LLVMInitializeLoongArchDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeMipsDisassembler = __library
            .get(b"LLVMInitializeMipsDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeMSP430Disassembler = __library
            .get(b"LLVMInitializeMSP430Disassembler\0")
            .map(|sym| *sym);
        let LLVMInitializePowerPCDisassembler = __library
            .get(b"LLVMInitializePowerPCDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeRISCVDisassembler = __library
            .get(b"LLVMInitializeRISCVDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeSparcDisassembler = __library
            .get(b"LLVMInitializeSparcDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeSystemZDisassembler = __library
            .get(b"LLVMInitializeSystemZDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeVEDisassembler = __library
            .get(b"LLVMInitializeVEDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeWebAssemblyDisassembler = __library
            .get(b"LLVMInitializeWebAssemblyDisassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeX86Disassembler = __library
            .get(b"LLVMInitializeX86Disassembler\0")
            .map(|sym| *sym);
        let LLVMInitializeXCoreDisassembler = __library
            .get(b"LLVMInitializeXCoreDisassembler\0")
            .map(|sym| *sym);
        let LLVMGetModuleDataLayout = __library.get(b"LLVMGetModuleDataLayout\0").map(|sym| *sym);
        let LLVMSetModuleDataLayout = __library.get(b"LLVMSetModuleDataLayout\0").map(|sym| *sym);
        let LLVMCreateTargetData = __library.get(b"LLVMCreateTargetData\0").map(|sym| *sym);
        let LLVMDisposeTargetData = __library.get(b"LLVMDisposeTargetData\0").map(|sym| *sym);
        let LLVMAddTargetLibraryInfo = __library.get(b"LLVMAddTargetLibraryInfo\0").map(|sym| *sym);
        let LLVMCopyStringRepOfTargetData = __library
            .get(b"LLVMCopyStringRepOfTargetData\0")
            .map(|sym| *sym);
        let LLVMByteOrder = __library.get(b"LLVMByteOrder\0").map(|sym| *sym);
        let LLVMPointerSize = __library.get(b"LLVMPointerSize\0").map(|sym| *sym);
        let LLVMPointerSizeForAS = __library.get(b"LLVMPointerSizeForAS\0").map(|sym| *sym);
        let LLVMIntPtrType = __library.get(b"LLVMIntPtrType\0").map(|sym| *sym);
        let LLVMIntPtrTypeForAS = __library.get(b"LLVMIntPtrTypeForAS\0").map(|sym| *sym);
        let LLVMIntPtrTypeInContext = __library.get(b"LLVMIntPtrTypeInContext\0").map(|sym| *sym);
        let LLVMIntPtrTypeForASInContext = __library
            .get(b"LLVMIntPtrTypeForASInContext\0")
            .map(|sym| *sym);
        let LLVMSizeOfTypeInBits = __library.get(b"LLVMSizeOfTypeInBits\0").map(|sym| *sym);
        let LLVMStoreSizeOfType = __library.get(b"LLVMStoreSizeOfType\0").map(|sym| *sym);
        let LLVMABISizeOfType = __library.get(b"LLVMABISizeOfType\0").map(|sym| *sym);
        let LLVMABIAlignmentOfType = __library.get(b"LLVMABIAlignmentOfType\0").map(|sym| *sym);
        let LLVMCallFrameAlignmentOfType = __library
            .get(b"LLVMCallFrameAlignmentOfType\0")
            .map(|sym| *sym);
        let LLVMPreferredAlignmentOfType = __library
            .get(b"LLVMPreferredAlignmentOfType\0")
            .map(|sym| *sym);
        let LLVMPreferredAlignmentOfGlobal = __library
            .get(b"LLVMPreferredAlignmentOfGlobal\0")
            .map(|sym| *sym);
        let LLVMElementAtOffset = __library.get(b"LLVMElementAtOffset\0").map(|sym| *sym);
        let LLVMOffsetOfElement = __library.get(b"LLVMOffsetOfElement\0").map(|sym| *sym);
        let LLVMGetFirstTarget = __library.get(b"LLVMGetFirstTarget\0").map(|sym| *sym);
        let LLVMGetNextTarget = __library.get(b"LLVMGetNextTarget\0").map(|sym| *sym);
        let LLVMGetTargetFromName = __library.get(b"LLVMGetTargetFromName\0").map(|sym| *sym);
        let LLVMGetTargetFromTriple = __library.get(b"LLVMGetTargetFromTriple\0").map(|sym| *sym);
        let LLVMGetTargetName = __library.get(b"LLVMGetTargetName\0").map(|sym| *sym);
        let LLVMGetTargetDescription = __library.get(b"LLVMGetTargetDescription\0").map(|sym| *sym);
        let LLVMTargetHasJIT = __library.get(b"LLVMTargetHasJIT\0").map(|sym| *sym);
        let LLVMTargetHasTargetMachine = __library
            .get(b"LLVMTargetHasTargetMachine\0")
            .map(|sym| *sym);
        let LLVMTargetHasAsmBackend = __library.get(b"LLVMTargetHasAsmBackend\0").map(|sym| *sym);
        let LLVMCreateTargetMachine = __library.get(b"LLVMCreateTargetMachine\0").map(|sym| *sym);
        let LLVMDisposeTargetMachine = __library.get(b"LLVMDisposeTargetMachine\0").map(|sym| *sym);
        let LLVMGetTargetMachineTarget = __library
            .get(b"LLVMGetTargetMachineTarget\0")
            .map(|sym| *sym);
        let LLVMGetTargetMachineTriple = __library
            .get(b"LLVMGetTargetMachineTriple\0")
            .map(|sym| *sym);
        let LLVMGetTargetMachineCPU = __library.get(b"LLVMGetTargetMachineCPU\0").map(|sym| *sym);
        let LLVMGetTargetMachineFeatureString = __library
            .get(b"LLVMGetTargetMachineFeatureString\0")
            .map(|sym| *sym);
        let LLVMCreateTargetDataLayout = __library
            .get(b"LLVMCreateTargetDataLayout\0")
            .map(|sym| *sym);
        let LLVMSetTargetMachineAsmVerbosity = __library
            .get(b"LLVMSetTargetMachineAsmVerbosity\0")
            .map(|sym| *sym);
        let LLVMTargetMachineEmitToFile = __library
            .get(b"LLVMTargetMachineEmitToFile\0")
            .map(|sym| *sym);
        let LLVMTargetMachineEmitToMemoryBuffer = __library
            .get(b"LLVMTargetMachineEmitToMemoryBuffer\0")
            .map(|sym| *sym);
        let LLVMGetDefaultTargetTriple = __library
            .get(b"LLVMGetDefaultTargetTriple\0")
            .map(|sym| *sym);
        let LLVMNormalizeTargetTriple = __library
            .get(b"LLVMNormalizeTargetTriple\0")
            .map(|sym| *sym);
        let LLVMGetHostCPUName = __library.get(b"LLVMGetHostCPUName\0").map(|sym| *sym);
        let LLVMGetHostCPUFeatures = __library.get(b"LLVMGetHostCPUFeatures\0").map(|sym| *sym);
        let LLVMAddAnalysisPasses = __library.get(b"LLVMAddAnalysisPasses\0").map(|sym| *sym);
        let LLVMLinkInMCJIT = __library.get(b"LLVMLinkInMCJIT\0").map(|sym| *sym);
        let LLVMLinkInInterpreter = __library.get(b"LLVMLinkInInterpreter\0").map(|sym| *sym);
        let LLVMCreateGenericValueOfInt = __library
            .get(b"LLVMCreateGenericValueOfInt\0")
            .map(|sym| *sym);
        let LLVMCreateGenericValueOfPointer = __library
            .get(b"LLVMCreateGenericValueOfPointer\0")
            .map(|sym| *sym);
        let LLVMCreateGenericValueOfFloat = __library
            .get(b"LLVMCreateGenericValueOfFloat\0")
            .map(|sym| *sym);
        let LLVMGenericValueIntWidth = __library.get(b"LLVMGenericValueIntWidth\0").map(|sym| *sym);
        let LLVMGenericValueToInt = __library.get(b"LLVMGenericValueToInt\0").map(|sym| *sym);
        let LLVMGenericValueToPointer = __library
            .get(b"LLVMGenericValueToPointer\0")
            .map(|sym| *sym);
        let LLVMGenericValueToFloat = __library.get(b"LLVMGenericValueToFloat\0").map(|sym| *sym);
        let LLVMDisposeGenericValue = __library.get(b"LLVMDisposeGenericValue\0").map(|sym| *sym);
        let LLVMCreateExecutionEngineForModule = __library
            .get(b"LLVMCreateExecutionEngineForModule\0")
            .map(|sym| *sym);
        let LLVMCreateInterpreterForModule = __library
            .get(b"LLVMCreateInterpreterForModule\0")
            .map(|sym| *sym);
        let LLVMCreateJITCompilerForModule = __library
            .get(b"LLVMCreateJITCompilerForModule\0")
            .map(|sym| *sym);
        let LLVMInitializeMCJITCompilerOptions = __library
            .get(b"LLVMInitializeMCJITCompilerOptions\0")
            .map(|sym| *sym);
        let LLVMCreateMCJITCompilerForModule = __library
            .get(b"LLVMCreateMCJITCompilerForModule\0")
            .map(|sym| *sym);
        let LLVMDisposeExecutionEngine = __library
            .get(b"LLVMDisposeExecutionEngine\0")
            .map(|sym| *sym);
        let LLVMRunStaticConstructors = __library
            .get(b"LLVMRunStaticConstructors\0")
            .map(|sym| *sym);
        let LLVMRunStaticDestructors = __library.get(b"LLVMRunStaticDestructors\0").map(|sym| *sym);
        let LLVMRunFunctionAsMain = __library.get(b"LLVMRunFunctionAsMain\0").map(|sym| *sym);
        let LLVMRunFunction = __library.get(b"LLVMRunFunction\0").map(|sym| *sym);
        let LLVMFreeMachineCodeForFunction = __library
            .get(b"LLVMFreeMachineCodeForFunction\0")
            .map(|sym| *sym);
        let LLVMAddModule = __library.get(b"LLVMAddModule\0").map(|sym| *sym);
        let LLVMRemoveModule = __library.get(b"LLVMRemoveModule\0").map(|sym| *sym);
        let LLVMFindFunction = __library.get(b"LLVMFindFunction\0").map(|sym| *sym);
        let LLVMRecompileAndRelinkFunction = __library
            .get(b"LLVMRecompileAndRelinkFunction\0")
            .map(|sym| *sym);
        let LLVMGetExecutionEngineTargetData = __library
            .get(b"LLVMGetExecutionEngineTargetData\0")
            .map(|sym| *sym);
        let LLVMGetExecutionEngineTargetMachine = __library
            .get(b"LLVMGetExecutionEngineTargetMachine\0")
            .map(|sym| *sym);
        let LLVMAddGlobalMapping = __library.get(b"LLVMAddGlobalMapping\0").map(|sym| *sym);
        let LLVMGetPointerToGlobal = __library.get(b"LLVMGetPointerToGlobal\0").map(|sym| *sym);
        let LLVMGetGlobalValueAddress = __library
            .get(b"LLVMGetGlobalValueAddress\0")
            .map(|sym| *sym);
        let LLVMGetFunctionAddress = __library.get(b"LLVMGetFunctionAddress\0").map(|sym| *sym);
        let LLVMExecutionEngineGetErrMsg = __library
            .get(b"LLVMExecutionEngineGetErrMsg\0")
            .map(|sym| *sym);
        let LLVMCreateSimpleMCJITMemoryManager = __library
            .get(b"LLVMCreateSimpleMCJITMemoryManager\0")
            .map(|sym| *sym);
        let LLVMDisposeMCJITMemoryManager = __library
            .get(b"LLVMDisposeMCJITMemoryManager\0")
            .map(|sym| *sym);
        let LLVMCreateGDBRegistrationListener = __library
            .get(b"LLVMCreateGDBRegistrationListener\0")
            .map(|sym| *sym);
        let LLVMCreateIntelJITEventListener = __library
            .get(b"LLVMCreateIntelJITEventListener\0")
            .map(|sym| *sym);
        let LLVMCreateOProfileJITEventListener = __library
            .get(b"LLVMCreateOProfileJITEventListener\0")
            .map(|sym| *sym);
        let LLVMCreatePerfJITEventListener = __library
            .get(b"LLVMCreatePerfJITEventListener\0")
            .map(|sym| *sym);
        let LLVMParseIRInContext = __library.get(b"LLVMParseIRInContext\0").map(|sym| *sym);
        let LLVMLinkModules2 = __library.get(b"LLVMLinkModules2\0").map(|sym| *sym);
        let LLVMOrcExecutionSessionSetErrorReporter = __library
            .get(b"LLVMOrcExecutionSessionSetErrorReporter\0")
            .map(|sym| *sym);
        let LLVMOrcExecutionSessionGetSymbolStringPool = __library
            .get(b"LLVMOrcExecutionSessionGetSymbolStringPool\0")
            .map(|sym| *sym);
        let LLVMOrcSymbolStringPoolClearDeadEntries = __library
            .get(b"LLVMOrcSymbolStringPoolClearDeadEntries\0")
            .map(|sym| *sym);
        let LLVMOrcExecutionSessionIntern = __library
            .get(b"LLVMOrcExecutionSessionIntern\0")
            .map(|sym| *sym);
        let LLVMOrcExecutionSessionLookup = __library
            .get(b"LLVMOrcExecutionSessionLookup\0")
            .map(|sym| *sym);
        let LLVMOrcRetainSymbolStringPoolEntry = __library
            .get(b"LLVMOrcRetainSymbolStringPoolEntry\0")
            .map(|sym| *sym);
        let LLVMOrcReleaseSymbolStringPoolEntry = __library
            .get(b"LLVMOrcReleaseSymbolStringPoolEntry\0")
            .map(|sym| *sym);
        let LLVMOrcSymbolStringPoolEntryStr = __library
            .get(b"LLVMOrcSymbolStringPoolEntryStr\0")
            .map(|sym| *sym);
        let LLVMOrcReleaseResourceTracker = __library
            .get(b"LLVMOrcReleaseResourceTracker\0")
            .map(|sym| *sym);
        let LLVMOrcResourceTrackerTransferTo = __library
            .get(b"LLVMOrcResourceTrackerTransferTo\0")
            .map(|sym| *sym);
        let LLVMOrcResourceTrackerRemove = __library
            .get(b"LLVMOrcResourceTrackerRemove\0")
            .map(|sym| *sym);
        let LLVMOrcDisposeDefinitionGenerator = __library
            .get(b"LLVMOrcDisposeDefinitionGenerator\0")
            .map(|sym| *sym);
        let LLVMOrcDisposeMaterializationUnit = __library
            .get(b"LLVMOrcDisposeMaterializationUnit\0")
            .map(|sym| *sym);
        let LLVMOrcCreateCustomMaterializationUnit = __library
            .get(b"LLVMOrcCreateCustomMaterializationUnit\0")
            .map(|sym| *sym);
        let LLVMOrcAbsoluteSymbols = __library.get(b"LLVMOrcAbsoluteSymbols\0").map(|sym| *sym);
        let LLVMOrcLazyReexports = __library.get(b"LLVMOrcLazyReexports\0").map(|sym| *sym);
        let LLVMOrcDisposeMaterializationResponsibility = __library
            .get(b"LLVMOrcDisposeMaterializationResponsibility\0")
            .map(|sym| *sym);
        let LLVMOrcMaterializationResponsibilityGetTargetDylib = __library
            .get(b"LLVMOrcMaterializationResponsibilityGetTargetDylib\0")
            .map(|sym| *sym);
        let LLVMOrcMaterializationResponsibilityGetExecutionSession = __library
            .get(b"LLVMOrcMaterializationResponsibilityGetExecutionSession\0")
            .map(|sym| *sym);
        let LLVMOrcMaterializationResponsibilityGetSymbols = __library
            .get(b"LLVMOrcMaterializationResponsibilityGetSymbols\0")
            .map(|sym| *sym);
        let LLVMOrcDisposeCSymbolFlagsMap = __library
            .get(b"LLVMOrcDisposeCSymbolFlagsMap\0")
            .map(|sym| *sym);
        let LLVMOrcMaterializationResponsibilityGetInitializerSymbol = __library
            .get(b"LLVMOrcMaterializationResponsibilityGetInitializerSymbol\0")
            .map(|sym| *sym);
        let LLVMOrcMaterializationResponsibilityGetRequestedSymbols = __library
            .get(b"LLVMOrcMaterializationResponsibilityGetRequestedSymbols\0")
            .map(|sym| *sym);
        let LLVMOrcDisposeSymbols = __library.get(b"LLVMOrcDisposeSymbols\0").map(|sym| *sym);
        let LLVMOrcMaterializationResponsibilityNotifyResolved = __library
            .get(b"LLVMOrcMaterializationResponsibilityNotifyResolved\0")
            .map(|sym| *sym);
        let LLVMOrcMaterializationResponsibilityNotifyEmitted = __library
            .get(b"LLVMOrcMaterializationResponsibilityNotifyEmitted\0")
            .map(|sym| *sym);
        let LLVMOrcMaterializationResponsibilityDefineMaterializing = __library
            .get(b"LLVMOrcMaterializationResponsibilityDefineMaterializing\0")
            .map(|sym| *sym);
        let LLVMOrcMaterializationResponsibilityFailMaterialization = __library
            .get(b"LLVMOrcMaterializationResponsibilityFailMaterialization\0")
            .map(|sym| *sym);
        let LLVMOrcMaterializationResponsibilityReplace = __library
            .get(b"LLVMOrcMaterializationResponsibilityReplace\0")
            .map(|sym| *sym);
        let LLVMOrcMaterializationResponsibilityDelegate = __library
            .get(b"LLVMOrcMaterializationResponsibilityDelegate\0")
            .map(|sym| *sym);
        let LLVMOrcMaterializationResponsibilityAddDependencies = __library
            .get(b"LLVMOrcMaterializationResponsibilityAddDependencies\0")
            .map(|sym| *sym);
        let LLVMOrcMaterializationResponsibilityAddDependenciesForAll = __library
            .get(b"LLVMOrcMaterializationResponsibilityAddDependenciesForAll\0")
            .map(|sym| *sym);
        let LLVMOrcExecutionSessionCreateBareJITDylib = __library
            .get(b"LLVMOrcExecutionSessionCreateBareJITDylib\0")
            .map(|sym| *sym);
        let LLVMOrcExecutionSessionCreateJITDylib = __library
            .get(b"LLVMOrcExecutionSessionCreateJITDylib\0")
            .map(|sym| *sym);
        let LLVMOrcExecutionSessionGetJITDylibByName = __library
            .get(b"LLVMOrcExecutionSessionGetJITDylibByName\0")
            .map(|sym| *sym);
        let LLVMOrcJITDylibCreateResourceTracker = __library
            .get(b"LLVMOrcJITDylibCreateResourceTracker\0")
            .map(|sym| *sym);
        let LLVMOrcJITDylibGetDefaultResourceTracker = __library
            .get(b"LLVMOrcJITDylibGetDefaultResourceTracker\0")
            .map(|sym| *sym);
        let LLVMOrcJITDylibDefine = __library.get(b"LLVMOrcJITDylibDefine\0").map(|sym| *sym);
        let LLVMOrcJITDylibClear = __library.get(b"LLVMOrcJITDylibClear\0").map(|sym| *sym);
        let LLVMOrcJITDylibAddGenerator = __library
            .get(b"LLVMOrcJITDylibAddGenerator\0")
            .map(|sym| *sym);
        let LLVMOrcCreateCustomCAPIDefinitionGenerator = __library
            .get(b"LLVMOrcCreateCustomCAPIDefinitionGenerator\0")
            .map(|sym| *sym);
        let LLVMOrcLookupStateContinueLookup = __library
            .get(b"LLVMOrcLookupStateContinueLookup\0")
            .map(|sym| *sym);
        let LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess = __library
            .get(b"LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess\0")
            .map(|sym| *sym);
        let LLVMOrcCreateDynamicLibrarySearchGeneratorForPath = __library
            .get(b"LLVMOrcCreateDynamicLibrarySearchGeneratorForPath\0")
            .map(|sym| *sym);
        let LLVMOrcCreateStaticLibrarySearchGeneratorForPath = __library
            .get(b"LLVMOrcCreateStaticLibrarySearchGeneratorForPath\0")
            .map(|sym| *sym);
        let LLVMOrcCreateNewThreadSafeContext = __library
            .get(b"LLVMOrcCreateNewThreadSafeContext\0")
            .map(|sym| *sym);
        let LLVMOrcThreadSafeContextGetContext = __library
            .get(b"LLVMOrcThreadSafeContextGetContext\0")
            .map(|sym| *sym);
        let LLVMOrcDisposeThreadSafeContext = __library
            .get(b"LLVMOrcDisposeThreadSafeContext\0")
            .map(|sym| *sym);
        let LLVMOrcCreateNewThreadSafeModule = __library
            .get(b"LLVMOrcCreateNewThreadSafeModule\0")
            .map(|sym| *sym);
        let LLVMOrcDisposeThreadSafeModule = __library
            .get(b"LLVMOrcDisposeThreadSafeModule\0")
            .map(|sym| *sym);
        let LLVMOrcThreadSafeModuleWithModuleDo = __library
            .get(b"LLVMOrcThreadSafeModuleWithModuleDo\0")
            .map(|sym| *sym);
        let LLVMOrcJITTargetMachineBuilderDetectHost = __library
            .get(b"LLVMOrcJITTargetMachineBuilderDetectHost\0")
            .map(|sym| *sym);
        let LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine = __library
            .get(b"LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine\0")
            .map(|sym| *sym);
        let LLVMOrcDisposeJITTargetMachineBuilder = __library
            .get(b"LLVMOrcDisposeJITTargetMachineBuilder\0")
            .map(|sym| *sym);
        let LLVMOrcJITTargetMachineBuilderGetTargetTriple = __library
            .get(b"LLVMOrcJITTargetMachineBuilderGetTargetTriple\0")
            .map(|sym| *sym);
        let LLVMOrcJITTargetMachineBuilderSetTargetTriple = __library
            .get(b"LLVMOrcJITTargetMachineBuilderSetTargetTriple\0")
            .map(|sym| *sym);
        let LLVMOrcObjectLayerAddObjectFile = __library
            .get(b"LLVMOrcObjectLayerAddObjectFile\0")
            .map(|sym| *sym);
        let LLVMOrcObjectLayerAddObjectFileWithRT = __library
            .get(b"LLVMOrcObjectLayerAddObjectFileWithRT\0")
            .map(|sym| *sym);
        let LLVMOrcObjectLayerEmit = __library.get(b"LLVMOrcObjectLayerEmit\0").map(|sym| *sym);
        let LLVMOrcDisposeObjectLayer = __library
            .get(b"LLVMOrcDisposeObjectLayer\0")
            .map(|sym| *sym);
        let LLVMOrcIRTransformLayerEmit = __library
            .get(b"LLVMOrcIRTransformLayerEmit\0")
            .map(|sym| *sym);
        let LLVMOrcIRTransformLayerSetTransform = __library
            .get(b"LLVMOrcIRTransformLayerSetTransform\0")
            .map(|sym| *sym);
        let LLVMOrcObjectTransformLayerSetTransform = __library
            .get(b"LLVMOrcObjectTransformLayerSetTransform\0")
            .map(|sym| *sym);
        let LLVMOrcCreateLocalIndirectStubsManager = __library
            .get(b"LLVMOrcCreateLocalIndirectStubsManager\0")
            .map(|sym| *sym);
        let LLVMOrcDisposeIndirectStubsManager = __library
            .get(b"LLVMOrcDisposeIndirectStubsManager\0")
            .map(|sym| *sym);
        let LLVMOrcCreateLocalLazyCallThroughManager = __library
            .get(b"LLVMOrcCreateLocalLazyCallThroughManager\0")
            .map(|sym| *sym);
        let LLVMOrcDisposeLazyCallThroughManager = __library
            .get(b"LLVMOrcDisposeLazyCallThroughManager\0")
            .map(|sym| *sym);
        let LLVMOrcCreateDumpObjects = __library.get(b"LLVMOrcCreateDumpObjects\0").map(|sym| *sym);
        let LLVMOrcDisposeDumpObjects = __library
            .get(b"LLVMOrcDisposeDumpObjects\0")
            .map(|sym| *sym);
        let LLVMOrcDumpObjects_CallOperator = __library
            .get(b"LLVMOrcDumpObjects_CallOperator\0")
            .map(|sym| *sym);
        let LLVMOrcCreateLLJITBuilder = __library
            .get(b"LLVMOrcCreateLLJITBuilder\0")
            .map(|sym| *sym);
        let LLVMOrcDisposeLLJITBuilder = __library
            .get(b"LLVMOrcDisposeLLJITBuilder\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITBuilderSetJITTargetMachineBuilder = __library
            .get(b"LLVMOrcLLJITBuilderSetJITTargetMachineBuilder\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITBuilderSetObjectLinkingLayerCreator = __library
            .get(b"LLVMOrcLLJITBuilderSetObjectLinkingLayerCreator\0")
            .map(|sym| *sym);
        let LLVMOrcCreateLLJIT = __library.get(b"LLVMOrcCreateLLJIT\0").map(|sym| *sym);
        let LLVMOrcDisposeLLJIT = __library.get(b"LLVMOrcDisposeLLJIT\0").map(|sym| *sym);
        let LLVMOrcLLJITGetExecutionSession = __library
            .get(b"LLVMOrcLLJITGetExecutionSession\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITGetMainJITDylib = __library
            .get(b"LLVMOrcLLJITGetMainJITDylib\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITGetTripleString = __library
            .get(b"LLVMOrcLLJITGetTripleString\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITGetGlobalPrefix = __library
            .get(b"LLVMOrcLLJITGetGlobalPrefix\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITMangleAndIntern = __library
            .get(b"LLVMOrcLLJITMangleAndIntern\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITAddObjectFile = __library
            .get(b"LLVMOrcLLJITAddObjectFile\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITAddObjectFileWithRT = __library
            .get(b"LLVMOrcLLJITAddObjectFileWithRT\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITAddLLVMIRModule = __library
            .get(b"LLVMOrcLLJITAddLLVMIRModule\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITAddLLVMIRModuleWithRT = __library
            .get(b"LLVMOrcLLJITAddLLVMIRModuleWithRT\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITLookup = __library.get(b"LLVMOrcLLJITLookup\0").map(|sym| *sym);
        let LLVMOrcLLJITGetObjLinkingLayer = __library
            .get(b"LLVMOrcLLJITGetObjLinkingLayer\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITGetObjTransformLayer = __library
            .get(b"LLVMOrcLLJITGetObjTransformLayer\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITGetIRTransformLayer = __library
            .get(b"LLVMOrcLLJITGetIRTransformLayer\0")
            .map(|sym| *sym);
        let LLVMOrcLLJITGetDataLayoutStr = __library
            .get(b"LLVMOrcLLJITGetDataLayoutStr\0")
            .map(|sym| *sym);
        let LLVMCreateBinary = __library.get(b"LLVMCreateBinary\0").map(|sym| *sym);
        let LLVMDisposeBinary = __library.get(b"LLVMDisposeBinary\0").map(|sym| *sym);
        let LLVMBinaryCopyMemoryBuffer = __library
            .get(b"LLVMBinaryCopyMemoryBuffer\0")
            .map(|sym| *sym);
        let LLVMBinaryGetType = __library.get(b"LLVMBinaryGetType\0").map(|sym| *sym);
        let LLVMMachOUniversalBinaryCopyObjectForArch = __library
            .get(b"LLVMMachOUniversalBinaryCopyObjectForArch\0")
            .map(|sym| *sym);
        let LLVMObjectFileCopySectionIterator = __library
            .get(b"LLVMObjectFileCopySectionIterator\0")
            .map(|sym| *sym);
        let LLVMObjectFileIsSectionIteratorAtEnd = __library
            .get(b"LLVMObjectFileIsSectionIteratorAtEnd\0")
            .map(|sym| *sym);
        let LLVMObjectFileCopySymbolIterator = __library
            .get(b"LLVMObjectFileCopySymbolIterator\0")
            .map(|sym| *sym);
        let LLVMObjectFileIsSymbolIteratorAtEnd = __library
            .get(b"LLVMObjectFileIsSymbolIteratorAtEnd\0")
            .map(|sym| *sym);
        let LLVMDisposeSectionIterator = __library
            .get(b"LLVMDisposeSectionIterator\0")
            .map(|sym| *sym);
        let LLVMMoveToNextSection = __library.get(b"LLVMMoveToNextSection\0").map(|sym| *sym);
        let LLVMMoveToContainingSection = __library
            .get(b"LLVMMoveToContainingSection\0")
            .map(|sym| *sym);
        let LLVMDisposeSymbolIterator = __library
            .get(b"LLVMDisposeSymbolIterator\0")
            .map(|sym| *sym);
        let LLVMMoveToNextSymbol = __library.get(b"LLVMMoveToNextSymbol\0").map(|sym| *sym);
        let LLVMGetSectionName = __library.get(b"LLVMGetSectionName\0").map(|sym| *sym);
        let LLVMGetSectionSize = __library.get(b"LLVMGetSectionSize\0").map(|sym| *sym);
        let LLVMGetSectionContents = __library.get(b"LLVMGetSectionContents\0").map(|sym| *sym);
        let LLVMGetSectionAddress = __library.get(b"LLVMGetSectionAddress\0").map(|sym| *sym);
        let LLVMGetSectionContainsSymbol = __library
            .get(b"LLVMGetSectionContainsSymbol\0")
            .map(|sym| *sym);
        let LLVMGetRelocations = __library.get(b"LLVMGetRelocations\0").map(|sym| *sym);
        let LLVMDisposeRelocationIterator = __library
            .get(b"LLVMDisposeRelocationIterator\0")
            .map(|sym| *sym);
        let LLVMIsRelocationIteratorAtEnd = __library
            .get(b"LLVMIsRelocationIteratorAtEnd\0")
            .map(|sym| *sym);
        let LLVMMoveToNextRelocation = __library.get(b"LLVMMoveToNextRelocation\0").map(|sym| *sym);
        let LLVMGetSymbolName = __library.get(b"LLVMGetSymbolName\0").map(|sym| *sym);
        let LLVMGetSymbolAddress = __library.get(b"LLVMGetSymbolAddress\0").map(|sym| *sym);
        let LLVMGetSymbolSize = __library.get(b"LLVMGetSymbolSize\0").map(|sym| *sym);
        let LLVMGetRelocationOffset = __library.get(b"LLVMGetRelocationOffset\0").map(|sym| *sym);
        let LLVMGetRelocationSymbol = __library.get(b"LLVMGetRelocationSymbol\0").map(|sym| *sym);
        let LLVMGetRelocationType = __library.get(b"LLVMGetRelocationType\0").map(|sym| *sym);
        let LLVMGetRelocationTypeName = __library
            .get(b"LLVMGetRelocationTypeName\0")
            .map(|sym| *sym);
        let LLVMGetRelocationValueString = __library
            .get(b"LLVMGetRelocationValueString\0")
            .map(|sym| *sym);
        let LLVMCreateObjectFile = __library.get(b"LLVMCreateObjectFile\0").map(|sym| *sym);
        let LLVMDisposeObjectFile = __library.get(b"LLVMDisposeObjectFile\0").map(|sym| *sym);
        let LLVMGetSections = __library.get(b"LLVMGetSections\0").map(|sym| *sym);
        let LLVMIsSectionIteratorAtEnd = __library
            .get(b"LLVMIsSectionIteratorAtEnd\0")
            .map(|sym| *sym);
        let LLVMGetSymbols = __library.get(b"LLVMGetSymbols\0").map(|sym| *sym);
        let LLVMIsSymbolIteratorAtEnd = __library
            .get(b"LLVMIsSymbolIteratorAtEnd\0")
            .map(|sym| *sym);
        let LLVMOrcCreateRTDyldObjectLinkingLayerWithSectionMemoryManager = __library
            .get(b"LLVMOrcCreateRTDyldObjectLinkingLayerWithSectionMemoryManager\0")
            .map(|sym| *sym);
        let LLVMOrcCreateRTDyldObjectLinkingLayerWithMCJITMemoryManagerLikeCallbacks = __library
            .get(b"LLVMOrcCreateRTDyldObjectLinkingLayerWithMCJITMemoryManagerLikeCallbacks\0")
            .map(|sym| *sym);
        let LLVMOrcRTDyldObjectLinkingLayerRegisterJITEventListener = __library
            .get(b"LLVMOrcRTDyldObjectLinkingLayerRegisterJITEventListener\0")
            .map(|sym| *sym);
        let LLVMRemarkStringGetData = __library.get(b"LLVMRemarkStringGetData\0").map(|sym| *sym);
        let LLVMRemarkStringGetLen = __library.get(b"LLVMRemarkStringGetLen\0").map(|sym| *sym);
        let LLVMRemarkDebugLocGetSourceFilePath = __library
            .get(b"LLVMRemarkDebugLocGetSourceFilePath\0")
            .map(|sym| *sym);
        let LLVMRemarkDebugLocGetSourceLine = __library
            .get(b"LLVMRemarkDebugLocGetSourceLine\0")
            .map(|sym| *sym);
        let LLVMRemarkDebugLocGetSourceColumn = __library
            .get(b"LLVMRemarkDebugLocGetSourceColumn\0")
            .map(|sym| *sym);
        let LLVMRemarkArgGetKey = __library.get(b"LLVMRemarkArgGetKey\0").map(|sym| *sym);
        let LLVMRemarkArgGetValue = __library.get(b"LLVMRemarkArgGetValue\0").map(|sym| *sym);
        let LLVMRemarkArgGetDebugLoc = __library.get(b"LLVMRemarkArgGetDebugLoc\0").map(|sym| *sym);
        let LLVMRemarkEntryDispose = __library.get(b"LLVMRemarkEntryDispose\0").map(|sym| *sym);
        let LLVMRemarkEntryGetType = __library.get(b"LLVMRemarkEntryGetType\0").map(|sym| *sym);
        let LLVMRemarkEntryGetPassName = __library
            .get(b"LLVMRemarkEntryGetPassName\0")
            .map(|sym| *sym);
        let LLVMRemarkEntryGetRemarkName = __library
            .get(b"LLVMRemarkEntryGetRemarkName\0")
            .map(|sym| *sym);
        let LLVMRemarkEntryGetFunctionName = __library
            .get(b"LLVMRemarkEntryGetFunctionName\0")
            .map(|sym| *sym);
        let LLVMRemarkEntryGetDebugLoc = __library
            .get(b"LLVMRemarkEntryGetDebugLoc\0")
            .map(|sym| *sym);
        let LLVMRemarkEntryGetHotness = __library
            .get(b"LLVMRemarkEntryGetHotness\0")
            .map(|sym| *sym);
        let LLVMRemarkEntryGetNumArgs = __library
            .get(b"LLVMRemarkEntryGetNumArgs\0")
            .map(|sym| *sym);
        let LLVMRemarkEntryGetFirstArg = __library
            .get(b"LLVMRemarkEntryGetFirstArg\0")
            .map(|sym| *sym);
        let LLVMRemarkEntryGetNextArg = __library
            .get(b"LLVMRemarkEntryGetNextArg\0")
            .map(|sym| *sym);
        let LLVMRemarkParserCreateYAML = __library
            .get(b"LLVMRemarkParserCreateYAML\0")
            .map(|sym| *sym);
        let LLVMRemarkParserCreateBitstream = __library
            .get(b"LLVMRemarkParserCreateBitstream\0")
            .map(|sym| *sym);
        let LLVMRemarkParserGetNext = __library.get(b"LLVMRemarkParserGetNext\0").map(|sym| *sym);
        let LLVMRemarkParserHasError = __library.get(b"LLVMRemarkParserHasError\0").map(|sym| *sym);
        let LLVMRemarkParserGetErrorMessage = __library
            .get(b"LLVMRemarkParserGetErrorMessage\0")
            .map(|sym| *sym);
        let LLVMRemarkParserDispose = __library.get(b"LLVMRemarkParserDispose\0").map(|sym| *sym);
        let LLVMRemarkVersion = __library.get(b"LLVMRemarkVersion\0").map(|sym| *sym);
        let LLVMLoadLibraryPermanently = __library
            .get(b"LLVMLoadLibraryPermanently\0")
            .map(|sym| *sym);
        let LLVMParseCommandLineOptions = __library
            .get(b"LLVMParseCommandLineOptions\0")
            .map(|sym| *sym);
        let LLVMSearchForAddressOfSymbol = __library
            .get(b"LLVMSearchForAddressOfSymbol\0")
            .map(|sym| *sym);
        let LLVMAddSymbol = __library.get(b"LLVMAddSymbol\0").map(|sym| *sym);
        Ok(llvm {
            __library,
            LLVMVerifyModule,
            LLVMVerifyFunction,
            LLVMViewFunctionCFG,
            LLVMViewFunctionCFGOnly,
            LLVMParseBitcode,
            LLVMParseBitcode2,
            LLVMParseBitcodeInContext,
            LLVMParseBitcodeInContext2,
            LLVMGetBitcodeModuleInContext,
            LLVMGetBitcodeModuleInContext2,
            LLVMGetBitcodeModule,
            LLVMGetBitcodeModule2,
            LLVMWriteBitcodeToFile,
            LLVMWriteBitcodeToFD,
            LLVMWriteBitcodeToFileHandle,
            LLVMWriteBitcodeToMemoryBuffer,
            LLVMGetOrInsertComdat,
            LLVMGetComdat,
            LLVMSetComdat,
            LLVMGetComdatSelectionKind,
            LLVMSetComdatSelectionKind,
            LLVMInstallFatalErrorHandler,
            LLVMResetFatalErrorHandler,
            LLVMEnablePrettyStackTrace,
            LLVMShutdown,
            LLVMGetVersion,
            LLVMCreateMessage,
            LLVMDisposeMessage,
            LLVMContextCreate,
            LLVMGetGlobalContext,
            LLVMContextSetDiagnosticHandler,
            LLVMContextGetDiagnosticHandler,
            LLVMContextGetDiagnosticContext,
            LLVMContextSetYieldCallback,
            LLVMContextShouldDiscardValueNames,
            LLVMContextSetDiscardValueNames,
            LLVMContextDispose,
            LLVMGetDiagInfoDescription,
            LLVMGetDiagInfoSeverity,
            LLVMGetMDKindIDInContext,
            LLVMGetMDKindID,
            LLVMGetEnumAttributeKindForName,
            LLVMGetLastEnumAttributeKind,
            LLVMCreateEnumAttribute,
            LLVMGetEnumAttributeKind,
            LLVMGetEnumAttributeValue,
            LLVMCreateTypeAttribute,
            LLVMGetTypeAttributeValue,
            LLVMCreateStringAttribute,
            LLVMGetStringAttributeKind,
            LLVMGetStringAttributeValue,
            LLVMIsEnumAttribute,
            LLVMIsStringAttribute,
            LLVMIsTypeAttribute,
            LLVMGetTypeByName2,
            LLVMModuleCreateWithName,
            LLVMModuleCreateWithNameInContext,
            LLVMCloneModule,
            LLVMDisposeModule,
            LLVMGetModuleIdentifier,
            LLVMSetModuleIdentifier,
            LLVMGetSourceFileName,
            LLVMSetSourceFileName,
            LLVMGetDataLayoutStr,
            LLVMGetDataLayout,
            LLVMSetDataLayout,
            LLVMGetTarget,
            LLVMSetTarget,
            LLVMCopyModuleFlagsMetadata,
            LLVMDisposeModuleFlagsMetadata,
            LLVMModuleFlagEntriesGetFlagBehavior,
            LLVMModuleFlagEntriesGetKey,
            LLVMModuleFlagEntriesGetMetadata,
            LLVMGetModuleFlag,
            LLVMAddModuleFlag,
            LLVMDumpModule,
            LLVMPrintModuleToFile,
            LLVMPrintModuleToString,
            LLVMGetModuleInlineAsm,
            LLVMSetModuleInlineAsm2,
            LLVMAppendModuleInlineAsm,
            LLVMGetInlineAsm,
            LLVMGetModuleContext,
            LLVMGetTypeByName,
            LLVMGetFirstNamedMetadata,
            LLVMGetLastNamedMetadata,
            LLVMGetNextNamedMetadata,
            LLVMGetPreviousNamedMetadata,
            LLVMGetNamedMetadata,
            LLVMGetOrInsertNamedMetadata,
            LLVMGetNamedMetadataName,
            LLVMGetNamedMetadataNumOperands,
            LLVMGetNamedMetadataOperands,
            LLVMAddNamedMetadataOperand,
            LLVMGetDebugLocDirectory,
            LLVMGetDebugLocFilename,
            LLVMGetDebugLocLine,
            LLVMGetDebugLocColumn,
            LLVMAddFunction,
            LLVMGetNamedFunction,
            LLVMGetFirstFunction,
            LLVMGetLastFunction,
            LLVMGetNextFunction,
            LLVMGetPreviousFunction,
            LLVMSetModuleInlineAsm,
            LLVMGetTypeKind,
            LLVMTypeIsSized,
            LLVMGetTypeContext,
            LLVMDumpType,
            LLVMPrintTypeToString,
            LLVMInt1TypeInContext,
            LLVMInt8TypeInContext,
            LLVMInt16TypeInContext,
            LLVMInt32TypeInContext,
            LLVMInt64TypeInContext,
            LLVMInt128TypeInContext,
            LLVMIntTypeInContext,
            LLVMInt1Type,
            LLVMInt8Type,
            LLVMInt16Type,
            LLVMInt32Type,
            LLVMInt64Type,
            LLVMInt128Type,
            LLVMIntType,
            LLVMGetIntTypeWidth,
            LLVMHalfTypeInContext,
            LLVMBFloatTypeInContext,
            LLVMFloatTypeInContext,
            LLVMDoubleTypeInContext,
            LLVMX86FP80TypeInContext,
            LLVMFP128TypeInContext,
            LLVMPPCFP128TypeInContext,
            LLVMHalfType,
            LLVMBFloatType,
            LLVMFloatType,
            LLVMDoubleType,
            LLVMX86FP80Type,
            LLVMFP128Type,
            LLVMPPCFP128Type,
            LLVMFunctionType,
            LLVMIsFunctionVarArg,
            LLVMGetReturnType,
            LLVMCountParamTypes,
            LLVMGetParamTypes,
            LLVMStructTypeInContext,
            LLVMStructType,
            LLVMStructCreateNamed,
            LLVMGetStructName,
            LLVMStructSetBody,
            LLVMCountStructElementTypes,
            LLVMGetStructElementTypes,
            LLVMStructGetTypeAtIndex,
            LLVMIsPackedStruct,
            LLVMIsOpaqueStruct,
            LLVMIsLiteralStruct,
            LLVMGetElementType,
            LLVMGetSubtypes,
            LLVMGetNumContainedTypes,
            LLVMArrayType,
            LLVMArrayType2,
            LLVMGetArrayLength,
            LLVMGetArrayLength2,
            LLVMPointerType,
            LLVMPointerTypeIsOpaque,
            LLVMPointerTypeInContext,
            LLVMGetPointerAddressSpace,
            LLVMVectorType,
            LLVMScalableVectorType,
            LLVMGetVectorSize,
            LLVMVoidTypeInContext,
            LLVMLabelTypeInContext,
            LLVMX86MMXTypeInContext,
            LLVMX86AMXTypeInContext,
            LLVMTokenTypeInContext,
            LLVMMetadataTypeInContext,
            LLVMVoidType,
            LLVMLabelType,
            LLVMX86MMXType,
            LLVMX86AMXType,
            LLVMTargetExtTypeInContext,
            LLVMTypeOf,
            LLVMGetValueKind,
            LLVMGetValueName2,
            LLVMSetValueName2,
            LLVMDumpValue,
            LLVMPrintValueToString,
            LLVMReplaceAllUsesWith,
            LLVMIsConstant,
            LLVMIsUndef,
            LLVMIsPoison,
            LLVMIsAArgument,
            LLVMIsABasicBlock,
            LLVMIsAInlineAsm,
            LLVMIsAUser,
            LLVMIsAConstant,
            LLVMIsABlockAddress,
            LLVMIsAConstantAggregateZero,
            LLVMIsAConstantArray,
            LLVMIsAConstantDataSequential,
            LLVMIsAConstantDataArray,
            LLVMIsAConstantDataVector,
            LLVMIsAConstantExpr,
            LLVMIsAConstantFP,
            LLVMIsAConstantInt,
            LLVMIsAConstantPointerNull,
            LLVMIsAConstantStruct,
            LLVMIsAConstantTokenNone,
            LLVMIsAConstantVector,
            LLVMIsAGlobalValue,
            LLVMIsAGlobalAlias,
            LLVMIsAGlobalObject,
            LLVMIsAFunction,
            LLVMIsAGlobalVariable,
            LLVMIsAGlobalIFunc,
            LLVMIsAUndefValue,
            LLVMIsAPoisonValue,
            LLVMIsAInstruction,
            LLVMIsAUnaryOperator,
            LLVMIsABinaryOperator,
            LLVMIsACallInst,
            LLVMIsAIntrinsicInst,
            LLVMIsADbgInfoIntrinsic,
            LLVMIsADbgVariableIntrinsic,
            LLVMIsADbgDeclareInst,
            LLVMIsADbgLabelInst,
            LLVMIsAMemIntrinsic,
            LLVMIsAMemCpyInst,
            LLVMIsAMemMoveInst,
            LLVMIsAMemSetInst,
            LLVMIsACmpInst,
            LLVMIsAFCmpInst,
            LLVMIsAICmpInst,
            LLVMIsAExtractElementInst,
            LLVMIsAGetElementPtrInst,
            LLVMIsAInsertElementInst,
            LLVMIsAInsertValueInst,
            LLVMIsALandingPadInst,
            LLVMIsAPHINode,
            LLVMIsASelectInst,
            LLVMIsAShuffleVectorInst,
            LLVMIsAStoreInst,
            LLVMIsABranchInst,
            LLVMIsAIndirectBrInst,
            LLVMIsAInvokeInst,
            LLVMIsAReturnInst,
            LLVMIsASwitchInst,
            LLVMIsAUnreachableInst,
            LLVMIsAResumeInst,
            LLVMIsACleanupReturnInst,
            LLVMIsACatchReturnInst,
            LLVMIsACatchSwitchInst,
            LLVMIsACallBrInst,
            LLVMIsAFuncletPadInst,
            LLVMIsACatchPadInst,
            LLVMIsACleanupPadInst,
            LLVMIsAUnaryInstruction,
            LLVMIsAAllocaInst,
            LLVMIsACastInst,
            LLVMIsAAddrSpaceCastInst,
            LLVMIsABitCastInst,
            LLVMIsAFPExtInst,
            LLVMIsAFPToSIInst,
            LLVMIsAFPToUIInst,
            LLVMIsAFPTruncInst,
            LLVMIsAIntToPtrInst,
            LLVMIsAPtrToIntInst,
            LLVMIsASExtInst,
            LLVMIsASIToFPInst,
            LLVMIsATruncInst,
            LLVMIsAUIToFPInst,
            LLVMIsAZExtInst,
            LLVMIsAExtractValueInst,
            LLVMIsALoadInst,
            LLVMIsAVAArgInst,
            LLVMIsAFreezeInst,
            LLVMIsAAtomicCmpXchgInst,
            LLVMIsAAtomicRMWInst,
            LLVMIsAFenceInst,
            LLVMIsAMDNode,
            LLVMIsAValueAsMetadata,
            LLVMIsAMDString,
            LLVMGetValueName,
            LLVMSetValueName,
            LLVMGetFirstUse,
            LLVMGetNextUse,
            LLVMGetUser,
            LLVMGetUsedValue,
            LLVMGetOperand,
            LLVMGetOperandUse,
            LLVMSetOperand,
            LLVMGetNumOperands,
            LLVMConstNull,
            LLVMConstAllOnes,
            LLVMGetUndef,
            LLVMGetPoison,
            LLVMIsNull,
            LLVMConstPointerNull,
            LLVMConstInt,
            LLVMConstIntOfArbitraryPrecision,
            LLVMConstIntOfString,
            LLVMConstIntOfStringAndSize,
            LLVMConstReal,
            LLVMConstRealOfString,
            LLVMConstRealOfStringAndSize,
            LLVMConstIntGetZExtValue,
            LLVMConstIntGetSExtValue,
            LLVMConstRealGetDouble,
            LLVMConstStringInContext,
            LLVMConstString,
            LLVMIsConstantString,
            LLVMGetAsString,
            LLVMConstStructInContext,
            LLVMConstStruct,
            LLVMConstArray,
            LLVMConstArray2,
            LLVMConstNamedStruct,
            LLVMGetAggregateElement,
            LLVMGetElementAsConstant,
            LLVMConstVector,
            LLVMGetConstOpcode,
            LLVMAlignOf,
            LLVMSizeOf,
            LLVMConstNeg,
            LLVMConstNSWNeg,
            LLVMConstNUWNeg,
            LLVMConstNot,
            LLVMConstAdd,
            LLVMConstNSWAdd,
            LLVMConstNUWAdd,
            LLVMConstSub,
            LLVMConstNSWSub,
            LLVMConstNUWSub,
            LLVMConstMul,
            LLVMConstNSWMul,
            LLVMConstNUWMul,
            LLVMConstAnd,
            LLVMConstOr,
            LLVMConstXor,
            LLVMConstICmp,
            LLVMConstFCmp,
            LLVMConstShl,
            LLVMConstLShr,
            LLVMConstAShr,
            LLVMConstGEP2,
            LLVMConstInBoundsGEP2,
            LLVMConstTrunc,
            LLVMConstSExt,
            LLVMConstZExt,
            LLVMConstFPTrunc,
            LLVMConstFPExt,
            LLVMConstUIToFP,
            LLVMConstSIToFP,
            LLVMConstFPToUI,
            LLVMConstFPToSI,
            LLVMConstPtrToInt,
            LLVMConstIntToPtr,
            LLVMConstBitCast,
            LLVMConstAddrSpaceCast,
            LLVMConstZExtOrBitCast,
            LLVMConstSExtOrBitCast,
            LLVMConstTruncOrBitCast,
            LLVMConstPointerCast,
            LLVMConstIntCast,
            LLVMConstFPCast,
            LLVMConstExtractElement,
            LLVMConstInsertElement,
            LLVMConstShuffleVector,
            LLVMBlockAddress,
            LLVMConstInlineAsm,
            LLVMGetGlobalParent,
            LLVMIsDeclaration,
            LLVMGetLinkage,
            LLVMSetLinkage,
            LLVMGetSection,
            LLVMSetSection,
            LLVMGetVisibility,
            LLVMSetVisibility,
            LLVMGetDLLStorageClass,
            LLVMSetDLLStorageClass,
            LLVMGetUnnamedAddress,
            LLVMSetUnnamedAddress,
            LLVMGlobalGetValueType,
            LLVMHasUnnamedAddr,
            LLVMSetUnnamedAddr,
            LLVMGetAlignment,
            LLVMSetAlignment,
            LLVMGlobalSetMetadata,
            LLVMGlobalEraseMetadata,
            LLVMGlobalClearMetadata,
            LLVMGlobalCopyAllMetadata,
            LLVMDisposeValueMetadataEntries,
            LLVMValueMetadataEntriesGetKind,
            LLVMValueMetadataEntriesGetMetadata,
            LLVMAddGlobal,
            LLVMAddGlobalInAddressSpace,
            LLVMGetNamedGlobal,
            LLVMGetFirstGlobal,
            LLVMGetLastGlobal,
            LLVMGetNextGlobal,
            LLVMGetPreviousGlobal,
            LLVMDeleteGlobal,
            LLVMGetInitializer,
            LLVMSetInitializer,
            LLVMIsThreadLocal,
            LLVMSetThreadLocal,
            LLVMIsGlobalConstant,
            LLVMSetGlobalConstant,
            LLVMGetThreadLocalMode,
            LLVMSetThreadLocalMode,
            LLVMIsExternallyInitialized,
            LLVMSetExternallyInitialized,
            LLVMAddAlias2,
            LLVMGetNamedGlobalAlias,
            LLVMGetFirstGlobalAlias,
            LLVMGetLastGlobalAlias,
            LLVMGetNextGlobalAlias,
            LLVMGetPreviousGlobalAlias,
            LLVMAliasGetAliasee,
            LLVMAliasSetAliasee,
            LLVMDeleteFunction,
            LLVMHasPersonalityFn,
            LLVMGetPersonalityFn,
            LLVMSetPersonalityFn,
            LLVMLookupIntrinsicID,
            LLVMGetIntrinsicID,
            LLVMGetIntrinsicDeclaration,
            LLVMIntrinsicGetType,
            LLVMIntrinsicGetName,
            LLVMIntrinsicCopyOverloadedName,
            LLVMIntrinsicCopyOverloadedName2,
            LLVMIntrinsicIsOverloaded,
            LLVMGetFunctionCallConv,
            LLVMSetFunctionCallConv,
            LLVMGetGC,
            LLVMSetGC,
            LLVMAddAttributeAtIndex,
            LLVMGetAttributeCountAtIndex,
            LLVMGetAttributesAtIndex,
            LLVMGetEnumAttributeAtIndex,
            LLVMGetStringAttributeAtIndex,
            LLVMRemoveEnumAttributeAtIndex,
            LLVMRemoveStringAttributeAtIndex,
            LLVMAddTargetDependentFunctionAttr,
            LLVMCountParams,
            LLVMGetParams,
            LLVMGetParam,
            LLVMGetParamParent,
            LLVMGetFirstParam,
            LLVMGetLastParam,
            LLVMGetNextParam,
            LLVMGetPreviousParam,
            LLVMSetParamAlignment,
            LLVMAddGlobalIFunc,
            LLVMGetNamedGlobalIFunc,
            LLVMGetFirstGlobalIFunc,
            LLVMGetLastGlobalIFunc,
            LLVMGetNextGlobalIFunc,
            LLVMGetPreviousGlobalIFunc,
            LLVMGetGlobalIFuncResolver,
            LLVMSetGlobalIFuncResolver,
            LLVMEraseGlobalIFunc,
            LLVMRemoveGlobalIFunc,
            LLVMMDStringInContext2,
            LLVMMDNodeInContext2,
            LLVMMetadataAsValue,
            LLVMValueAsMetadata,
            LLVMGetMDString,
            LLVMGetMDNodeNumOperands,
            LLVMGetMDNodeOperands,
            LLVMReplaceMDNodeOperandWith,
            LLVMMDStringInContext,
            LLVMMDString,
            LLVMMDNodeInContext,
            LLVMMDNode,
            LLVMBasicBlockAsValue,
            LLVMValueIsBasicBlock,
            LLVMValueAsBasicBlock,
            LLVMGetBasicBlockName,
            LLVMGetBasicBlockParent,
            LLVMGetBasicBlockTerminator,
            LLVMCountBasicBlocks,
            LLVMGetBasicBlocks,
            LLVMGetFirstBasicBlock,
            LLVMGetLastBasicBlock,
            LLVMGetNextBasicBlock,
            LLVMGetPreviousBasicBlock,
            LLVMGetEntryBasicBlock,
            LLVMInsertExistingBasicBlockAfterInsertBlock,
            LLVMAppendExistingBasicBlock,
            LLVMCreateBasicBlockInContext,
            LLVMAppendBasicBlockInContext,
            LLVMAppendBasicBlock,
            LLVMInsertBasicBlockInContext,
            LLVMInsertBasicBlock,
            LLVMDeleteBasicBlock,
            LLVMRemoveBasicBlockFromParent,
            LLVMMoveBasicBlockBefore,
            LLVMMoveBasicBlockAfter,
            LLVMGetFirstInstruction,
            LLVMGetLastInstruction,
            LLVMHasMetadata,
            LLVMGetMetadata,
            LLVMSetMetadata,
            LLVMInstructionGetAllMetadataOtherThanDebugLoc,
            LLVMGetInstructionParent,
            LLVMGetNextInstruction,
            LLVMGetPreviousInstruction,
            LLVMInstructionRemoveFromParent,
            LLVMInstructionEraseFromParent,
            LLVMDeleteInstruction,
            LLVMGetInstructionOpcode,
            LLVMGetICmpPredicate,
            LLVMGetFCmpPredicate,
            LLVMInstructionClone,
            LLVMIsATerminatorInst,
            LLVMGetNumArgOperands,
            LLVMSetInstructionCallConv,
            LLVMGetInstructionCallConv,
            LLVMSetInstrParamAlignment,
            LLVMAddCallSiteAttribute,
            LLVMGetCallSiteAttributeCount,
            LLVMGetCallSiteAttributes,
            LLVMGetCallSiteEnumAttribute,
            LLVMGetCallSiteStringAttribute,
            LLVMRemoveCallSiteEnumAttribute,
            LLVMRemoveCallSiteStringAttribute,
            LLVMGetCalledFunctionType,
            LLVMGetCalledValue,
            LLVMIsTailCall,
            LLVMSetTailCall,
            LLVMGetNormalDest,
            LLVMGetUnwindDest,
            LLVMSetNormalDest,
            LLVMSetUnwindDest,
            LLVMGetNumSuccessors,
            LLVMGetSuccessor,
            LLVMSetSuccessor,
            LLVMIsConditional,
            LLVMGetCondition,
            LLVMSetCondition,
            LLVMGetSwitchDefaultDest,
            LLVMGetAllocatedType,
            LLVMIsInBounds,
            LLVMSetIsInBounds,
            LLVMGetGEPSourceElementType,
            LLVMAddIncoming,
            LLVMCountIncoming,
            LLVMGetIncomingValue,
            LLVMGetIncomingBlock,
            LLVMGetNumIndices,
            LLVMGetIndices,
            LLVMCreateBuilderInContext,
            LLVMCreateBuilder,
            LLVMPositionBuilder,
            LLVMPositionBuilderBefore,
            LLVMPositionBuilderAtEnd,
            LLVMGetInsertBlock,
            LLVMClearInsertionPosition,
            LLVMInsertIntoBuilder,
            LLVMInsertIntoBuilderWithName,
            LLVMDisposeBuilder,
            LLVMGetCurrentDebugLocation2,
            LLVMSetCurrentDebugLocation2,
            LLVMSetInstDebugLocation,
            LLVMAddMetadataToInst,
            LLVMBuilderGetDefaultFPMathTag,
            LLVMBuilderSetDefaultFPMathTag,
            LLVMSetCurrentDebugLocation,
            LLVMGetCurrentDebugLocation,
            LLVMBuildRetVoid,
            LLVMBuildRet,
            LLVMBuildAggregateRet,
            LLVMBuildBr,
            LLVMBuildCondBr,
            LLVMBuildSwitch,
            LLVMBuildIndirectBr,
            LLVMBuildInvoke2,
            LLVMBuildUnreachable,
            LLVMBuildResume,
            LLVMBuildLandingPad,
            LLVMBuildCleanupRet,
            LLVMBuildCatchRet,
            LLVMBuildCatchPad,
            LLVMBuildCleanupPad,
            LLVMBuildCatchSwitch,
            LLVMAddCase,
            LLVMAddDestination,
            LLVMGetNumClauses,
            LLVMGetClause,
            LLVMAddClause,
            LLVMIsCleanup,
            LLVMSetCleanup,
            LLVMAddHandler,
            LLVMGetNumHandlers,
            LLVMGetHandlers,
            LLVMGetArgOperand,
            LLVMSetArgOperand,
            LLVMGetParentCatchSwitch,
            LLVMSetParentCatchSwitch,
            LLVMBuildAdd,
            LLVMBuildNSWAdd,
            LLVMBuildNUWAdd,
            LLVMBuildFAdd,
            LLVMBuildSub,
            LLVMBuildNSWSub,
            LLVMBuildNUWSub,
            LLVMBuildFSub,
            LLVMBuildMul,
            LLVMBuildNSWMul,
            LLVMBuildNUWMul,
            LLVMBuildFMul,
            LLVMBuildUDiv,
            LLVMBuildExactUDiv,
            LLVMBuildSDiv,
            LLVMBuildExactSDiv,
            LLVMBuildFDiv,
            LLVMBuildURem,
            LLVMBuildSRem,
            LLVMBuildFRem,
            LLVMBuildShl,
            LLVMBuildLShr,
            LLVMBuildAShr,
            LLVMBuildAnd,
            LLVMBuildOr,
            LLVMBuildXor,
            LLVMBuildBinOp,
            LLVMBuildNeg,
            LLVMBuildNSWNeg,
            LLVMBuildNUWNeg,
            LLVMBuildFNeg,
            LLVMBuildNot,
            LLVMGetNUW,
            LLVMSetNUW,
            LLVMGetNSW,
            LLVMSetNSW,
            LLVMGetExact,
            LLVMSetExact,
            LLVMBuildMalloc,
            LLVMBuildArrayMalloc,
            LLVMBuildMemSet,
            LLVMBuildMemCpy,
            LLVMBuildMemMove,
            LLVMBuildAlloca,
            LLVMBuildArrayAlloca,
            LLVMBuildFree,
            LLVMBuildLoad2,
            LLVMBuildStore,
            LLVMBuildGEP2,
            LLVMBuildInBoundsGEP2,
            LLVMBuildStructGEP2,
            LLVMBuildGlobalString,
            LLVMBuildGlobalStringPtr,
            LLVMGetVolatile,
            LLVMSetVolatile,
            LLVMGetWeak,
            LLVMSetWeak,
            LLVMGetOrdering,
            LLVMSetOrdering,
            LLVMGetAtomicRMWBinOp,
            LLVMSetAtomicRMWBinOp,
            LLVMBuildTrunc,
            LLVMBuildZExt,
            LLVMBuildSExt,
            LLVMBuildFPToUI,
            LLVMBuildFPToSI,
            LLVMBuildUIToFP,
            LLVMBuildSIToFP,
            LLVMBuildFPTrunc,
            LLVMBuildFPExt,
            LLVMBuildPtrToInt,
            LLVMBuildIntToPtr,
            LLVMBuildBitCast,
            LLVMBuildAddrSpaceCast,
            LLVMBuildZExtOrBitCast,
            LLVMBuildSExtOrBitCast,
            LLVMBuildTruncOrBitCast,
            LLVMBuildCast,
            LLVMBuildPointerCast,
            LLVMBuildIntCast2,
            LLVMBuildFPCast,
            LLVMBuildIntCast,
            LLVMGetCastOpcode,
            LLVMBuildICmp,
            LLVMBuildFCmp,
            LLVMBuildPhi,
            LLVMBuildCall2,
            LLVMBuildSelect,
            LLVMBuildVAArg,
            LLVMBuildExtractElement,
            LLVMBuildInsertElement,
            LLVMBuildShuffleVector,
            LLVMBuildExtractValue,
            LLVMBuildInsertValue,
            LLVMBuildFreeze,
            LLVMBuildIsNull,
            LLVMBuildIsNotNull,
            LLVMBuildPtrDiff2,
            LLVMBuildFence,
            LLVMBuildAtomicRMW,
            LLVMBuildAtomicCmpXchg,
            LLVMGetNumMaskElements,
            LLVMGetUndefMaskElem,
            LLVMGetMaskValue,
            LLVMIsAtomicSingleThread,
            LLVMSetAtomicSingleThread,
            LLVMGetCmpXchgSuccessOrdering,
            LLVMSetCmpXchgSuccessOrdering,
            LLVMGetCmpXchgFailureOrdering,
            LLVMSetCmpXchgFailureOrdering,
            LLVMCreateModuleProviderForExistingModule,
            LLVMDisposeModuleProvider,
            LLVMCreateMemoryBufferWithContentsOfFile,
            LLVMCreateMemoryBufferWithSTDIN,
            LLVMCreateMemoryBufferWithMemoryRange,
            LLVMCreateMemoryBufferWithMemoryRangeCopy,
            LLVMGetBufferStart,
            LLVMGetBufferSize,
            LLVMDisposeMemoryBuffer,
            LLVMCreatePassManager,
            LLVMCreateFunctionPassManagerForModule,
            LLVMCreateFunctionPassManager,
            LLVMRunPassManager,
            LLVMInitializeFunctionPassManager,
            LLVMRunFunctionPassManager,
            LLVMFinalizeFunctionPassManager,
            LLVMDisposePassManager,
            LLVMStartMultithreaded,
            LLVMStopMultithreaded,
            LLVMIsMultithreaded,
            LLVMDebugMetadataVersion,
            LLVMGetModuleDebugMetadataVersion,
            LLVMStripModuleDebugInfo,
            LLVMCreateDIBuilderDisallowUnresolved,
            LLVMCreateDIBuilder,
            LLVMDisposeDIBuilder,
            LLVMDIBuilderFinalize,
            LLVMDIBuilderFinalizeSubprogram,
            LLVMDIBuilderCreateCompileUnit,
            LLVMDIBuilderCreateFile,
            LLVMDIBuilderCreateModule,
            LLVMDIBuilderCreateNameSpace,
            LLVMDIBuilderCreateFunction,
            LLVMDIBuilderCreateLexicalBlock,
            LLVMDIBuilderCreateLexicalBlockFile,
            LLVMDIBuilderCreateImportedModuleFromNamespace,
            LLVMDIBuilderCreateImportedModuleFromAlias,
            LLVMDIBuilderCreateImportedModuleFromModule,
            LLVMDIBuilderCreateImportedDeclaration,
            LLVMDIBuilderCreateDebugLocation,
            LLVMDILocationGetLine,
            LLVMDILocationGetColumn,
            LLVMDILocationGetScope,
            LLVMDILocationGetInlinedAt,
            LLVMDIScopeGetFile,
            LLVMDIFileGetDirectory,
            LLVMDIFileGetFilename,
            LLVMDIFileGetSource,
            LLVMDIBuilderGetOrCreateTypeArray,
            LLVMDIBuilderCreateSubroutineType,
            LLVMDIBuilderCreateMacro,
            LLVMDIBuilderCreateTempMacroFile,
            LLVMDIBuilderCreateEnumerator,
            LLVMDIBuilderCreateEnumerationType,
            LLVMDIBuilderCreateUnionType,
            LLVMDIBuilderCreateArrayType,
            LLVMDIBuilderCreateVectorType,
            LLVMDIBuilderCreateUnspecifiedType,
            LLVMDIBuilderCreateBasicType,
            LLVMDIBuilderCreatePointerType,
            LLVMDIBuilderCreateStructType,
            LLVMDIBuilderCreateMemberType,
            LLVMDIBuilderCreateStaticMemberType,
            LLVMDIBuilderCreateMemberPointerType,
            LLVMDIBuilderCreateObjCIVar,
            LLVMDIBuilderCreateObjCProperty,
            LLVMDIBuilderCreateObjectPointerType,
            LLVMDIBuilderCreateQualifiedType,
            LLVMDIBuilderCreateReferenceType,
            LLVMDIBuilderCreateNullPtrType,
            LLVMDIBuilderCreateTypedef,
            LLVMDIBuilderCreateInheritance,
            LLVMDIBuilderCreateForwardDecl,
            LLVMDIBuilderCreateReplaceableCompositeType,
            LLVMDIBuilderCreateBitFieldMemberType,
            LLVMDIBuilderCreateClassType,
            LLVMDIBuilderCreateArtificialType,
            LLVMDITypeGetName,
            LLVMDITypeGetSizeInBits,
            LLVMDITypeGetOffsetInBits,
            LLVMDITypeGetAlignInBits,
            LLVMDITypeGetLine,
            LLVMDITypeGetFlags,
            LLVMDIBuilderGetOrCreateSubrange,
            LLVMDIBuilderGetOrCreateArray,
            LLVMDIBuilderCreateExpression,
            LLVMDIBuilderCreateConstantValueExpression,
            LLVMDIBuilderCreateGlobalVariableExpression,
            LLVMGetDINodeTag,
            LLVMDIGlobalVariableExpressionGetVariable,
            LLVMDIGlobalVariableExpressionGetExpression,
            LLVMDIVariableGetFile,
            LLVMDIVariableGetScope,
            LLVMDIVariableGetLine,
            LLVMTemporaryMDNode,
            LLVMDisposeTemporaryMDNode,
            LLVMMetadataReplaceAllUsesWith,
            LLVMDIBuilderCreateTempGlobalVariableFwdDecl,
            LLVMDIBuilderInsertDeclareBefore,
            LLVMDIBuilderInsertDeclareAtEnd,
            LLVMDIBuilderInsertDbgValueBefore,
            LLVMDIBuilderInsertDbgValueAtEnd,
            LLVMDIBuilderCreateAutoVariable,
            LLVMDIBuilderCreateParameterVariable,
            LLVMGetSubprogram,
            LLVMSetSubprogram,
            LLVMDISubprogramGetLine,
            LLVMInstructionGetDebugLoc,
            LLVMInstructionSetDebugLoc,
            LLVMGetMetadataKind,
            LLVMCreateDisasm,
            LLVMCreateDisasmCPU,
            LLVMCreateDisasmCPUFeatures,
            LLVMSetDisasmOptions,
            LLVMDisasmDispose,
            LLVMDisasmInstruction,
            LLVMGetErrorTypeId,
            LLVMConsumeError,
            LLVMGetErrorMessage,
            LLVMDisposeErrorMessage,
            LLVMGetStringErrorTypeId,
            LLVMCreateStringError,
            LLVMInitializeAArch64TargetInfo,
            LLVMInitializeAMDGPUTargetInfo,
            LLVMInitializeARMTargetInfo,
            LLVMInitializeAVRTargetInfo,
            LLVMInitializeBPFTargetInfo,
            LLVMInitializeHexagonTargetInfo,
            LLVMInitializeLanaiTargetInfo,
            LLVMInitializeLoongArchTargetInfo,
            LLVMInitializeMipsTargetInfo,
            LLVMInitializeMSP430TargetInfo,
            LLVMInitializeNVPTXTargetInfo,
            LLVMInitializePowerPCTargetInfo,
            LLVMInitializeRISCVTargetInfo,
            LLVMInitializeSparcTargetInfo,
            LLVMInitializeSystemZTargetInfo,
            LLVMInitializeVETargetInfo,
            LLVMInitializeWebAssemblyTargetInfo,
            LLVMInitializeX86TargetInfo,
            LLVMInitializeXCoreTargetInfo,
            LLVMInitializeAArch64Target,
            LLVMInitializeAMDGPUTarget,
            LLVMInitializeARMTarget,
            LLVMInitializeAVRTarget,
            LLVMInitializeBPFTarget,
            LLVMInitializeHexagonTarget,
            LLVMInitializeLanaiTarget,
            LLVMInitializeLoongArchTarget,
            LLVMInitializeMipsTarget,
            LLVMInitializeMSP430Target,
            LLVMInitializeNVPTXTarget,
            LLVMInitializePowerPCTarget,
            LLVMInitializeRISCVTarget,
            LLVMInitializeSparcTarget,
            LLVMInitializeSystemZTarget,
            LLVMInitializeVETarget,
            LLVMInitializeWebAssemblyTarget,
            LLVMInitializeX86Target,
            LLVMInitializeXCoreTarget,
            LLVMInitializeAArch64TargetMC,
            LLVMInitializeAMDGPUTargetMC,
            LLVMInitializeARMTargetMC,
            LLVMInitializeAVRTargetMC,
            LLVMInitializeBPFTargetMC,
            LLVMInitializeHexagonTargetMC,
            LLVMInitializeLanaiTargetMC,
            LLVMInitializeLoongArchTargetMC,
            LLVMInitializeMipsTargetMC,
            LLVMInitializeMSP430TargetMC,
            LLVMInitializeNVPTXTargetMC,
            LLVMInitializePowerPCTargetMC,
            LLVMInitializeRISCVTargetMC,
            LLVMInitializeSparcTargetMC,
            LLVMInitializeSystemZTargetMC,
            LLVMInitializeVETargetMC,
            LLVMInitializeWebAssemblyTargetMC,
            LLVMInitializeX86TargetMC,
            LLVMInitializeXCoreTargetMC,
            LLVMInitializeAArch64AsmPrinter,
            LLVMInitializeAMDGPUAsmPrinter,
            LLVMInitializeARMAsmPrinter,
            LLVMInitializeAVRAsmPrinter,
            LLVMInitializeBPFAsmPrinter,
            LLVMInitializeHexagonAsmPrinter,
            LLVMInitializeLanaiAsmPrinter,
            LLVMInitializeLoongArchAsmPrinter,
            LLVMInitializeMipsAsmPrinter,
            LLVMInitializeMSP430AsmPrinter,
            LLVMInitializeNVPTXAsmPrinter,
            LLVMInitializePowerPCAsmPrinter,
            LLVMInitializeRISCVAsmPrinter,
            LLVMInitializeSparcAsmPrinter,
            LLVMInitializeSystemZAsmPrinter,
            LLVMInitializeVEAsmPrinter,
            LLVMInitializeWebAssemblyAsmPrinter,
            LLVMInitializeX86AsmPrinter,
            LLVMInitializeXCoreAsmPrinter,
            LLVMInitializeAArch64AsmParser,
            LLVMInitializeAMDGPUAsmParser,
            LLVMInitializeARMAsmParser,
            LLVMInitializeAVRAsmParser,
            LLVMInitializeBPFAsmParser,
            LLVMInitializeHexagonAsmParser,
            LLVMInitializeLanaiAsmParser,
            LLVMInitializeLoongArchAsmParser,
            LLVMInitializeMipsAsmParser,
            LLVMInitializeMSP430AsmParser,
            LLVMInitializePowerPCAsmParser,
            LLVMInitializeRISCVAsmParser,
            LLVMInitializeSparcAsmParser,
            LLVMInitializeSystemZAsmParser,
            LLVMInitializeVEAsmParser,
            LLVMInitializeWebAssemblyAsmParser,
            LLVMInitializeX86AsmParser,
            LLVMInitializeAArch64Disassembler,
            LLVMInitializeAMDGPUDisassembler,
            LLVMInitializeARMDisassembler,
            LLVMInitializeAVRDisassembler,
            LLVMInitializeBPFDisassembler,
            LLVMInitializeHexagonDisassembler,
            LLVMInitializeLanaiDisassembler,
            LLVMInitializeLoongArchDisassembler,
            LLVMInitializeMipsDisassembler,
            LLVMInitializeMSP430Disassembler,
            LLVMInitializePowerPCDisassembler,
            LLVMInitializeRISCVDisassembler,
            LLVMInitializeSparcDisassembler,
            LLVMInitializeSystemZDisassembler,
            LLVMInitializeVEDisassembler,
            LLVMInitializeWebAssemblyDisassembler,
            LLVMInitializeX86Disassembler,
            LLVMInitializeXCoreDisassembler,
            LLVMGetModuleDataLayout,
            LLVMSetModuleDataLayout,
            LLVMCreateTargetData,
            LLVMDisposeTargetData,
            LLVMAddTargetLibraryInfo,
            LLVMCopyStringRepOfTargetData,
            LLVMByteOrder,
            LLVMPointerSize,
            LLVMPointerSizeForAS,
            LLVMIntPtrType,
            LLVMIntPtrTypeForAS,
            LLVMIntPtrTypeInContext,
            LLVMIntPtrTypeForASInContext,
            LLVMSizeOfTypeInBits,
            LLVMStoreSizeOfType,
            LLVMABISizeOfType,
            LLVMABIAlignmentOfType,
            LLVMCallFrameAlignmentOfType,
            LLVMPreferredAlignmentOfType,
            LLVMPreferredAlignmentOfGlobal,
            LLVMElementAtOffset,
            LLVMOffsetOfElement,
            LLVMGetFirstTarget,
            LLVMGetNextTarget,
            LLVMGetTargetFromName,
            LLVMGetTargetFromTriple,
            LLVMGetTargetName,
            LLVMGetTargetDescription,
            LLVMTargetHasJIT,
            LLVMTargetHasTargetMachine,
            LLVMTargetHasAsmBackend,
            LLVMCreateTargetMachine,
            LLVMDisposeTargetMachine,
            LLVMGetTargetMachineTarget,
            LLVMGetTargetMachineTriple,
            LLVMGetTargetMachineCPU,
            LLVMGetTargetMachineFeatureString,
            LLVMCreateTargetDataLayout,
            LLVMSetTargetMachineAsmVerbosity,
            LLVMTargetMachineEmitToFile,
            LLVMTargetMachineEmitToMemoryBuffer,
            LLVMGetDefaultTargetTriple,
            LLVMNormalizeTargetTriple,
            LLVMGetHostCPUName,
            LLVMGetHostCPUFeatures,
            LLVMAddAnalysisPasses,
            LLVMLinkInMCJIT,
            LLVMLinkInInterpreter,
            LLVMCreateGenericValueOfInt,
            LLVMCreateGenericValueOfPointer,
            LLVMCreateGenericValueOfFloat,
            LLVMGenericValueIntWidth,
            LLVMGenericValueToInt,
            LLVMGenericValueToPointer,
            LLVMGenericValueToFloat,
            LLVMDisposeGenericValue,
            LLVMCreateExecutionEngineForModule,
            LLVMCreateInterpreterForModule,
            LLVMCreateJITCompilerForModule,
            LLVMInitializeMCJITCompilerOptions,
            LLVMCreateMCJITCompilerForModule,
            LLVMDisposeExecutionEngine,
            LLVMRunStaticConstructors,
            LLVMRunStaticDestructors,
            LLVMRunFunctionAsMain,
            LLVMRunFunction,
            LLVMFreeMachineCodeForFunction,
            LLVMAddModule,
            LLVMRemoveModule,
            LLVMFindFunction,
            LLVMRecompileAndRelinkFunction,
            LLVMGetExecutionEngineTargetData,
            LLVMGetExecutionEngineTargetMachine,
            LLVMAddGlobalMapping,
            LLVMGetPointerToGlobal,
            LLVMGetGlobalValueAddress,
            LLVMGetFunctionAddress,
            LLVMExecutionEngineGetErrMsg,
            LLVMCreateSimpleMCJITMemoryManager,
            LLVMDisposeMCJITMemoryManager,
            LLVMCreateGDBRegistrationListener,
            LLVMCreateIntelJITEventListener,
            LLVMCreateOProfileJITEventListener,
            LLVMCreatePerfJITEventListener,
            LLVMParseIRInContext,
            LLVMLinkModules2,
            LLVMOrcExecutionSessionSetErrorReporter,
            LLVMOrcExecutionSessionGetSymbolStringPool,
            LLVMOrcSymbolStringPoolClearDeadEntries,
            LLVMOrcExecutionSessionIntern,
            LLVMOrcExecutionSessionLookup,
            LLVMOrcRetainSymbolStringPoolEntry,
            LLVMOrcReleaseSymbolStringPoolEntry,
            LLVMOrcSymbolStringPoolEntryStr,
            LLVMOrcReleaseResourceTracker,
            LLVMOrcResourceTrackerTransferTo,
            LLVMOrcResourceTrackerRemove,
            LLVMOrcDisposeDefinitionGenerator,
            LLVMOrcDisposeMaterializationUnit,
            LLVMOrcCreateCustomMaterializationUnit,
            LLVMOrcAbsoluteSymbols,
            LLVMOrcLazyReexports,
            LLVMOrcDisposeMaterializationResponsibility,
            LLVMOrcMaterializationResponsibilityGetTargetDylib,
            LLVMOrcMaterializationResponsibilityGetExecutionSession,
            LLVMOrcMaterializationResponsibilityGetSymbols,
            LLVMOrcDisposeCSymbolFlagsMap,
            LLVMOrcMaterializationResponsibilityGetInitializerSymbol,
            LLVMOrcMaterializationResponsibilityGetRequestedSymbols,
            LLVMOrcDisposeSymbols,
            LLVMOrcMaterializationResponsibilityNotifyResolved,
            LLVMOrcMaterializationResponsibilityNotifyEmitted,
            LLVMOrcMaterializationResponsibilityDefineMaterializing,
            LLVMOrcMaterializationResponsibilityFailMaterialization,
            LLVMOrcMaterializationResponsibilityReplace,
            LLVMOrcMaterializationResponsibilityDelegate,
            LLVMOrcMaterializationResponsibilityAddDependencies,
            LLVMOrcMaterializationResponsibilityAddDependenciesForAll,
            LLVMOrcExecutionSessionCreateBareJITDylib,
            LLVMOrcExecutionSessionCreateJITDylib,
            LLVMOrcExecutionSessionGetJITDylibByName,
            LLVMOrcJITDylibCreateResourceTracker,
            LLVMOrcJITDylibGetDefaultResourceTracker,
            LLVMOrcJITDylibDefine,
            LLVMOrcJITDylibClear,
            LLVMOrcJITDylibAddGenerator,
            LLVMOrcCreateCustomCAPIDefinitionGenerator,
            LLVMOrcLookupStateContinueLookup,
            LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess,
            LLVMOrcCreateDynamicLibrarySearchGeneratorForPath,
            LLVMOrcCreateStaticLibrarySearchGeneratorForPath,
            LLVMOrcCreateNewThreadSafeContext,
            LLVMOrcThreadSafeContextGetContext,
            LLVMOrcDisposeThreadSafeContext,
            LLVMOrcCreateNewThreadSafeModule,
            LLVMOrcDisposeThreadSafeModule,
            LLVMOrcThreadSafeModuleWithModuleDo,
            LLVMOrcJITTargetMachineBuilderDetectHost,
            LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine,
            LLVMOrcDisposeJITTargetMachineBuilder,
            LLVMOrcJITTargetMachineBuilderGetTargetTriple,
            LLVMOrcJITTargetMachineBuilderSetTargetTriple,
            LLVMOrcObjectLayerAddObjectFile,
            LLVMOrcObjectLayerAddObjectFileWithRT,
            LLVMOrcObjectLayerEmit,
            LLVMOrcDisposeObjectLayer,
            LLVMOrcIRTransformLayerEmit,
            LLVMOrcIRTransformLayerSetTransform,
            LLVMOrcObjectTransformLayerSetTransform,
            LLVMOrcCreateLocalIndirectStubsManager,
            LLVMOrcDisposeIndirectStubsManager,
            LLVMOrcCreateLocalLazyCallThroughManager,
            LLVMOrcDisposeLazyCallThroughManager,
            LLVMOrcCreateDumpObjects,
            LLVMOrcDisposeDumpObjects,
            LLVMOrcDumpObjects_CallOperator,
            LLVMOrcCreateLLJITBuilder,
            LLVMOrcDisposeLLJITBuilder,
            LLVMOrcLLJITBuilderSetJITTargetMachineBuilder,
            LLVMOrcLLJITBuilderSetObjectLinkingLayerCreator,
            LLVMOrcCreateLLJIT,
            LLVMOrcDisposeLLJIT,
            LLVMOrcLLJITGetExecutionSession,
            LLVMOrcLLJITGetMainJITDylib,
            LLVMOrcLLJITGetTripleString,
            LLVMOrcLLJITGetGlobalPrefix,
            LLVMOrcLLJITMangleAndIntern,
            LLVMOrcLLJITAddObjectFile,
            LLVMOrcLLJITAddObjectFileWithRT,
            LLVMOrcLLJITAddLLVMIRModule,
            LLVMOrcLLJITAddLLVMIRModuleWithRT,
            LLVMOrcLLJITLookup,
            LLVMOrcLLJITGetObjLinkingLayer,
            LLVMOrcLLJITGetObjTransformLayer,
            LLVMOrcLLJITGetIRTransformLayer,
            LLVMOrcLLJITGetDataLayoutStr,
            LLVMCreateBinary,
            LLVMDisposeBinary,
            LLVMBinaryCopyMemoryBuffer,
            LLVMBinaryGetType,
            LLVMMachOUniversalBinaryCopyObjectForArch,
            LLVMObjectFileCopySectionIterator,
            LLVMObjectFileIsSectionIteratorAtEnd,
            LLVMObjectFileCopySymbolIterator,
            LLVMObjectFileIsSymbolIteratorAtEnd,
            LLVMDisposeSectionIterator,
            LLVMMoveToNextSection,
            LLVMMoveToContainingSection,
            LLVMDisposeSymbolIterator,
            LLVMMoveToNextSymbol,
            LLVMGetSectionName,
            LLVMGetSectionSize,
            LLVMGetSectionContents,
            LLVMGetSectionAddress,
            LLVMGetSectionContainsSymbol,
            LLVMGetRelocations,
            LLVMDisposeRelocationIterator,
            LLVMIsRelocationIteratorAtEnd,
            LLVMMoveToNextRelocation,
            LLVMGetSymbolName,
            LLVMGetSymbolAddress,
            LLVMGetSymbolSize,
            LLVMGetRelocationOffset,
            LLVMGetRelocationSymbol,
            LLVMGetRelocationType,
            LLVMGetRelocationTypeName,
            LLVMGetRelocationValueString,
            LLVMCreateObjectFile,
            LLVMDisposeObjectFile,
            LLVMGetSections,
            LLVMIsSectionIteratorAtEnd,
            LLVMGetSymbols,
            LLVMIsSymbolIteratorAtEnd,
            LLVMOrcCreateRTDyldObjectLinkingLayerWithSectionMemoryManager,
            LLVMOrcCreateRTDyldObjectLinkingLayerWithMCJITMemoryManagerLikeCallbacks,
            LLVMOrcRTDyldObjectLinkingLayerRegisterJITEventListener,
            LLVMRemarkStringGetData,
            LLVMRemarkStringGetLen,
            LLVMRemarkDebugLocGetSourceFilePath,
            LLVMRemarkDebugLocGetSourceLine,
            LLVMRemarkDebugLocGetSourceColumn,
            LLVMRemarkArgGetKey,
            LLVMRemarkArgGetValue,
            LLVMRemarkArgGetDebugLoc,
            LLVMRemarkEntryDispose,
            LLVMRemarkEntryGetType,
            LLVMRemarkEntryGetPassName,
            LLVMRemarkEntryGetRemarkName,
            LLVMRemarkEntryGetFunctionName,
            LLVMRemarkEntryGetDebugLoc,
            LLVMRemarkEntryGetHotness,
            LLVMRemarkEntryGetNumArgs,
            LLVMRemarkEntryGetFirstArg,
            LLVMRemarkEntryGetNextArg,
            LLVMRemarkParserCreateYAML,
            LLVMRemarkParserCreateBitstream,
            LLVMRemarkParserGetNext,
            LLVMRemarkParserHasError,
            LLVMRemarkParserGetErrorMessage,
            LLVMRemarkParserDispose,
            LLVMRemarkVersion,
            LLVMLoadLibraryPermanently,
            LLVMParseCommandLineOptions,
            LLVMSearchForAddressOfSymbol,
            LLVMAddSymbol,
        })
    }
    pub unsafe fn LLVMVerifyModule(
        &self,
        M: LLVMModuleRef,
        Action: LLVMVerifierFailureAction,
        OutMessage: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMVerifyModule
            .as_ref()
            .expect("Expected function, got error."))(M, Action, OutMessage)
    }
    pub unsafe fn LLVMVerifyFunction(
        &self,
        Fn: LLVMValueRef,
        Action: LLVMVerifierFailureAction,
    ) -> LLVMBool {
        (self
            .LLVMVerifyFunction
            .as_ref()
            .expect("Expected function, got error."))(Fn, Action)
    }
    pub unsafe fn LLVMViewFunctionCFG(&self, Fn: LLVMValueRef) {
        (self
            .LLVMViewFunctionCFG
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    pub unsafe fn LLVMViewFunctionCFGOnly(&self, Fn: LLVMValueRef) {
        (self
            .LLVMViewFunctionCFGOnly
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " @defgroup LLVMCBitReader Bit Reader\n @ingroup LLVMC\n\n @{"]
    pub unsafe fn LLVMParseBitcode(
        &self,
        MemBuf: LLVMMemoryBufferRef,
        OutModule: *mut LLVMModuleRef,
        OutMessage: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMParseBitcode
            .as_ref()
            .expect("Expected function, got error."))(MemBuf, OutModule, OutMessage)
    }
    pub unsafe fn LLVMParseBitcode2(
        &self,
        MemBuf: LLVMMemoryBufferRef,
        OutModule: *mut LLVMModuleRef,
    ) -> LLVMBool {
        (self
            .LLVMParseBitcode2
            .as_ref()
            .expect("Expected function, got error."))(MemBuf, OutModule)
    }
    pub unsafe fn LLVMParseBitcodeInContext(
        &self,
        ContextRef: LLVMContextRef,
        MemBuf: LLVMMemoryBufferRef,
        OutModule: *mut LLVMModuleRef,
        OutMessage: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMParseBitcodeInContext
            .as_ref()
            .expect("Expected function, got error."))(
            ContextRef, MemBuf, OutModule, OutMessage
        )
    }
    pub unsafe fn LLVMParseBitcodeInContext2(
        &self,
        ContextRef: LLVMContextRef,
        MemBuf: LLVMMemoryBufferRef,
        OutModule: *mut LLVMModuleRef,
    ) -> LLVMBool {
        (self
            .LLVMParseBitcodeInContext2
            .as_ref()
            .expect("Expected function, got error."))(ContextRef, MemBuf, OutModule)
    }
    #[doc = " Reads a module from the specified path, returning via the OutMP parameter\na module provider which performs lazy deserialization. Returns 0 on success.\nOptionally returns a human-readable error message via OutMessage.\nThis is deprecated. Use LLVMGetBitcodeModuleInContext2."]
    pub unsafe fn LLVMGetBitcodeModuleInContext(
        &self,
        ContextRef: LLVMContextRef,
        MemBuf: LLVMMemoryBufferRef,
        OutM: *mut LLVMModuleRef,
        OutMessage: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMGetBitcodeModuleInContext
            .as_ref()
            .expect("Expected function, got error."))(ContextRef, MemBuf, OutM, OutMessage)
    }
    #[doc = " Reads a module from the given memory buffer, returning via the OutMP\n parameter a module provider which performs lazy deserialization.\n\n Returns 0 on success.\n\n Takes ownership of \\p MemBuf if (and only if) the module was read\n successfully."]
    pub unsafe fn LLVMGetBitcodeModuleInContext2(
        &self,
        ContextRef: LLVMContextRef,
        MemBuf: LLVMMemoryBufferRef,
        OutM: *mut LLVMModuleRef,
    ) -> LLVMBool {
        (self
            .LLVMGetBitcodeModuleInContext2
            .as_ref()
            .expect("Expected function, got error."))(ContextRef, MemBuf, OutM)
    }
    pub unsafe fn LLVMGetBitcodeModule(
        &self,
        MemBuf: LLVMMemoryBufferRef,
        OutM: *mut LLVMModuleRef,
        OutMessage: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMGetBitcodeModule
            .as_ref()
            .expect("Expected function, got error."))(MemBuf, OutM, OutMessage)
    }
    pub unsafe fn LLVMGetBitcodeModule2(
        &self,
        MemBuf: LLVMMemoryBufferRef,
        OutM: *mut LLVMModuleRef,
    ) -> LLVMBool {
        (self
            .LLVMGetBitcodeModule2
            .as_ref()
            .expect("Expected function, got error."))(MemBuf, OutM)
    }
    #[doc = " Writes a module to the specified path. Returns 0 on success."]
    pub unsafe fn LLVMWriteBitcodeToFile(
        &self,
        M: LLVMModuleRef,
        Path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            .LLVMWriteBitcodeToFile
            .as_ref()
            .expect("Expected function, got error."))(M, Path)
    }
    #[doc = " Writes a module to an open file descriptor. Returns 0 on success."]
    pub unsafe fn LLVMWriteBitcodeToFD(
        &self,
        M: LLVMModuleRef,
        FD: ::std::os::raw::c_int,
        ShouldClose: ::std::os::raw::c_int,
        Unbuffered: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .LLVMWriteBitcodeToFD
            .as_ref()
            .expect("Expected function, got error."))(M, FD, ShouldClose, Unbuffered)
    }
    #[doc = " Deprecated for LLVMWriteBitcodeToFD. Writes a module to an open file\ndescriptor. Returns 0 on success. Closes the Handle."]
    pub unsafe fn LLVMWriteBitcodeToFileHandle(
        &self,
        M: LLVMModuleRef,
        Handle: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self
            .LLVMWriteBitcodeToFileHandle
            .as_ref()
            .expect("Expected function, got error."))(M, Handle)
    }
    #[doc = " Writes a module to a new memory buffer and returns it."]
    pub unsafe fn LLVMWriteBitcodeToMemoryBuffer(&self, M: LLVMModuleRef) -> LLVMMemoryBufferRef {
        (self
            .LLVMWriteBitcodeToMemoryBuffer
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Return the Comdat in the module with the specified name. It is created\n if it didn't already exist.\n\n @see llvm::Module::getOrInsertComdat()"]
    pub unsafe fn LLVMGetOrInsertComdat(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMComdatRef {
        (self
            .LLVMGetOrInsertComdat
            .as_ref()
            .expect("Expected function, got error."))(M, Name)
    }
    #[doc = " Get the Comdat assigned to the given global object.\n\n @see llvm::GlobalObject::getComdat()"]
    pub unsafe fn LLVMGetComdat(&self, V: LLVMValueRef) -> LLVMComdatRef {
        (self
            .LLVMGetComdat
            .as_ref()
            .expect("Expected function, got error."))(V)
    }
    #[doc = " Assign the Comdat to the given global object.\n\n @see llvm::GlobalObject::setComdat()"]
    pub unsafe fn LLVMSetComdat(&self, V: LLVMValueRef, C: LLVMComdatRef) {
        (self
            .LLVMSetComdat
            .as_ref()
            .expect("Expected function, got error."))(V, C)
    }
    pub unsafe fn LLVMGetComdatSelectionKind(&self, C: LLVMComdatRef) -> LLVMComdatSelectionKind {
        (self
            .LLVMGetComdatSelectionKind
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    pub unsafe fn LLVMSetComdatSelectionKind(
        &self,
        C: LLVMComdatRef,
        Kind: LLVMComdatSelectionKind,
    ) {
        (self
            .LLVMSetComdatSelectionKind
            .as_ref()
            .expect("Expected function, got error."))(C, Kind)
    }
    #[doc = " Install a fatal error handler. By default, if LLVM detects a fatal error, it\n will call exit(1). This may not be appropriate in many contexts. For example,\n doing exit(1) will bypass many crash reporting/tracing system tools. This\n function allows you to install a callback that will be invoked prior to the\n call to exit(1)."]
    pub unsafe fn LLVMInstallFatalErrorHandler(&self, Handler: LLVMFatalErrorHandler) {
        (self
            .LLVMInstallFatalErrorHandler
            .as_ref()
            .expect("Expected function, got error."))(Handler)
    }
    #[doc = " Reset the fatal error handler. This resets LLVM's fatal error handling\n behavior to the default."]
    pub unsafe fn LLVMResetFatalErrorHandler(&self) {
        (self
            .LLVMResetFatalErrorHandler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Enable LLVM's built-in stack trace code. This intercepts the OS's crash\n signals and prints which component of LLVM you were in at the time if the\n crash."]
    pub unsafe fn LLVMEnablePrettyStackTrace(&self) {
        (self
            .LLVMEnablePrettyStackTrace
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Deallocate and destroy all ManagedStatic variables.\n@see llvm::llvm_shutdown\n@see ManagedStatic"]
    pub unsafe fn LLVMShutdown(&self) {
        (self
            .LLVMShutdown
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Return the major, minor, and patch version of LLVM\n\n The version components are returned via the function's three output\n parameters or skipped if a NULL pointer was supplied."]
    pub unsafe fn LLVMGetVersion(
        &self,
        Major: *mut ::std::os::raw::c_uint,
        Minor: *mut ::std::os::raw::c_uint,
        Patch: *mut ::std::os::raw::c_uint,
    ) {
        (self
            .LLVMGetVersion
            .as_ref()
            .expect("Expected function, got error."))(Major, Minor, Patch)
    }
    pub unsafe fn LLVMCreateMessage(
        &self,
        Message: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMCreateMessage
            .as_ref()
            .expect("Expected function, got error."))(Message)
    }
    pub unsafe fn LLVMDisposeMessage(&self, Message: *mut ::std::os::raw::c_char) {
        (self
            .LLVMDisposeMessage
            .as_ref()
            .expect("Expected function, got error."))(Message)
    }
    #[doc = " Create a new context.\n\n Every call to this function should be paired with a call to\n LLVMContextDispose() or the context will leak memory."]
    pub unsafe fn LLVMContextCreate(&self) -> LLVMContextRef {
        (self
            .LLVMContextCreate
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Obtain the global context instance."]
    pub unsafe fn LLVMGetGlobalContext(&self) -> LLVMContextRef {
        (self
            .LLVMGetGlobalContext
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Set the diagnostic handler for this context."]
    pub unsafe fn LLVMContextSetDiagnosticHandler(
        &self,
        C: LLVMContextRef,
        Handler: LLVMDiagnosticHandler,
        DiagnosticContext: *mut ::std::os::raw::c_void,
    ) {
        (self
            .LLVMContextSetDiagnosticHandler
            .as_ref()
            .expect("Expected function, got error."))(C, Handler, DiagnosticContext)
    }
    #[doc = " Get the diagnostic handler of this context."]
    pub unsafe fn LLVMContextGetDiagnosticHandler(
        &self,
        C: LLVMContextRef,
    ) -> LLVMDiagnosticHandler {
        (self
            .LLVMContextGetDiagnosticHandler
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Get the diagnostic context of this context."]
    pub unsafe fn LLVMContextGetDiagnosticContext(
        &self,
        C: LLVMContextRef,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .LLVMContextGetDiagnosticContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Set the yield callback function for this context.\n\n @see LLVMContext::setYieldCallback()"]
    pub unsafe fn LLVMContextSetYieldCallback(
        &self,
        C: LLVMContextRef,
        Callback: LLVMYieldCallback,
        OpaqueHandle: *mut ::std::os::raw::c_void,
    ) {
        (self
            .LLVMContextSetYieldCallback
            .as_ref()
            .expect("Expected function, got error."))(C, Callback, OpaqueHandle)
    }
    #[doc = " Retrieve whether the given context is set to discard all value names.\n\n @see LLVMContext::shouldDiscardValueNames()"]
    pub unsafe fn LLVMContextShouldDiscardValueNames(&self, C: LLVMContextRef) -> LLVMBool {
        (self
            .LLVMContextShouldDiscardValueNames
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Set whether the given context discards all value names.\n\n If true, only the names of GlobalValue objects will be available in the IR.\n This can be used to save memory and runtime, especially in release mode.\n\n @see LLVMContext::setDiscardValueNames()"]
    pub unsafe fn LLVMContextSetDiscardValueNames(&self, C: LLVMContextRef, Discard: LLVMBool) {
        (self
            .LLVMContextSetDiscardValueNames
            .as_ref()
            .expect("Expected function, got error."))(C, Discard)
    }
    #[doc = " Destroy a context instance.\n\n This should be called for every call to LLVMContextCreate() or memory\n will be leaked."]
    pub unsafe fn LLVMContextDispose(&self, C: LLVMContextRef) {
        (self
            .LLVMContextDispose
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Return a string representation of the DiagnosticInfo. Use\n LLVMDisposeMessage to free the string.\n\n @see DiagnosticInfo::print()"]
    pub unsafe fn LLVMGetDiagInfoDescription(
        &self,
        DI: LLVMDiagnosticInfoRef,
    ) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMGetDiagInfoDescription
            .as_ref()
            .expect("Expected function, got error."))(DI)
    }
    #[doc = " Return an enum LLVMDiagnosticSeverity.\n\n @see DiagnosticInfo::getSeverity()"]
    pub unsafe fn LLVMGetDiagInfoSeverity(
        &self,
        DI: LLVMDiagnosticInfoRef,
    ) -> LLVMDiagnosticSeverity {
        (self
            .LLVMGetDiagInfoSeverity
            .as_ref()
            .expect("Expected function, got error."))(DI)
    }
    pub unsafe fn LLVMGetMDKindIDInContext(
        &self,
        C: LLVMContextRef,
        Name: *const ::std::os::raw::c_char,
        SLen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetMDKindIDInContext
            .as_ref()
            .expect("Expected function, got error."))(C, Name, SLen)
    }
    pub unsafe fn LLVMGetMDKindID(
        &self,
        Name: *const ::std::os::raw::c_char,
        SLen: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetMDKindID
            .as_ref()
            .expect("Expected function, got error."))(Name, SLen)
    }
    #[doc = " Return an unique id given the name of a enum attribute,\n or 0 if no attribute by that name exists.\n\n See http://llvm.org/docs/LangRef.html#parameter-attributes\n and http://llvm.org/docs/LangRef.html#function-attributes\n for the list of available attributes.\n\n NB: Attribute names and/or id are subject to change without\n going through the C API deprecation cycle."]
    pub unsafe fn LLVMGetEnumAttributeKindForName(
        &self,
        Name: *const ::std::os::raw::c_char,
        SLen: usize,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetEnumAttributeKindForName
            .as_ref()
            .expect("Expected function, got error."))(Name, SLen)
    }
    pub unsafe fn LLVMGetLastEnumAttributeKind(&self) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetLastEnumAttributeKind
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Create an enum attribute."]
    pub unsafe fn LLVMCreateEnumAttribute(
        &self,
        C: LLVMContextRef,
        KindID: ::std::os::raw::c_uint,
        Val: u64,
    ) -> LLVMAttributeRef {
        (self
            .LLVMCreateEnumAttribute
            .as_ref()
            .expect("Expected function, got error."))(C, KindID, Val)
    }
    #[doc = " Get the unique id corresponding to the enum attribute\n passed as argument."]
    pub unsafe fn LLVMGetEnumAttributeKind(&self, A: LLVMAttributeRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetEnumAttributeKind
            .as_ref()
            .expect("Expected function, got error."))(A)
    }
    #[doc = " Get the enum attribute's value. 0 is returned if none exists."]
    pub unsafe fn LLVMGetEnumAttributeValue(&self, A: LLVMAttributeRef) -> u64 {
        (self
            .LLVMGetEnumAttributeValue
            .as_ref()
            .expect("Expected function, got error."))(A)
    }
    #[doc = " Create a type attribute"]
    pub unsafe fn LLVMCreateTypeAttribute(
        &self,
        C: LLVMContextRef,
        KindID: ::std::os::raw::c_uint,
        type_ref: LLVMTypeRef,
    ) -> LLVMAttributeRef {
        (self
            .LLVMCreateTypeAttribute
            .as_ref()
            .expect("Expected function, got error."))(C, KindID, type_ref)
    }
    #[doc = " Get the type attribute's value."]
    pub unsafe fn LLVMGetTypeAttributeValue(&self, A: LLVMAttributeRef) -> LLVMTypeRef {
        (self
            .LLVMGetTypeAttributeValue
            .as_ref()
            .expect("Expected function, got error."))(A)
    }
    #[doc = " Create a string attribute."]
    pub unsafe fn LLVMCreateStringAttribute(
        &self,
        C: LLVMContextRef,
        K: *const ::std::os::raw::c_char,
        KLength: ::std::os::raw::c_uint,
        V: *const ::std::os::raw::c_char,
        VLength: ::std::os::raw::c_uint,
    ) -> LLVMAttributeRef {
        (self
            .LLVMCreateStringAttribute
            .as_ref()
            .expect("Expected function, got error."))(C, K, KLength, V, VLength)
    }
    #[doc = " Get the string attribute's kind."]
    pub unsafe fn LLVMGetStringAttributeKind(
        &self,
        A: LLVMAttributeRef,
        Length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetStringAttributeKind
            .as_ref()
            .expect("Expected function, got error."))(A, Length)
    }
    #[doc = " Get the string attribute's value."]
    pub unsafe fn LLVMGetStringAttributeValue(
        &self,
        A: LLVMAttributeRef,
        Length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetStringAttributeValue
            .as_ref()
            .expect("Expected function, got error."))(A, Length)
    }
    #[doc = " Check for the different types of attributes."]
    pub unsafe fn LLVMIsEnumAttribute(&self, A: LLVMAttributeRef) -> LLVMBool {
        (self
            .LLVMIsEnumAttribute
            .as_ref()
            .expect("Expected function, got error."))(A)
    }
    pub unsafe fn LLVMIsStringAttribute(&self, A: LLVMAttributeRef) -> LLVMBool {
        (self
            .LLVMIsStringAttribute
            .as_ref()
            .expect("Expected function, got error."))(A)
    }
    pub unsafe fn LLVMIsTypeAttribute(&self, A: LLVMAttributeRef) -> LLVMBool {
        (self
            .LLVMIsTypeAttribute
            .as_ref()
            .expect("Expected function, got error."))(A)
    }
    #[doc = " Obtain a Type from a context by its registered name."]
    pub unsafe fn LLVMGetTypeByName2(
        &self,
        C: LLVMContextRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMTypeRef {
        (self
            .LLVMGetTypeByName2
            .as_ref()
            .expect("Expected function, got error."))(C, Name)
    }
    #[doc = " Create a new, empty module in the global context.\n\n This is equivalent to calling LLVMModuleCreateWithNameInContext with\n LLVMGetGlobalContext() as the context parameter.\n\n Every invocation should be paired with LLVMDisposeModule() or memory\n will be leaked."]
    pub unsafe fn LLVMModuleCreateWithName(
        &self,
        ModuleID: *const ::std::os::raw::c_char,
    ) -> LLVMModuleRef {
        (self
            .LLVMModuleCreateWithName
            .as_ref()
            .expect("Expected function, got error."))(ModuleID)
    }
    #[doc = " Create a new, empty module in a specific context.\n\n Every invocation should be paired with LLVMDisposeModule() or memory\n will be leaked."]
    pub unsafe fn LLVMModuleCreateWithNameInContext(
        &self,
        ModuleID: *const ::std::os::raw::c_char,
        C: LLVMContextRef,
    ) -> LLVMModuleRef {
        (self
            .LLVMModuleCreateWithNameInContext
            .as_ref()
            .expect("Expected function, got error."))(ModuleID, C)
    }
    #[doc = " Return an exact copy of the specified module."]
    pub unsafe fn LLVMCloneModule(&self, M: LLVMModuleRef) -> LLVMModuleRef {
        (self
            .LLVMCloneModule
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Destroy a module instance.\n\n This must be called for every created module or memory will be\n leaked."]
    pub unsafe fn LLVMDisposeModule(&self, M: LLVMModuleRef) {
        (self
            .LLVMDisposeModule
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Obtain the identifier of a module.\n\n @param M Module to obtain identifier of\n @param Len Out parameter which holds the length of the returned string.\n @return The identifier of M.\n @see Module::getModuleIdentifier()"]
    pub unsafe fn LLVMGetModuleIdentifier(
        &self,
        M: LLVMModuleRef,
        Len: *mut usize,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetModuleIdentifier
            .as_ref()
            .expect("Expected function, got error."))(M, Len)
    }
    #[doc = " Set the identifier of a module to a string Ident with length Len.\n\n @param M The module to set identifier\n @param Ident The string to set M's identifier to\n @param Len Length of Ident\n @see Module::setModuleIdentifier()"]
    pub unsafe fn LLVMSetModuleIdentifier(
        &self,
        M: LLVMModuleRef,
        Ident: *const ::std::os::raw::c_char,
        Len: usize,
    ) {
        (self
            .LLVMSetModuleIdentifier
            .as_ref()
            .expect("Expected function, got error."))(M, Ident, Len)
    }
    #[doc = " Obtain the module's original source file name.\n\n @param M Module to obtain the name of\n @param Len Out parameter which holds the length of the returned string\n @return The original source file name of M\n @see Module::getSourceFileName()"]
    pub unsafe fn LLVMGetSourceFileName(
        &self,
        M: LLVMModuleRef,
        Len: *mut usize,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetSourceFileName
            .as_ref()
            .expect("Expected function, got error."))(M, Len)
    }
    #[doc = " Set the original source file name of a module to a string Name with length\n Len.\n\n @param M The module to set the source file name of\n @param Name The string to set M's source file name to\n @param Len Length of Name\n @see Module::setSourceFileName()"]
    pub unsafe fn LLVMSetSourceFileName(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
        Len: usize,
    ) {
        (self
            .LLVMSetSourceFileName
            .as_ref()
            .expect("Expected function, got error."))(M, Name, Len)
    }
    #[doc = " Obtain the data layout for a module.\n\n @see Module::getDataLayoutStr()\n\n LLVMGetDataLayout is DEPRECATED, as the name is not only incorrect,\n but match the name of another method on the module. Prefer the use\n of LLVMGetDataLayoutStr, which is not ambiguous."]
    pub unsafe fn LLVMGetDataLayoutStr(&self, M: LLVMModuleRef) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetDataLayoutStr
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    pub unsafe fn LLVMGetDataLayout(&self, M: LLVMModuleRef) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetDataLayout
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Set the data layout for a module.\n\n @see Module::setDataLayout()"]
    pub unsafe fn LLVMSetDataLayout(
        &self,
        M: LLVMModuleRef,
        DataLayoutStr: *const ::std::os::raw::c_char,
    ) {
        (self
            .LLVMSetDataLayout
            .as_ref()
            .expect("Expected function, got error."))(M, DataLayoutStr)
    }
    #[doc = " Obtain the target triple for a module.\n\n @see Module::getTargetTriple()"]
    pub unsafe fn LLVMGetTarget(&self, M: LLVMModuleRef) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetTarget
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Set the target triple for a module.\n\n @see Module::setTargetTriple()"]
    pub unsafe fn LLVMSetTarget(&self, M: LLVMModuleRef, Triple: *const ::std::os::raw::c_char) {
        (self
            .LLVMSetTarget
            .as_ref()
            .expect("Expected function, got error."))(M, Triple)
    }
    #[doc = " Returns the module flags as an array of flag-key-value triples.  The caller\n is responsible for freeing this array by calling\n \\c LLVMDisposeModuleFlagsMetadata.\n\n @see Module::getModuleFlagsMetadata()"]
    pub unsafe fn LLVMCopyModuleFlagsMetadata(
        &self,
        M: LLVMModuleRef,
        Len: *mut usize,
    ) -> *mut LLVMModuleFlagEntry {
        (self
            .LLVMCopyModuleFlagsMetadata
            .as_ref()
            .expect("Expected function, got error."))(M, Len)
    }
    #[doc = " Destroys module flags metadata entries."]
    pub unsafe fn LLVMDisposeModuleFlagsMetadata(&self, Entries: *mut LLVMModuleFlagEntry) {
        (self
            .LLVMDisposeModuleFlagsMetadata
            .as_ref()
            .expect("Expected function, got error."))(Entries)
    }
    #[doc = " Returns the flag behavior for a module flag entry at a specific index.\n\n @see Module::ModuleFlagEntry::Behavior"]
    pub unsafe fn LLVMModuleFlagEntriesGetFlagBehavior(
        &self,
        Entries: *mut LLVMModuleFlagEntry,
        Index: ::std::os::raw::c_uint,
    ) -> LLVMModuleFlagBehavior {
        (self
            .LLVMModuleFlagEntriesGetFlagBehavior
            .as_ref()
            .expect("Expected function, got error."))(Entries, Index)
    }
    #[doc = " Returns the key for a module flag entry at a specific index.\n\n @see Module::ModuleFlagEntry::Key"]
    pub unsafe fn LLVMModuleFlagEntriesGetKey(
        &self,
        Entries: *mut LLVMModuleFlagEntry,
        Index: ::std::os::raw::c_uint,
        Len: *mut usize,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMModuleFlagEntriesGetKey
            .as_ref()
            .expect("Expected function, got error."))(Entries, Index, Len)
    }
    #[doc = " Returns the metadata for a module flag entry at a specific index.\n\n @see Module::ModuleFlagEntry::Val"]
    pub unsafe fn LLVMModuleFlagEntriesGetMetadata(
        &self,
        Entries: *mut LLVMModuleFlagEntry,
        Index: ::std::os::raw::c_uint,
    ) -> LLVMMetadataRef {
        (self
            .LLVMModuleFlagEntriesGetMetadata
            .as_ref()
            .expect("Expected function, got error."))(Entries, Index)
    }
    #[doc = " Add a module-level flag to the module-level flags metadata if it doesn't\n already exist.\n\n @see Module::getModuleFlag()"]
    pub unsafe fn LLVMGetModuleFlag(
        &self,
        M: LLVMModuleRef,
        Key: *const ::std::os::raw::c_char,
        KeyLen: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMGetModuleFlag
            .as_ref()
            .expect("Expected function, got error."))(M, Key, KeyLen)
    }
    #[doc = " Add a module-level flag to the module-level flags metadata if it doesn't\n already exist.\n\n @see Module::addModuleFlag()"]
    pub unsafe fn LLVMAddModuleFlag(
        &self,
        M: LLVMModuleRef,
        Behavior: LLVMModuleFlagBehavior,
        Key: *const ::std::os::raw::c_char,
        KeyLen: usize,
        Val: LLVMMetadataRef,
    ) {
        (self
            .LLVMAddModuleFlag
            .as_ref()
            .expect("Expected function, got error."))(M, Behavior, Key, KeyLen, Val)
    }
    #[doc = " Dump a representation of a module to stderr.\n\n @see Module::dump()"]
    pub unsafe fn LLVMDumpModule(&self, M: LLVMModuleRef) {
        (self
            .LLVMDumpModule
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Print a representation of a module to a file. The ErrorMessage needs to be\n disposed with LLVMDisposeMessage. Returns 0 on success, 1 otherwise.\n\n @see Module::print()"]
    pub unsafe fn LLVMPrintModuleToFile(
        &self,
        M: LLVMModuleRef,
        Filename: *const ::std::os::raw::c_char,
        ErrorMessage: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMPrintModuleToFile
            .as_ref()
            .expect("Expected function, got error."))(M, Filename, ErrorMessage)
    }
    #[doc = " Return a string representation of the module. Use\n LLVMDisposeMessage to free the string.\n\n @see Module::print()"]
    pub unsafe fn LLVMPrintModuleToString(&self, M: LLVMModuleRef) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMPrintModuleToString
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Get inline assembly for a module.\n\n @see Module::getModuleInlineAsm()"]
    pub unsafe fn LLVMGetModuleInlineAsm(
        &self,
        M: LLVMModuleRef,
        Len: *mut usize,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetModuleInlineAsm
            .as_ref()
            .expect("Expected function, got error."))(M, Len)
    }
    #[doc = " Set inline assembly for a module.\n\n @see Module::setModuleInlineAsm()"]
    pub unsafe fn LLVMSetModuleInlineAsm2(
        &self,
        M: LLVMModuleRef,
        Asm: *const ::std::os::raw::c_char,
        Len: usize,
    ) {
        (self
            .LLVMSetModuleInlineAsm2
            .as_ref()
            .expect("Expected function, got error."))(M, Asm, Len)
    }
    #[doc = " Append inline assembly to a module.\n\n @see Module::appendModuleInlineAsm()"]
    pub unsafe fn LLVMAppendModuleInlineAsm(
        &self,
        M: LLVMModuleRef,
        Asm: *const ::std::os::raw::c_char,
        Len: usize,
    ) {
        (self
            .LLVMAppendModuleInlineAsm
            .as_ref()
            .expect("Expected function, got error."))(M, Asm, Len)
    }
    #[doc = " Create the specified uniqued inline asm string.\n\n @see InlineAsm::get()"]
    pub unsafe fn LLVMGetInlineAsm(
        &self,
        Ty: LLVMTypeRef,
        AsmString: *mut ::std::os::raw::c_char,
        AsmStringSize: usize,
        Constraints: *mut ::std::os::raw::c_char,
        ConstraintsSize: usize,
        HasSideEffects: LLVMBool,
        IsAlignStack: LLVMBool,
        Dialect: LLVMInlineAsmDialect,
        CanThrow: LLVMBool,
    ) -> LLVMValueRef {
        (self
            .LLVMGetInlineAsm
            .as_ref()
            .expect("Expected function, got error."))(
            Ty,
            AsmString,
            AsmStringSize,
            Constraints,
            ConstraintsSize,
            HasSideEffects,
            IsAlignStack,
            Dialect,
            CanThrow,
        )
    }
    #[doc = " Obtain the context to which this module is associated.\n\n @see Module::getContext()"]
    pub unsafe fn LLVMGetModuleContext(&self, M: LLVMModuleRef) -> LLVMContextRef {
        (self
            .LLVMGetModuleContext
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Deprecated: Use LLVMGetTypeByName2 instead."]
    pub unsafe fn LLVMGetTypeByName(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMTypeRef {
        (self
            .LLVMGetTypeByName
            .as_ref()
            .expect("Expected function, got error."))(M, Name)
    }
    #[doc = " Obtain an iterator to the first NamedMDNode in a Module.\n\n @see llvm::Module::named_metadata_begin()"]
    pub unsafe fn LLVMGetFirstNamedMetadata(&self, M: LLVMModuleRef) -> LLVMNamedMDNodeRef {
        (self
            .LLVMGetFirstNamedMetadata
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Obtain an iterator to the last NamedMDNode in a Module.\n\n @see llvm::Module::named_metadata_end()"]
    pub unsafe fn LLVMGetLastNamedMetadata(&self, M: LLVMModuleRef) -> LLVMNamedMDNodeRef {
        (self
            .LLVMGetLastNamedMetadata
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Advance a NamedMDNode iterator to the next NamedMDNode.\n\n Returns NULL if the iterator was already at the end and there are no more\n named metadata nodes."]
    pub unsafe fn LLVMGetNextNamedMetadata(
        &self,
        NamedMDNode: LLVMNamedMDNodeRef,
    ) -> LLVMNamedMDNodeRef {
        (self
            .LLVMGetNextNamedMetadata
            .as_ref()
            .expect("Expected function, got error."))(NamedMDNode)
    }
    #[doc = " Decrement a NamedMDNode iterator to the previous NamedMDNode.\n\n Returns NULL if the iterator was already at the beginning and there are\n no previous named metadata nodes."]
    pub unsafe fn LLVMGetPreviousNamedMetadata(
        &self,
        NamedMDNode: LLVMNamedMDNodeRef,
    ) -> LLVMNamedMDNodeRef {
        (self
            .LLVMGetPreviousNamedMetadata
            .as_ref()
            .expect("Expected function, got error."))(NamedMDNode)
    }
    #[doc = " Retrieve a NamedMDNode with the given name, returning NULL if no such\n node exists.\n\n @see llvm::Module::getNamedMetadata()"]
    pub unsafe fn LLVMGetNamedMetadata(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
    ) -> LLVMNamedMDNodeRef {
        (self
            .LLVMGetNamedMetadata
            .as_ref()
            .expect("Expected function, got error."))(M, Name, NameLen)
    }
    #[doc = " Retrieve a NamedMDNode with the given name, creating a new node if no such\n node exists.\n\n @see llvm::Module::getOrInsertNamedMetadata()"]
    pub unsafe fn LLVMGetOrInsertNamedMetadata(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
    ) -> LLVMNamedMDNodeRef {
        (self
            .LLVMGetOrInsertNamedMetadata
            .as_ref()
            .expect("Expected function, got error."))(M, Name, NameLen)
    }
    #[doc = " Retrieve the name of a NamedMDNode.\n\n @see llvm::NamedMDNode::getName()"]
    pub unsafe fn LLVMGetNamedMetadataName(
        &self,
        NamedMD: LLVMNamedMDNodeRef,
        NameLen: *mut usize,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetNamedMetadataName
            .as_ref()
            .expect("Expected function, got error."))(NamedMD, NameLen)
    }
    #[doc = " Obtain the number of operands for named metadata in a module.\n\n @see llvm::Module::getNamedMetadata()"]
    pub unsafe fn LLVMGetNamedMetadataNumOperands(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetNamedMetadataNumOperands
            .as_ref()
            .expect("Expected function, got error."))(M, Name)
    }
    #[doc = " Obtain the named metadata operands for a module.\n\n The passed LLVMValueRef pointer should refer to an array of\n LLVMValueRef at least LLVMGetNamedMetadataNumOperands long. This\n array will be populated with the LLVMValueRef instances. Each\n instance corresponds to a llvm::MDNode.\n\n @see llvm::Module::getNamedMetadata()\n @see llvm::MDNode::getOperand()"]
    pub unsafe fn LLVMGetNamedMetadataOperands(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
        Dest: *mut LLVMValueRef,
    ) {
        (self
            .LLVMGetNamedMetadataOperands
            .as_ref()
            .expect("Expected function, got error."))(M, Name, Dest)
    }
    #[doc = " Add an operand to named metadata.\n\n @see llvm::Module::getNamedMetadata()\n @see llvm::MDNode::addOperand()"]
    pub unsafe fn LLVMAddNamedMetadataOperand(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
        Val: LLVMValueRef,
    ) {
        (self
            .LLVMAddNamedMetadataOperand
            .as_ref()
            .expect("Expected function, got error."))(M, Name, Val)
    }
    #[doc = " Return the directory of the debug location for this value, which must be\n an llvm::Instruction, llvm::GlobalVariable, or llvm::Function.\n\n @see llvm::Instruction::getDebugLoc()\n @see llvm::GlobalVariable::getDebugInfo()\n @see llvm::Function::getSubprogram()"]
    pub unsafe fn LLVMGetDebugLocDirectory(
        &self,
        Val: LLVMValueRef,
        Length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetDebugLocDirectory
            .as_ref()
            .expect("Expected function, got error."))(Val, Length)
    }
    #[doc = " Return the filename of the debug location for this value, which must be\n an llvm::Instruction, llvm::GlobalVariable, or llvm::Function.\n\n @see llvm::Instruction::getDebugLoc()\n @see llvm::GlobalVariable::getDebugInfo()\n @see llvm::Function::getSubprogram()"]
    pub unsafe fn LLVMGetDebugLocFilename(
        &self,
        Val: LLVMValueRef,
        Length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetDebugLocFilename
            .as_ref()
            .expect("Expected function, got error."))(Val, Length)
    }
    #[doc = " Return the line number of the debug location for this value, which must be\n an llvm::Instruction, llvm::GlobalVariable, or llvm::Function.\n\n @see llvm::Instruction::getDebugLoc()\n @see llvm::GlobalVariable::getDebugInfo()\n @see llvm::Function::getSubprogram()"]
    pub unsafe fn LLVMGetDebugLocLine(&self, Val: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetDebugLocLine
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Return the column number of the debug location for this value, which must be\n an llvm::Instruction.\n\n @see llvm::Instruction::getDebugLoc()"]
    pub unsafe fn LLVMGetDebugLocColumn(&self, Val: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetDebugLocColumn
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Add a function to a module under a specified name.\n\n @see llvm::Function::Create()"]
    pub unsafe fn LLVMAddFunction(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
        FunctionTy: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMAddFunction
            .as_ref()
            .expect("Expected function, got error."))(M, Name, FunctionTy)
    }
    #[doc = " Obtain a Function value from a Module by its name.\n\n The returned value corresponds to a llvm::Function value.\n\n @see llvm::Module::getFunction()"]
    pub unsafe fn LLVMGetNamedFunction(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMGetNamedFunction
            .as_ref()
            .expect("Expected function, got error."))(M, Name)
    }
    #[doc = " Obtain an iterator to the first Function in a Module.\n\n @see llvm::Module::begin()"]
    pub unsafe fn LLVMGetFirstFunction(&self, M: LLVMModuleRef) -> LLVMValueRef {
        (self
            .LLVMGetFirstFunction
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Obtain an iterator to the last Function in a Module.\n\n @see llvm::Module::end()"]
    pub unsafe fn LLVMGetLastFunction(&self, M: LLVMModuleRef) -> LLVMValueRef {
        (self
            .LLVMGetLastFunction
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Advance a Function iterator to the next Function.\n\n Returns NULL if the iterator was already at the end and there are no more\n functions."]
    pub unsafe fn LLVMGetNextFunction(&self, Fn: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetNextFunction
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Decrement a Function iterator to the previous Function.\n\n Returns NULL if the iterator was already at the beginning and there are\n no previous functions."]
    pub unsafe fn LLVMGetPreviousFunction(&self, Fn: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetPreviousFunction
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Deprecated: Use LLVMSetModuleInlineAsm2 instead."]
    pub unsafe fn LLVMSetModuleInlineAsm(
        &self,
        M: LLVMModuleRef,
        Asm: *const ::std::os::raw::c_char,
    ) {
        (self
            .LLVMSetModuleInlineAsm
            .as_ref()
            .expect("Expected function, got error."))(M, Asm)
    }
    #[doc = " Obtain the enumerated type of a Type instance.\n\n @see llvm::Type:getTypeID()"]
    pub unsafe fn LLVMGetTypeKind(&self, Ty: LLVMTypeRef) -> LLVMTypeKind {
        (self
            .LLVMGetTypeKind
            .as_ref()
            .expect("Expected function, got error."))(Ty)
    }
    #[doc = " Whether the type has a known size.\n\n Things that don't have a size are abstract types, labels, and void.a\n\n @see llvm::Type::isSized()"]
    pub unsafe fn LLVMTypeIsSized(&self, Ty: LLVMTypeRef) -> LLVMBool {
        (self
            .LLVMTypeIsSized
            .as_ref()
            .expect("Expected function, got error."))(Ty)
    }
    #[doc = " Obtain the context to which this type instance is associated.\n\n @see llvm::Type::getContext()"]
    pub unsafe fn LLVMGetTypeContext(&self, Ty: LLVMTypeRef) -> LLVMContextRef {
        (self
            .LLVMGetTypeContext
            .as_ref()
            .expect("Expected function, got error."))(Ty)
    }
    #[doc = " Dump a representation of a type to stderr.\n\n @see llvm::Type::dump()"]
    pub unsafe fn LLVMDumpType(&self, Val: LLVMTypeRef) {
        (self
            .LLVMDumpType
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Return a string representation of the type. Use\n LLVMDisposeMessage to free the string.\n\n @see llvm::Type::print()"]
    pub unsafe fn LLVMPrintTypeToString(&self, Val: LLVMTypeRef) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMPrintTypeToString
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Obtain an integer type from a context with specified bit width."]
    pub unsafe fn LLVMInt1TypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMInt1TypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    pub unsafe fn LLVMInt8TypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMInt8TypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    pub unsafe fn LLVMInt16TypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMInt16TypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    pub unsafe fn LLVMInt32TypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMInt32TypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    pub unsafe fn LLVMInt64TypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMInt64TypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    pub unsafe fn LLVMInt128TypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMInt128TypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    pub unsafe fn LLVMIntTypeInContext(
        &self,
        C: LLVMContextRef,
        NumBits: ::std::os::raw::c_uint,
    ) -> LLVMTypeRef {
        (self
            .LLVMIntTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C, NumBits)
    }
    #[doc = " Obtain an integer type from the global context with a specified bit\n width."]
    pub unsafe fn LLVMInt1Type(&self) -> LLVMTypeRef {
        (self
            .LLVMInt1Type
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInt8Type(&self) -> LLVMTypeRef {
        (self
            .LLVMInt8Type
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInt16Type(&self) -> LLVMTypeRef {
        (self
            .LLVMInt16Type
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInt32Type(&self) -> LLVMTypeRef {
        (self
            .LLVMInt32Type
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInt64Type(&self) -> LLVMTypeRef {
        (self
            .LLVMInt64Type
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInt128Type(&self) -> LLVMTypeRef {
        (self
            .LLVMInt128Type
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMIntType(&self, NumBits: ::std::os::raw::c_uint) -> LLVMTypeRef {
        (self
            .LLVMIntType
            .as_ref()
            .expect("Expected function, got error."))(NumBits)
    }
    pub unsafe fn LLVMGetIntTypeWidth(&self, IntegerTy: LLVMTypeRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetIntTypeWidth
            .as_ref()
            .expect("Expected function, got error."))(IntegerTy)
    }
    #[doc = " Obtain a 16-bit floating point type from a context."]
    pub unsafe fn LLVMHalfTypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMHalfTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Obtain a 16-bit brain floating point type from a context."]
    pub unsafe fn LLVMBFloatTypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMBFloatTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Obtain a 32-bit floating point type from a context."]
    pub unsafe fn LLVMFloatTypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMFloatTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Obtain a 64-bit floating point type from a context."]
    pub unsafe fn LLVMDoubleTypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMDoubleTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Obtain a 80-bit floating point type (X87) from a context."]
    pub unsafe fn LLVMX86FP80TypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMX86FP80TypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Obtain a 128-bit floating point type (112-bit mantissa) from a\n context."]
    pub unsafe fn LLVMFP128TypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMFP128TypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Obtain a 128-bit floating point type (two 64-bits) from a context."]
    pub unsafe fn LLVMPPCFP128TypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMPPCFP128TypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Obtain a floating point type from the global context.\n\n These map to the functions in this group of the same name."]
    pub unsafe fn LLVMHalfType(&self) -> LLVMTypeRef {
        (self
            .LLVMHalfType
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMBFloatType(&self) -> LLVMTypeRef {
        (self
            .LLVMBFloatType
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMFloatType(&self) -> LLVMTypeRef {
        (self
            .LLVMFloatType
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMDoubleType(&self) -> LLVMTypeRef {
        (self
            .LLVMDoubleType
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMX86FP80Type(&self) -> LLVMTypeRef {
        (self
            .LLVMX86FP80Type
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMFP128Type(&self) -> LLVMTypeRef {
        (self
            .LLVMFP128Type
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMPPCFP128Type(&self) -> LLVMTypeRef {
        (self
            .LLVMPPCFP128Type
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Obtain a function type consisting of a specified signature.\n\n The function is defined as a tuple of a return Type, a list of\n parameter types, and whether the function is variadic."]
    pub unsafe fn LLVMFunctionType(
        &self,
        ReturnType: LLVMTypeRef,
        ParamTypes: *mut LLVMTypeRef,
        ParamCount: ::std::os::raw::c_uint,
        IsVarArg: LLVMBool,
    ) -> LLVMTypeRef {
        (self
            .LLVMFunctionType
            .as_ref()
            .expect("Expected function, got error."))(
            ReturnType, ParamTypes, ParamCount, IsVarArg
        )
    }
    #[doc = " Returns whether a function type is variadic."]
    pub unsafe fn LLVMIsFunctionVarArg(&self, FunctionTy: LLVMTypeRef) -> LLVMBool {
        (self
            .LLVMIsFunctionVarArg
            .as_ref()
            .expect("Expected function, got error."))(FunctionTy)
    }
    #[doc = " Obtain the Type this function Type returns."]
    pub unsafe fn LLVMGetReturnType(&self, FunctionTy: LLVMTypeRef) -> LLVMTypeRef {
        (self
            .LLVMGetReturnType
            .as_ref()
            .expect("Expected function, got error."))(FunctionTy)
    }
    #[doc = " Obtain the number of parameters this function accepts."]
    pub unsafe fn LLVMCountParamTypes(&self, FunctionTy: LLVMTypeRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMCountParamTypes
            .as_ref()
            .expect("Expected function, got error."))(FunctionTy)
    }
    #[doc = " Obtain the types of a function's parameters.\n\n The Dest parameter should point to a pre-allocated array of\n LLVMTypeRef at least LLVMCountParamTypes() large. On return, the\n first LLVMCountParamTypes() entries in the array will be populated\n with LLVMTypeRef instances.\n\n @param FunctionTy The function type to operate on.\n @param Dest Memory address of an array to be filled with result."]
    pub unsafe fn LLVMGetParamTypes(&self, FunctionTy: LLVMTypeRef, Dest: *mut LLVMTypeRef) {
        (self
            .LLVMGetParamTypes
            .as_ref()
            .expect("Expected function, got error."))(FunctionTy, Dest)
    }
    #[doc = " Create a new structure type in a context.\n\n A structure is specified by a list of inner elements/types and\n whether these can be packed together.\n\n @see llvm::StructType::create()"]
    pub unsafe fn LLVMStructTypeInContext(
        &self,
        C: LLVMContextRef,
        ElementTypes: *mut LLVMTypeRef,
        ElementCount: ::std::os::raw::c_uint,
        Packed: LLVMBool,
    ) -> LLVMTypeRef {
        (self
            .LLVMStructTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C, ElementTypes, ElementCount, Packed)
    }
    #[doc = " Create a new structure type in the global context.\n\n @see llvm::StructType::create()"]
    pub unsafe fn LLVMStructType(
        &self,
        ElementTypes: *mut LLVMTypeRef,
        ElementCount: ::std::os::raw::c_uint,
        Packed: LLVMBool,
    ) -> LLVMTypeRef {
        (self
            .LLVMStructType
            .as_ref()
            .expect("Expected function, got error."))(ElementTypes, ElementCount, Packed)
    }
    #[doc = " Create an empty structure in a context having a specified name.\n\n @see llvm::StructType::create()"]
    pub unsafe fn LLVMStructCreateNamed(
        &self,
        C: LLVMContextRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMTypeRef {
        (self
            .LLVMStructCreateNamed
            .as_ref()
            .expect("Expected function, got error."))(C, Name)
    }
    #[doc = " Obtain the name of a structure.\n\n @see llvm::StructType::getName()"]
    pub unsafe fn LLVMGetStructName(&self, Ty: LLVMTypeRef) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetStructName
            .as_ref()
            .expect("Expected function, got error."))(Ty)
    }
    #[doc = " Set the contents of a structure type.\n\n @see llvm::StructType::setBody()"]
    pub unsafe fn LLVMStructSetBody(
        &self,
        StructTy: LLVMTypeRef,
        ElementTypes: *mut LLVMTypeRef,
        ElementCount: ::std::os::raw::c_uint,
        Packed: LLVMBool,
    ) {
        (self
            .LLVMStructSetBody
            .as_ref()
            .expect("Expected function, got error."))(
            StructTy, ElementTypes, ElementCount, Packed
        )
    }
    #[doc = " Get the number of elements defined inside the structure.\n\n @see llvm::StructType::getNumElements()"]
    pub unsafe fn LLVMCountStructElementTypes(
        &self,
        StructTy: LLVMTypeRef,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMCountStructElementTypes
            .as_ref()
            .expect("Expected function, got error."))(StructTy)
    }
    #[doc = " Get the elements within a structure.\n\n The function is passed the address of a pre-allocated array of\n LLVMTypeRef at least LLVMCountStructElementTypes() long. After\n invocation, this array will be populated with the structure's\n elements. The objects in the destination array will have a lifetime\n of the structure type itself, which is the lifetime of the context it\n is contained in."]
    pub unsafe fn LLVMGetStructElementTypes(&self, StructTy: LLVMTypeRef, Dest: *mut LLVMTypeRef) {
        (self
            .LLVMGetStructElementTypes
            .as_ref()
            .expect("Expected function, got error."))(StructTy, Dest)
    }
    #[doc = " Get the type of the element at a given index in the structure.\n\n @see llvm::StructType::getTypeAtIndex()"]
    pub unsafe fn LLVMStructGetTypeAtIndex(
        &self,
        StructTy: LLVMTypeRef,
        i: ::std::os::raw::c_uint,
    ) -> LLVMTypeRef {
        (self
            .LLVMStructGetTypeAtIndex
            .as_ref()
            .expect("Expected function, got error."))(StructTy, i)
    }
    #[doc = " Determine whether a structure is packed.\n\n @see llvm::StructType::isPacked()"]
    pub unsafe fn LLVMIsPackedStruct(&self, StructTy: LLVMTypeRef) -> LLVMBool {
        (self
            .LLVMIsPackedStruct
            .as_ref()
            .expect("Expected function, got error."))(StructTy)
    }
    #[doc = " Determine whether a structure is opaque.\n\n @see llvm::StructType::isOpaque()"]
    pub unsafe fn LLVMIsOpaqueStruct(&self, StructTy: LLVMTypeRef) -> LLVMBool {
        (self
            .LLVMIsOpaqueStruct
            .as_ref()
            .expect("Expected function, got error."))(StructTy)
    }
    #[doc = " Determine whether a structure is literal.\n\n @see llvm::StructType::isLiteral()"]
    pub unsafe fn LLVMIsLiteralStruct(&self, StructTy: LLVMTypeRef) -> LLVMBool {
        (self
            .LLVMIsLiteralStruct
            .as_ref()
            .expect("Expected function, got error."))(StructTy)
    }
    #[doc = " Obtain the element type of an array or vector type.\n\n @see llvm::SequentialType::getElementType()"]
    pub unsafe fn LLVMGetElementType(&self, Ty: LLVMTypeRef) -> LLVMTypeRef {
        (self
            .LLVMGetElementType
            .as_ref()
            .expect("Expected function, got error."))(Ty)
    }
    #[doc = " Returns type's subtypes\n\n @see llvm::Type::subtypes()"]
    pub unsafe fn LLVMGetSubtypes(&self, Tp: LLVMTypeRef, Arr: *mut LLVMTypeRef) {
        (self
            .LLVMGetSubtypes
            .as_ref()
            .expect("Expected function, got error."))(Tp, Arr)
    }
    #[doc = "  Return the number of types in the derived type.\n\n @see llvm::Type::getNumContainedTypes()"]
    pub unsafe fn LLVMGetNumContainedTypes(&self, Tp: LLVMTypeRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetNumContainedTypes
            .as_ref()
            .expect("Expected function, got error."))(Tp)
    }
    #[doc = " Create a fixed size array type that refers to a specific type.\n\n The created type will exist in the context that its element type\n exists in.\n\n @deprecated LLVMArrayType is deprecated in favor of the API accurate\n LLVMArrayType2\n @see llvm::ArrayType::get()"]
    pub unsafe fn LLVMArrayType(
        &self,
        ElementType: LLVMTypeRef,
        ElementCount: ::std::os::raw::c_uint,
    ) -> LLVMTypeRef {
        (self
            .LLVMArrayType
            .as_ref()
            .expect("Expected function, got error."))(ElementType, ElementCount)
    }
    #[doc = " Create a fixed size array type that refers to a specific type.\n\n The created type will exist in the context that its element type\n exists in.\n\n @see llvm::ArrayType::get()"]
    pub unsafe fn LLVMArrayType2(
        &self,
        ElementType: LLVMTypeRef,
        ElementCount: u64,
    ) -> LLVMTypeRef {
        (self
            .LLVMArrayType2
            .as_ref()
            .expect("Expected function, got error."))(ElementType, ElementCount)
    }
    #[doc = " Obtain the length of an array type.\n\n This only works on types that represent arrays.\n\n @deprecated LLVMGetArrayLength is deprecated in favor of the API accurate\n LLVMGetArrayLength2\n @see llvm::ArrayType::getNumElements()"]
    pub unsafe fn LLVMGetArrayLength(&self, ArrayTy: LLVMTypeRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetArrayLength
            .as_ref()
            .expect("Expected function, got error."))(ArrayTy)
    }
    #[doc = " Obtain the length of an array type.\n\n This only works on types that represent arrays.\n\n @see llvm::ArrayType::getNumElements()"]
    pub unsafe fn LLVMGetArrayLength2(&self, ArrayTy: LLVMTypeRef) -> u64 {
        (self
            .LLVMGetArrayLength2
            .as_ref()
            .expect("Expected function, got error."))(ArrayTy)
    }
    #[doc = " Create a pointer type that points to a defined type.\n\n The created type will exist in the context that its pointee type\n exists in.\n\n @see llvm::PointerType::get()"]
    pub unsafe fn LLVMPointerType(
        &self,
        ElementType: LLVMTypeRef,
        AddressSpace: ::std::os::raw::c_uint,
    ) -> LLVMTypeRef {
        (self
            .LLVMPointerType
            .as_ref()
            .expect("Expected function, got error."))(ElementType, AddressSpace)
    }
    #[doc = " Determine whether a pointer is opaque.\n\n True if this is an instance of an opaque PointerType.\n\n @see llvm::Type::isOpaquePointerTy()"]
    pub unsafe fn LLVMPointerTypeIsOpaque(&self, Ty: LLVMTypeRef) -> LLVMBool {
        (self
            .LLVMPointerTypeIsOpaque
            .as_ref()
            .expect("Expected function, got error."))(Ty)
    }
    #[doc = " Create an opaque pointer type in a context.\n\n @see llvm::PointerType::get()"]
    pub unsafe fn LLVMPointerTypeInContext(
        &self,
        C: LLVMContextRef,
        AddressSpace: ::std::os::raw::c_uint,
    ) -> LLVMTypeRef {
        (self
            .LLVMPointerTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C, AddressSpace)
    }
    #[doc = " Obtain the address space of a pointer type.\n\n This only works on types that represent pointers.\n\n @see llvm::PointerType::getAddressSpace()"]
    pub unsafe fn LLVMGetPointerAddressSpace(
        &self,
        PointerTy: LLVMTypeRef,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetPointerAddressSpace
            .as_ref()
            .expect("Expected function, got error."))(PointerTy)
    }
    #[doc = " Create a vector type that contains a defined type and has a specific\n number of elements.\n\n The created type will exist in the context thats its element type\n exists in.\n\n @see llvm::VectorType::get()"]
    pub unsafe fn LLVMVectorType(
        &self,
        ElementType: LLVMTypeRef,
        ElementCount: ::std::os::raw::c_uint,
    ) -> LLVMTypeRef {
        (self
            .LLVMVectorType
            .as_ref()
            .expect("Expected function, got error."))(ElementType, ElementCount)
    }
    #[doc = " Create a vector type that contains a defined type and has a scalable\n number of elements.\n\n The created type will exist in the context thats its element type\n exists in.\n\n @see llvm::ScalableVectorType::get()"]
    pub unsafe fn LLVMScalableVectorType(
        &self,
        ElementType: LLVMTypeRef,
        ElementCount: ::std::os::raw::c_uint,
    ) -> LLVMTypeRef {
        (self
            .LLVMScalableVectorType
            .as_ref()
            .expect("Expected function, got error."))(ElementType, ElementCount)
    }
    #[doc = " Obtain the (possibly scalable) number of elements in a vector type.\n\n This only works on types that represent vectors (fixed or scalable).\n\n @see llvm::VectorType::getNumElements()"]
    pub unsafe fn LLVMGetVectorSize(&self, VectorTy: LLVMTypeRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetVectorSize
            .as_ref()
            .expect("Expected function, got error."))(VectorTy)
    }
    #[doc = " Create a void type in a context."]
    pub unsafe fn LLVMVoidTypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMVoidTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Create a label type in a context."]
    pub unsafe fn LLVMLabelTypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMLabelTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Create a X86 MMX type in a context."]
    pub unsafe fn LLVMX86MMXTypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMX86MMXTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Create a X86 AMX type in a context."]
    pub unsafe fn LLVMX86AMXTypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMX86AMXTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Create a token type in a context."]
    pub unsafe fn LLVMTokenTypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMTokenTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Create a metadata type in a context."]
    pub unsafe fn LLVMMetadataTypeInContext(&self, C: LLVMContextRef) -> LLVMTypeRef {
        (self
            .LLVMMetadataTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " These are similar to the above functions except they operate on the\n global context."]
    pub unsafe fn LLVMVoidType(&self) -> LLVMTypeRef {
        (self
            .LLVMVoidType
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMLabelType(&self) -> LLVMTypeRef {
        (self
            .LLVMLabelType
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMX86MMXType(&self) -> LLVMTypeRef {
        (self
            .LLVMX86MMXType
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMX86AMXType(&self) -> LLVMTypeRef {
        (self
            .LLVMX86AMXType
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Create a target extension type in LLVM context."]
    pub unsafe fn LLVMTargetExtTypeInContext(
        &self,
        C: LLVMContextRef,
        Name: *const ::std::os::raw::c_char,
        TypeParams: *mut LLVMTypeRef,
        TypeParamCount: ::std::os::raw::c_uint,
        IntParams: *mut ::std::os::raw::c_uint,
        IntParamCount: ::std::os::raw::c_uint,
    ) -> LLVMTypeRef {
        (self
            .LLVMTargetExtTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(
            C,
            Name,
            TypeParams,
            TypeParamCount,
            IntParams,
            IntParamCount,
        )
    }
    #[doc = " Obtain the type of a value.\n\n @see llvm::Value::getType()"]
    pub unsafe fn LLVMTypeOf(&self, Val: LLVMValueRef) -> LLVMTypeRef {
        (self
            .LLVMTypeOf
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Obtain the enumerated type of a Value instance.\n\n @see llvm::Value::getValueID()"]
    pub unsafe fn LLVMGetValueKind(&self, Val: LLVMValueRef) -> LLVMValueKind {
        (self
            .LLVMGetValueKind
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Obtain the string name of a value.\n\n @see llvm::Value::getName()"]
    pub unsafe fn LLVMGetValueName2(
        &self,
        Val: LLVMValueRef,
        Length: *mut usize,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetValueName2
            .as_ref()
            .expect("Expected function, got error."))(Val, Length)
    }
    #[doc = " Set the string name of a value.\n\n @see llvm::Value::setName()"]
    pub unsafe fn LLVMSetValueName2(
        &self,
        Val: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
    ) {
        (self
            .LLVMSetValueName2
            .as_ref()
            .expect("Expected function, got error."))(Val, Name, NameLen)
    }
    #[doc = " Dump a representation of a value to stderr.\n\n @see llvm::Value::dump()"]
    pub unsafe fn LLVMDumpValue(&self, Val: LLVMValueRef) {
        (self
            .LLVMDumpValue
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Return a string representation of the value. Use\n LLVMDisposeMessage to free the string.\n\n @see llvm::Value::print()"]
    pub unsafe fn LLVMPrintValueToString(&self, Val: LLVMValueRef) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMPrintValueToString
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Replace all uses of a value with another one.\n\n @see llvm::Value::replaceAllUsesWith()"]
    pub unsafe fn LLVMReplaceAllUsesWith(&self, OldVal: LLVMValueRef, NewVal: LLVMValueRef) {
        (self
            .LLVMReplaceAllUsesWith
            .as_ref()
            .expect("Expected function, got error."))(OldVal, NewVal)
    }
    #[doc = " Determine whether the specified value instance is constant."]
    pub unsafe fn LLVMIsConstant(&self, Val: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsConstant
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Determine whether a value instance is undefined."]
    pub unsafe fn LLVMIsUndef(&self, Val: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsUndef
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Determine whether a value instance is poisonous."]
    pub unsafe fn LLVMIsPoison(&self, Val: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsPoison
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAArgument(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAArgument
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsABasicBlock(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsABasicBlock
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAInlineAsm(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAInlineAsm
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAUser(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAUser
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAConstant(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAConstant
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsABlockAddress(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsABlockAddress
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAConstantAggregateZero(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAConstantAggregateZero
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAConstantArray(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAConstantArray
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAConstantDataSequential(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAConstantDataSequential
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAConstantDataArray(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAConstantDataArray
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAConstantDataVector(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAConstantDataVector
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAConstantExpr(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAConstantExpr
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAConstantFP(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAConstantFP
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAConstantInt(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAConstantInt
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAConstantPointerNull(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAConstantPointerNull
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAConstantStruct(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAConstantStruct
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAConstantTokenNone(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAConstantTokenNone
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAConstantVector(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAConstantVector
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAGlobalValue(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAGlobalValue
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAGlobalAlias(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAGlobalAlias
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAGlobalObject(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAGlobalObject
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAFunction(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAFunction
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAGlobalVariable(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAGlobalVariable
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAGlobalIFunc(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAGlobalIFunc
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAUndefValue(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAUndefValue
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAPoisonValue(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAPoisonValue
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAInstruction(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAInstruction
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAUnaryOperator(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAUnaryOperator
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsABinaryOperator(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsABinaryOperator
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsACallInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsACallInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAIntrinsicInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAIntrinsicInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsADbgInfoIntrinsic(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsADbgInfoIntrinsic
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsADbgVariableIntrinsic(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsADbgVariableIntrinsic
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsADbgDeclareInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsADbgDeclareInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsADbgLabelInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsADbgLabelInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAMemIntrinsic(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAMemIntrinsic
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAMemCpyInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAMemCpyInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAMemMoveInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAMemMoveInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAMemSetInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAMemSetInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsACmpInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsACmpInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAFCmpInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAFCmpInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAICmpInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAICmpInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAExtractElementInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAExtractElementInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAGetElementPtrInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAGetElementPtrInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAInsertElementInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAInsertElementInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAInsertValueInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAInsertValueInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsALandingPadInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsALandingPadInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAPHINode(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAPHINode
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsASelectInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsASelectInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAShuffleVectorInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAShuffleVectorInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAStoreInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAStoreInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsABranchInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsABranchInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAIndirectBrInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAIndirectBrInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAInvokeInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAInvokeInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAReturnInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAReturnInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsASwitchInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsASwitchInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAUnreachableInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAUnreachableInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAResumeInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAResumeInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsACleanupReturnInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsACleanupReturnInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsACatchReturnInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsACatchReturnInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsACatchSwitchInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsACatchSwitchInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsACallBrInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsACallBrInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAFuncletPadInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAFuncletPadInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsACatchPadInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsACatchPadInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsACleanupPadInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsACleanupPadInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAUnaryInstruction(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAUnaryInstruction
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAAllocaInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAAllocaInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsACastInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsACastInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAAddrSpaceCastInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAAddrSpaceCastInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsABitCastInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsABitCastInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAFPExtInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAFPExtInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAFPToSIInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAFPToSIInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAFPToUIInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAFPToUIInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAFPTruncInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAFPTruncInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAIntToPtrInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAIntToPtrInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAPtrToIntInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAPtrToIntInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsASExtInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsASExtInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsASIToFPInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsASIToFPInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsATruncInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsATruncInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAUIToFPInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAUIToFPInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAZExtInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAZExtInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAExtractValueInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAExtractValueInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsALoadInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsALoadInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAVAArgInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAVAArgInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAFreezeInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAFreezeInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAAtomicCmpXchgInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAAtomicCmpXchgInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAAtomicRMWInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAAtomicRMWInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAFenceInst(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAFenceInst
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAMDNode(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAMDNode
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAValueAsMetadata(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAValueAsMetadata
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    pub unsafe fn LLVMIsAMDString(&self, Val: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsAMDString
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Deprecated: Use LLVMGetValueName2 instead."]
    pub unsafe fn LLVMGetValueName(&self, Val: LLVMValueRef) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetValueName
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Deprecated: Use LLVMSetValueName2 instead."]
    pub unsafe fn LLVMSetValueName(&self, Val: LLVMValueRef, Name: *const ::std::os::raw::c_char) {
        (self
            .LLVMSetValueName
            .as_ref()
            .expect("Expected function, got error."))(Val, Name)
    }
    #[doc = " Obtain the first use of a value.\n\n Uses are obtained in an iterator fashion. First, call this function\n to obtain a reference to the first use. Then, call LLVMGetNextUse()\n on that instance and all subsequently obtained instances until\n LLVMGetNextUse() returns NULL.\n\n @see llvm::Value::use_begin()"]
    pub unsafe fn LLVMGetFirstUse(&self, Val: LLVMValueRef) -> LLVMUseRef {
        (self
            .LLVMGetFirstUse
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Obtain the next use of a value.\n\n This effectively advances the iterator. It returns NULL if you are on\n the final use and no more are available."]
    pub unsafe fn LLVMGetNextUse(&self, U: LLVMUseRef) -> LLVMUseRef {
        (self
            .LLVMGetNextUse
            .as_ref()
            .expect("Expected function, got error."))(U)
    }
    #[doc = " Obtain the user value for a user.\n\n The returned value corresponds to a llvm::User type.\n\n @see llvm::Use::getUser()"]
    pub unsafe fn LLVMGetUser(&self, U: LLVMUseRef) -> LLVMValueRef {
        (self
            .LLVMGetUser
            .as_ref()
            .expect("Expected function, got error."))(U)
    }
    #[doc = " Obtain the value this use corresponds to.\n\n @see llvm::Use::get()."]
    pub unsafe fn LLVMGetUsedValue(&self, U: LLVMUseRef) -> LLVMValueRef {
        (self
            .LLVMGetUsedValue
            .as_ref()
            .expect("Expected function, got error."))(U)
    }
    #[doc = " Obtain an operand at a specific index in a llvm::User value.\n\n @see llvm::User::getOperand()"]
    pub unsafe fn LLVMGetOperand(
        &self,
        Val: LLVMValueRef,
        Index: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMGetOperand
            .as_ref()
            .expect("Expected function, got error."))(Val, Index)
    }
    #[doc = " Obtain the use of an operand at a specific index in a llvm::User value.\n\n @see llvm::User::getOperandUse()"]
    pub unsafe fn LLVMGetOperandUse(
        &self,
        Val: LLVMValueRef,
        Index: ::std::os::raw::c_uint,
    ) -> LLVMUseRef {
        (self
            .LLVMGetOperandUse
            .as_ref()
            .expect("Expected function, got error."))(Val, Index)
    }
    #[doc = " Set an operand at a specific index in a llvm::User value.\n\n @see llvm::User::setOperand()"]
    pub unsafe fn LLVMSetOperand(
        &self,
        User: LLVMValueRef,
        Index: ::std::os::raw::c_uint,
        Val: LLVMValueRef,
    ) {
        (self
            .LLVMSetOperand
            .as_ref()
            .expect("Expected function, got error."))(User, Index, Val)
    }
    #[doc = " Obtain the number of operands in a llvm::User value.\n\n @see llvm::User::getNumOperands()"]
    pub unsafe fn LLVMGetNumOperands(&self, Val: LLVMValueRef) -> ::std::os::raw::c_int {
        (self
            .LLVMGetNumOperands
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Obtain a constant value referring to the null instance of a type.\n\n @see llvm::Constant::getNullValue()"]
    pub unsafe fn LLVMConstNull(&self, Ty: LLVMTypeRef) -> LLVMValueRef {
        (self
            .LLVMConstNull
            .as_ref()
            .expect("Expected function, got error."))(Ty)
    }
    #[doc = " Obtain a constant value referring to the instance of a type\n consisting of all ones.\n\n This is only valid for integer types.\n\n @see llvm::Constant::getAllOnesValue()"]
    pub unsafe fn LLVMConstAllOnes(&self, Ty: LLVMTypeRef) -> LLVMValueRef {
        (self
            .LLVMConstAllOnes
            .as_ref()
            .expect("Expected function, got error."))(Ty)
    }
    #[doc = " Obtain a constant value referring to an undefined value of a type.\n\n @see llvm::UndefValue::get()"]
    pub unsafe fn LLVMGetUndef(&self, Ty: LLVMTypeRef) -> LLVMValueRef {
        (self
            .LLVMGetUndef
            .as_ref()
            .expect("Expected function, got error."))(Ty)
    }
    #[doc = " Obtain a constant value referring to a poison value of a type.\n\n @see llvm::PoisonValue::get()"]
    pub unsafe fn LLVMGetPoison(&self, Ty: LLVMTypeRef) -> LLVMValueRef {
        (self
            .LLVMGetPoison
            .as_ref()
            .expect("Expected function, got error."))(Ty)
    }
    #[doc = " Determine whether a value instance is null.\n\n @see llvm::Constant::isNullValue()"]
    pub unsafe fn LLVMIsNull(&self, Val: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsNull
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Obtain a constant that is a constant pointer pointing to NULL for a\n specified type."]
    pub unsafe fn LLVMConstPointerNull(&self, Ty: LLVMTypeRef) -> LLVMValueRef {
        (self
            .LLVMConstPointerNull
            .as_ref()
            .expect("Expected function, got error."))(Ty)
    }
    #[doc = " Obtain a constant value for an integer type.\n\n The returned value corresponds to a llvm::ConstantInt.\n\n @see llvm::ConstantInt::get()\n\n @param IntTy Integer type to obtain value of.\n @param N The value the returned instance should refer to.\n @param SignExtend Whether to sign extend the produced value."]
    pub unsafe fn LLVMConstInt(
        &self,
        IntTy: LLVMTypeRef,
        N: ::std::os::raw::c_ulonglong,
        SignExtend: LLVMBool,
    ) -> LLVMValueRef {
        (self
            .LLVMConstInt
            .as_ref()
            .expect("Expected function, got error."))(IntTy, N, SignExtend)
    }
    #[doc = " Obtain a constant value for an integer of arbitrary precision.\n\n @see llvm::ConstantInt::get()"]
    pub unsafe fn LLVMConstIntOfArbitraryPrecision(
        &self,
        IntTy: LLVMTypeRef,
        NumWords: ::std::os::raw::c_uint,
        Words: *const u64,
    ) -> LLVMValueRef {
        (self
            .LLVMConstIntOfArbitraryPrecision
            .as_ref()
            .expect("Expected function, got error."))(IntTy, NumWords, Words)
    }
    #[doc = " Obtain a constant value for an integer parsed from a string.\n\n A similar API, LLVMConstIntOfStringAndSize is also available. If the\n string's length is available, it is preferred to call that function\n instead.\n\n @see llvm::ConstantInt::get()"]
    pub unsafe fn LLVMConstIntOfString(
        &self,
        IntTy: LLVMTypeRef,
        Text: *const ::std::os::raw::c_char,
        Radix: u8,
    ) -> LLVMValueRef {
        (self
            .LLVMConstIntOfString
            .as_ref()
            .expect("Expected function, got error."))(IntTy, Text, Radix)
    }
    #[doc = " Obtain a constant value for an integer parsed from a string with\n specified length.\n\n @see llvm::ConstantInt::get()"]
    pub unsafe fn LLVMConstIntOfStringAndSize(
        &self,
        IntTy: LLVMTypeRef,
        Text: *const ::std::os::raw::c_char,
        SLen: ::std::os::raw::c_uint,
        Radix: u8,
    ) -> LLVMValueRef {
        (self
            .LLVMConstIntOfStringAndSize
            .as_ref()
            .expect("Expected function, got error."))(IntTy, Text, SLen, Radix)
    }
    #[doc = " Obtain a constant value referring to a double floating point value."]
    pub unsafe fn LLVMConstReal(&self, RealTy: LLVMTypeRef, N: f64) -> LLVMValueRef {
        (self
            .LLVMConstReal
            .as_ref()
            .expect("Expected function, got error."))(RealTy, N)
    }
    #[doc = " Obtain a constant for a floating point value parsed from a string.\n\n A similar API, LLVMConstRealOfStringAndSize is also available. It\n should be used if the input string's length is known."]
    pub unsafe fn LLVMConstRealOfString(
        &self,
        RealTy: LLVMTypeRef,
        Text: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMConstRealOfString
            .as_ref()
            .expect("Expected function, got error."))(RealTy, Text)
    }
    #[doc = " Obtain a constant for a floating point value parsed from a string."]
    pub unsafe fn LLVMConstRealOfStringAndSize(
        &self,
        RealTy: LLVMTypeRef,
        Text: *const ::std::os::raw::c_char,
        SLen: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMConstRealOfStringAndSize
            .as_ref()
            .expect("Expected function, got error."))(RealTy, Text, SLen)
    }
    #[doc = " Obtain the zero extended value for an integer constant value.\n\n @see llvm::ConstantInt::getZExtValue()"]
    pub unsafe fn LLVMConstIntGetZExtValue(
        &self,
        ConstantVal: LLVMValueRef,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            .LLVMConstIntGetZExtValue
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal)
    }
    #[doc = " Obtain the sign extended value for an integer constant value.\n\n @see llvm::ConstantInt::getSExtValue()"]
    pub unsafe fn LLVMConstIntGetSExtValue(
        &self,
        ConstantVal: LLVMValueRef,
    ) -> ::std::os::raw::c_longlong {
        (self
            .LLVMConstIntGetSExtValue
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal)
    }
    #[doc = " Obtain the double value for an floating point constant value.\n losesInfo indicates if some precision was lost in the conversion.\n\n @see llvm::ConstantFP::getDoubleValue"]
    pub unsafe fn LLVMConstRealGetDouble(
        &self,
        ConstantVal: LLVMValueRef,
        losesInfo: *mut LLVMBool,
    ) -> f64 {
        (self
            .LLVMConstRealGetDouble
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, losesInfo)
    }
    #[doc = " Create a ConstantDataSequential and initialize it with a string.\n\n @see llvm::ConstantDataArray::getString()"]
    pub unsafe fn LLVMConstStringInContext(
        &self,
        C: LLVMContextRef,
        Str: *const ::std::os::raw::c_char,
        Length: ::std::os::raw::c_uint,
        DontNullTerminate: LLVMBool,
    ) -> LLVMValueRef {
        (self
            .LLVMConstStringInContext
            .as_ref()
            .expect("Expected function, got error."))(C, Str, Length, DontNullTerminate)
    }
    #[doc = " Create a ConstantDataSequential with string content in the global context.\n\n This is the same as LLVMConstStringInContext except it operates on the\n global context.\n\n @see LLVMConstStringInContext()\n @see llvm::ConstantDataArray::getString()"]
    pub unsafe fn LLVMConstString(
        &self,
        Str: *const ::std::os::raw::c_char,
        Length: ::std::os::raw::c_uint,
        DontNullTerminate: LLVMBool,
    ) -> LLVMValueRef {
        (self
            .LLVMConstString
            .as_ref()
            .expect("Expected function, got error."))(Str, Length, DontNullTerminate)
    }
    #[doc = " Returns true if the specified constant is an array of i8.\n\n @see ConstantDataSequential::getAsString()"]
    pub unsafe fn LLVMIsConstantString(&self, c: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsConstantString
            .as_ref()
            .expect("Expected function, got error."))(c)
    }
    #[doc = " Get the given constant data sequential as a string.\n\n @see ConstantDataSequential::getAsString()"]
    pub unsafe fn LLVMGetAsString(
        &self,
        c: LLVMValueRef,
        Length: *mut usize,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetAsString
            .as_ref()
            .expect("Expected function, got error."))(c, Length)
    }
    #[doc = " Create an anonymous ConstantStruct with the specified values.\n\n @see llvm::ConstantStruct::getAnon()"]
    pub unsafe fn LLVMConstStructInContext(
        &self,
        C: LLVMContextRef,
        ConstantVals: *mut LLVMValueRef,
        Count: ::std::os::raw::c_uint,
        Packed: LLVMBool,
    ) -> LLVMValueRef {
        (self
            .LLVMConstStructInContext
            .as_ref()
            .expect("Expected function, got error."))(C, ConstantVals, Count, Packed)
    }
    #[doc = " Create a ConstantStruct in the global Context.\n\n This is the same as LLVMConstStructInContext except it operates on the\n global Context.\n\n @see LLVMConstStructInContext()"]
    pub unsafe fn LLVMConstStruct(
        &self,
        ConstantVals: *mut LLVMValueRef,
        Count: ::std::os::raw::c_uint,
        Packed: LLVMBool,
    ) -> LLVMValueRef {
        (self
            .LLVMConstStruct
            .as_ref()
            .expect("Expected function, got error."))(ConstantVals, Count, Packed)
    }
    #[doc = " Create a ConstantArray from values.\n\n @deprecated LLVMConstArray is deprecated in favor of the API accurate\n LLVMConstArray2\n @see llvm::ConstantArray::get()"]
    pub unsafe fn LLVMConstArray(
        &self,
        ElementTy: LLVMTypeRef,
        ConstantVals: *mut LLVMValueRef,
        Length: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMConstArray
            .as_ref()
            .expect("Expected function, got error."))(ElementTy, ConstantVals, Length)
    }
    #[doc = " Create a ConstantArray from values.\n\n @see llvm::ConstantArray::get()"]
    pub unsafe fn LLVMConstArray2(
        &self,
        ElementTy: LLVMTypeRef,
        ConstantVals: *mut LLVMValueRef,
        Length: u64,
    ) -> LLVMValueRef {
        (self
            .LLVMConstArray2
            .as_ref()
            .expect("Expected function, got error."))(ElementTy, ConstantVals, Length)
    }
    #[doc = " Create a non-anonymous ConstantStruct from values.\n\n @see llvm::ConstantStruct::get()"]
    pub unsafe fn LLVMConstNamedStruct(
        &self,
        StructTy: LLVMTypeRef,
        ConstantVals: *mut LLVMValueRef,
        Count: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMConstNamedStruct
            .as_ref()
            .expect("Expected function, got error."))(StructTy, ConstantVals, Count)
    }
    #[doc = " Get element of a constant aggregate (struct, array or vector) at the\n specified index. Returns null if the index is out of range, or it's not\n possible to determine the element (e.g., because the constant is a\n constant expression.)\n\n @see llvm::Constant::getAggregateElement()"]
    pub unsafe fn LLVMGetAggregateElement(
        &self,
        C: LLVMValueRef,
        Idx: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMGetAggregateElement
            .as_ref()
            .expect("Expected function, got error."))(C, Idx)
    }
    #[doc = " Get an element at specified index as a constant.\n\n @see ConstantDataSequential::getElementAsConstant()"]
    pub unsafe fn LLVMGetElementAsConstant(
        &self,
        C: LLVMValueRef,
        idx: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMGetElementAsConstant
            .as_ref()
            .expect("Expected function, got error."))(C, idx)
    }
    #[doc = " Create a ConstantVector from values.\n\n @see llvm::ConstantVector::get()"]
    pub unsafe fn LLVMConstVector(
        &self,
        ScalarConstantVals: *mut LLVMValueRef,
        Size: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMConstVector
            .as_ref()
            .expect("Expected function, got error."))(ScalarConstantVals, Size)
    }
    #[doc = " @defgroup LLVMCCoreValueConstantExpressions Constant Expressions\n\n Functions in this group correspond to APIs on llvm::ConstantExpr.\n\n @see llvm::ConstantExpr.\n\n @{"]
    pub unsafe fn LLVMGetConstOpcode(&self, ConstantVal: LLVMValueRef) -> LLVMOpcode {
        (self
            .LLVMGetConstOpcode
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal)
    }
    pub unsafe fn LLVMAlignOf(&self, Ty: LLVMTypeRef) -> LLVMValueRef {
        (self
            .LLVMAlignOf
            .as_ref()
            .expect("Expected function, got error."))(Ty)
    }
    pub unsafe fn LLVMSizeOf(&self, Ty: LLVMTypeRef) -> LLVMValueRef {
        (self
            .LLVMSizeOf
            .as_ref()
            .expect("Expected function, got error."))(Ty)
    }
    pub unsafe fn LLVMConstNeg(&self, ConstantVal: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMConstNeg
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal)
    }
    pub unsafe fn LLVMConstNSWNeg(&self, ConstantVal: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMConstNSWNeg
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal)
    }
    pub unsafe fn LLVMConstNUWNeg(&self, ConstantVal: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMConstNUWNeg
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal)
    }
    pub unsafe fn LLVMConstNot(&self, ConstantVal: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMConstNot
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal)
    }
    pub unsafe fn LLVMConstAdd(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstAdd
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstNSWAdd(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstNSWAdd
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstNUWAdd(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstNUWAdd
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstSub(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstSub
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstNSWSub(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstNSWSub
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstNUWSub(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstNUWSub
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstMul(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstMul
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstNSWMul(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstNSWMul
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstNUWMul(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstNUWMul
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstAnd(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstAnd
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstOr(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstOr
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstXor(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstXor
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstICmp(
        &self,
        Predicate: LLVMIntPredicate,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstICmp
            .as_ref()
            .expect("Expected function, got error."))(Predicate, LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstFCmp(
        &self,
        Predicate: LLVMRealPredicate,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstFCmp
            .as_ref()
            .expect("Expected function, got error."))(Predicate, LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstShl(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstShl
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstLShr(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstLShr
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstAShr(
        &self,
        LHSConstant: LLVMValueRef,
        RHSConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstAShr
            .as_ref()
            .expect("Expected function, got error."))(LHSConstant, RHSConstant)
    }
    pub unsafe fn LLVMConstGEP2(
        &self,
        Ty: LLVMTypeRef,
        ConstantVal: LLVMValueRef,
        ConstantIndices: *mut LLVMValueRef,
        NumIndices: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMConstGEP2
            .as_ref()
            .expect("Expected function, got error."))(
            Ty, ConstantVal, ConstantIndices, NumIndices
        )
    }
    pub unsafe fn LLVMConstInBoundsGEP2(
        &self,
        Ty: LLVMTypeRef,
        ConstantVal: LLVMValueRef,
        ConstantIndices: *mut LLVMValueRef,
        NumIndices: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMConstInBoundsGEP2
            .as_ref()
            .expect("Expected function, got error."))(
            Ty, ConstantVal, ConstantIndices, NumIndices
        )
    }
    pub unsafe fn LLVMConstTrunc(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstTrunc
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstSExt(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstSExt
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstZExt(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstZExt
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstFPTrunc(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstFPTrunc
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstFPExt(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstFPExt
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstUIToFP(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstUIToFP
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstSIToFP(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstSIToFP
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstFPToUI(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstFPToUI
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstFPToSI(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstFPToSI
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstPtrToInt(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstPtrToInt
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstIntToPtr(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstIntToPtr
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstBitCast(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstBitCast
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstAddrSpaceCast(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstAddrSpaceCast
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstZExtOrBitCast(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstZExtOrBitCast
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstSExtOrBitCast(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstSExtOrBitCast
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstTruncOrBitCast(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstTruncOrBitCast
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstPointerCast(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstPointerCast
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstIntCast(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
        isSigned: LLVMBool,
    ) -> LLVMValueRef {
        (self
            .LLVMConstIntCast
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType, isSigned)
    }
    pub unsafe fn LLVMConstFPCast(
        &self,
        ConstantVal: LLVMValueRef,
        ToType: LLVMTypeRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstFPCast
            .as_ref()
            .expect("Expected function, got error."))(ConstantVal, ToType)
    }
    pub unsafe fn LLVMConstExtractElement(
        &self,
        VectorConstant: LLVMValueRef,
        IndexConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstExtractElement
            .as_ref()
            .expect("Expected function, got error."))(VectorConstant, IndexConstant)
    }
    pub unsafe fn LLVMConstInsertElement(
        &self,
        VectorConstant: LLVMValueRef,
        ElementValueConstant: LLVMValueRef,
        IndexConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstInsertElement
            .as_ref()
            .expect("Expected function, got error."))(
            VectorConstant,
            ElementValueConstant,
            IndexConstant,
        )
    }
    pub unsafe fn LLVMConstShuffleVector(
        &self,
        VectorAConstant: LLVMValueRef,
        VectorBConstant: LLVMValueRef,
        MaskConstant: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMConstShuffleVector
            .as_ref()
            .expect("Expected function, got error."))(
            VectorAConstant,
            VectorBConstant,
            MaskConstant,
        )
    }
    pub unsafe fn LLVMBlockAddress(&self, F: LLVMValueRef, BB: LLVMBasicBlockRef) -> LLVMValueRef {
        (self
            .LLVMBlockAddress
            .as_ref()
            .expect("Expected function, got error."))(F, BB)
    }
    #[doc = " Deprecated: Use LLVMGetInlineAsm instead."]
    pub unsafe fn LLVMConstInlineAsm(
        &self,
        Ty: LLVMTypeRef,
        AsmString: *const ::std::os::raw::c_char,
        Constraints: *const ::std::os::raw::c_char,
        HasSideEffects: LLVMBool,
        IsAlignStack: LLVMBool,
    ) -> LLVMValueRef {
        (self
            .LLVMConstInlineAsm
            .as_ref()
            .expect("Expected function, got error."))(
            Ty,
            AsmString,
            Constraints,
            HasSideEffects,
            IsAlignStack,
        )
    }
    #[doc = " @defgroup LLVMCCoreValueConstantGlobals Global Values\n\n This group contains functions that operate on global values. Functions in\n this group relate to functions in the llvm::GlobalValue class tree.\n\n @see llvm::GlobalValue\n\n @{"]
    pub unsafe fn LLVMGetGlobalParent(&self, Global: LLVMValueRef) -> LLVMModuleRef {
        (self
            .LLVMGetGlobalParent
            .as_ref()
            .expect("Expected function, got error."))(Global)
    }
    pub unsafe fn LLVMIsDeclaration(&self, Global: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsDeclaration
            .as_ref()
            .expect("Expected function, got error."))(Global)
    }
    pub unsafe fn LLVMGetLinkage(&self, Global: LLVMValueRef) -> LLVMLinkage {
        (self
            .LLVMGetLinkage
            .as_ref()
            .expect("Expected function, got error."))(Global)
    }
    pub unsafe fn LLVMSetLinkage(&self, Global: LLVMValueRef, Linkage: LLVMLinkage) {
        (self
            .LLVMSetLinkage
            .as_ref()
            .expect("Expected function, got error."))(Global, Linkage)
    }
    pub unsafe fn LLVMGetSection(&self, Global: LLVMValueRef) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetSection
            .as_ref()
            .expect("Expected function, got error."))(Global)
    }
    pub unsafe fn LLVMSetSection(
        &self,
        Global: LLVMValueRef,
        Section: *const ::std::os::raw::c_char,
    ) {
        (self
            .LLVMSetSection
            .as_ref()
            .expect("Expected function, got error."))(Global, Section)
    }
    pub unsafe fn LLVMGetVisibility(&self, Global: LLVMValueRef) -> LLVMVisibility {
        (self
            .LLVMGetVisibility
            .as_ref()
            .expect("Expected function, got error."))(Global)
    }
    pub unsafe fn LLVMSetVisibility(&self, Global: LLVMValueRef, Viz: LLVMVisibility) {
        (self
            .LLVMSetVisibility
            .as_ref()
            .expect("Expected function, got error."))(Global, Viz)
    }
    pub unsafe fn LLVMGetDLLStorageClass(&self, Global: LLVMValueRef) -> LLVMDLLStorageClass {
        (self
            .LLVMGetDLLStorageClass
            .as_ref()
            .expect("Expected function, got error."))(Global)
    }
    pub unsafe fn LLVMSetDLLStorageClass(&self, Global: LLVMValueRef, Class: LLVMDLLStorageClass) {
        (self
            .LLVMSetDLLStorageClass
            .as_ref()
            .expect("Expected function, got error."))(Global, Class)
    }
    pub unsafe fn LLVMGetUnnamedAddress(&self, Global: LLVMValueRef) -> LLVMUnnamedAddr {
        (self
            .LLVMGetUnnamedAddress
            .as_ref()
            .expect("Expected function, got error."))(Global)
    }
    pub unsafe fn LLVMSetUnnamedAddress(&self, Global: LLVMValueRef, UnnamedAddr: LLVMUnnamedAddr) {
        (self
            .LLVMSetUnnamedAddress
            .as_ref()
            .expect("Expected function, got error."))(Global, UnnamedAddr)
    }
    #[doc = " Returns the \"value type\" of a global value.  This differs from the formal\n type of a global value which is always a pointer type.\n\n @see llvm::GlobalValue::getValueType()"]
    pub unsafe fn LLVMGlobalGetValueType(&self, Global: LLVMValueRef) -> LLVMTypeRef {
        (self
            .LLVMGlobalGetValueType
            .as_ref()
            .expect("Expected function, got error."))(Global)
    }
    #[doc = " Deprecated: Use LLVMGetUnnamedAddress instead."]
    pub unsafe fn LLVMHasUnnamedAddr(&self, Global: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMHasUnnamedAddr
            .as_ref()
            .expect("Expected function, got error."))(Global)
    }
    #[doc = " Deprecated: Use LLVMSetUnnamedAddress instead."]
    pub unsafe fn LLVMSetUnnamedAddr(&self, Global: LLVMValueRef, HasUnnamedAddr: LLVMBool) {
        (self
            .LLVMSetUnnamedAddr
            .as_ref()
            .expect("Expected function, got error."))(Global, HasUnnamedAddr)
    }
    #[doc = " Obtain the preferred alignment of the value.\n @see llvm::AllocaInst::getAlignment()\n @see llvm::LoadInst::getAlignment()\n @see llvm::StoreInst::getAlignment()\n @see llvm::AtomicRMWInst::setAlignment()\n @see llvm::AtomicCmpXchgInst::setAlignment()\n @see llvm::GlobalValue::getAlignment()"]
    pub unsafe fn LLVMGetAlignment(&self, V: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetAlignment
            .as_ref()
            .expect("Expected function, got error."))(V)
    }
    #[doc = " Set the preferred alignment of the value.\n @see llvm::AllocaInst::setAlignment()\n @see llvm::LoadInst::setAlignment()\n @see llvm::StoreInst::setAlignment()\n @see llvm::AtomicRMWInst::setAlignment()\n @see llvm::AtomicCmpXchgInst::setAlignment()\n @see llvm::GlobalValue::setAlignment()"]
    pub unsafe fn LLVMSetAlignment(&self, V: LLVMValueRef, Bytes: ::std::os::raw::c_uint) {
        (self
            .LLVMSetAlignment
            .as_ref()
            .expect("Expected function, got error."))(V, Bytes)
    }
    #[doc = " Sets a metadata attachment, erasing the existing metadata attachment if\n it already exists for the given kind.\n\n @see llvm::GlobalObject::setMetadata()"]
    pub unsafe fn LLVMGlobalSetMetadata(
        &self,
        Global: LLVMValueRef,
        Kind: ::std::os::raw::c_uint,
        MD: LLVMMetadataRef,
    ) {
        (self
            .LLVMGlobalSetMetadata
            .as_ref()
            .expect("Expected function, got error."))(Global, Kind, MD)
    }
    #[doc = " Erases a metadata attachment of the given kind if it exists.\n\n @see llvm::GlobalObject::eraseMetadata()"]
    pub unsafe fn LLVMGlobalEraseMetadata(
        &self,
        Global: LLVMValueRef,
        Kind: ::std::os::raw::c_uint,
    ) {
        (self
            .LLVMGlobalEraseMetadata
            .as_ref()
            .expect("Expected function, got error."))(Global, Kind)
    }
    #[doc = " Removes all metadata attachments from this value.\n\n @see llvm::GlobalObject::clearMetadata()"]
    pub unsafe fn LLVMGlobalClearMetadata(&self, Global: LLVMValueRef) {
        (self
            .LLVMGlobalClearMetadata
            .as_ref()
            .expect("Expected function, got error."))(Global)
    }
    #[doc = " Retrieves an array of metadata entries representing the metadata attached to\n this value. The caller is responsible for freeing this array by calling\n \\c LLVMDisposeValueMetadataEntries.\n\n @see llvm::GlobalObject::getAllMetadata()"]
    pub unsafe fn LLVMGlobalCopyAllMetadata(
        &self,
        Value: LLVMValueRef,
        NumEntries: *mut usize,
    ) -> *mut LLVMValueMetadataEntry {
        (self
            .LLVMGlobalCopyAllMetadata
            .as_ref()
            .expect("Expected function, got error."))(Value, NumEntries)
    }
    #[doc = " Destroys value metadata entries."]
    pub unsafe fn LLVMDisposeValueMetadataEntries(&self, Entries: *mut LLVMValueMetadataEntry) {
        (self
            .LLVMDisposeValueMetadataEntries
            .as_ref()
            .expect("Expected function, got error."))(Entries)
    }
    #[doc = " Returns the kind of a value metadata entry at a specific index."]
    pub unsafe fn LLVMValueMetadataEntriesGetKind(
        &self,
        Entries: *mut LLVMValueMetadataEntry,
        Index: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMValueMetadataEntriesGetKind
            .as_ref()
            .expect("Expected function, got error."))(Entries, Index)
    }
    #[doc = " Returns the underlying metadata node of a value metadata entry at a\n specific index."]
    pub unsafe fn LLVMValueMetadataEntriesGetMetadata(
        &self,
        Entries: *mut LLVMValueMetadataEntry,
        Index: ::std::os::raw::c_uint,
    ) -> LLVMMetadataRef {
        (self
            .LLVMValueMetadataEntriesGetMetadata
            .as_ref()
            .expect("Expected function, got error."))(Entries, Index)
    }
    #[doc = " @defgroup LLVMCoreValueConstantGlobalVariable Global Variables\n\n This group contains functions that operate on global variable values.\n\n @see llvm::GlobalVariable\n\n @{"]
    pub unsafe fn LLVMAddGlobal(
        &self,
        M: LLVMModuleRef,
        Ty: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMAddGlobal
            .as_ref()
            .expect("Expected function, got error."))(M, Ty, Name)
    }
    pub unsafe fn LLVMAddGlobalInAddressSpace(
        &self,
        M: LLVMModuleRef,
        Ty: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
        AddressSpace: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMAddGlobalInAddressSpace
            .as_ref()
            .expect("Expected function, got error."))(M, Ty, Name, AddressSpace)
    }
    pub unsafe fn LLVMGetNamedGlobal(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMGetNamedGlobal
            .as_ref()
            .expect("Expected function, got error."))(M, Name)
    }
    pub unsafe fn LLVMGetFirstGlobal(&self, M: LLVMModuleRef) -> LLVMValueRef {
        (self
            .LLVMGetFirstGlobal
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    pub unsafe fn LLVMGetLastGlobal(&self, M: LLVMModuleRef) -> LLVMValueRef {
        (self
            .LLVMGetLastGlobal
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    pub unsafe fn LLVMGetNextGlobal(&self, GlobalVar: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetNextGlobal
            .as_ref()
            .expect("Expected function, got error."))(GlobalVar)
    }
    pub unsafe fn LLVMGetPreviousGlobal(&self, GlobalVar: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetPreviousGlobal
            .as_ref()
            .expect("Expected function, got error."))(GlobalVar)
    }
    pub unsafe fn LLVMDeleteGlobal(&self, GlobalVar: LLVMValueRef) {
        (self
            .LLVMDeleteGlobal
            .as_ref()
            .expect("Expected function, got error."))(GlobalVar)
    }
    pub unsafe fn LLVMGetInitializer(&self, GlobalVar: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetInitializer
            .as_ref()
            .expect("Expected function, got error."))(GlobalVar)
    }
    pub unsafe fn LLVMSetInitializer(&self, GlobalVar: LLVMValueRef, ConstantVal: LLVMValueRef) {
        (self
            .LLVMSetInitializer
            .as_ref()
            .expect("Expected function, got error."))(GlobalVar, ConstantVal)
    }
    pub unsafe fn LLVMIsThreadLocal(&self, GlobalVar: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsThreadLocal
            .as_ref()
            .expect("Expected function, got error."))(GlobalVar)
    }
    pub unsafe fn LLVMSetThreadLocal(&self, GlobalVar: LLVMValueRef, IsThreadLocal: LLVMBool) {
        (self
            .LLVMSetThreadLocal
            .as_ref()
            .expect("Expected function, got error."))(GlobalVar, IsThreadLocal)
    }
    pub unsafe fn LLVMIsGlobalConstant(&self, GlobalVar: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsGlobalConstant
            .as_ref()
            .expect("Expected function, got error."))(GlobalVar)
    }
    pub unsafe fn LLVMSetGlobalConstant(&self, GlobalVar: LLVMValueRef, IsConstant: LLVMBool) {
        (self
            .LLVMSetGlobalConstant
            .as_ref()
            .expect("Expected function, got error."))(GlobalVar, IsConstant)
    }
    pub unsafe fn LLVMGetThreadLocalMode(&self, GlobalVar: LLVMValueRef) -> LLVMThreadLocalMode {
        (self
            .LLVMGetThreadLocalMode
            .as_ref()
            .expect("Expected function, got error."))(GlobalVar)
    }
    pub unsafe fn LLVMSetThreadLocalMode(
        &self,
        GlobalVar: LLVMValueRef,
        Mode: LLVMThreadLocalMode,
    ) {
        (self
            .LLVMSetThreadLocalMode
            .as_ref()
            .expect("Expected function, got error."))(GlobalVar, Mode)
    }
    pub unsafe fn LLVMIsExternallyInitialized(&self, GlobalVar: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsExternallyInitialized
            .as_ref()
            .expect("Expected function, got error."))(GlobalVar)
    }
    pub unsafe fn LLVMSetExternallyInitialized(
        &self,
        GlobalVar: LLVMValueRef,
        IsExtInit: LLVMBool,
    ) {
        (self
            .LLVMSetExternallyInitialized
            .as_ref()
            .expect("Expected function, got error."))(GlobalVar, IsExtInit)
    }
    #[doc = " Add a GlobalAlias with the given value type, address space and aliasee.\n\n @see llvm::GlobalAlias::create()"]
    pub unsafe fn LLVMAddAlias2(
        &self,
        M: LLVMModuleRef,
        ValueTy: LLVMTypeRef,
        AddrSpace: ::std::os::raw::c_uint,
        Aliasee: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMAddAlias2
            .as_ref()
            .expect("Expected function, got error."))(M, ValueTy, AddrSpace, Aliasee, Name)
    }
    #[doc = " Obtain a GlobalAlias value from a Module by its name.\n\n The returned value corresponds to a llvm::GlobalAlias value.\n\n @see llvm::Module::getNamedAlias()"]
    pub unsafe fn LLVMGetNamedGlobalAlias(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
    ) -> LLVMValueRef {
        (self
            .LLVMGetNamedGlobalAlias
            .as_ref()
            .expect("Expected function, got error."))(M, Name, NameLen)
    }
    #[doc = " Obtain an iterator to the first GlobalAlias in a Module.\n\n @see llvm::Module::alias_begin()"]
    pub unsafe fn LLVMGetFirstGlobalAlias(&self, M: LLVMModuleRef) -> LLVMValueRef {
        (self
            .LLVMGetFirstGlobalAlias
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Obtain an iterator to the last GlobalAlias in a Module.\n\n @see llvm::Module::alias_end()"]
    pub unsafe fn LLVMGetLastGlobalAlias(&self, M: LLVMModuleRef) -> LLVMValueRef {
        (self
            .LLVMGetLastGlobalAlias
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Advance a GlobalAlias iterator to the next GlobalAlias.\n\n Returns NULL if the iterator was already at the end and there are no more\n global aliases."]
    pub unsafe fn LLVMGetNextGlobalAlias(&self, GA: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetNextGlobalAlias
            .as_ref()
            .expect("Expected function, got error."))(GA)
    }
    #[doc = " Decrement a GlobalAlias iterator to the previous GlobalAlias.\n\n Returns NULL if the iterator was already at the beginning and there are\n no previous global aliases."]
    pub unsafe fn LLVMGetPreviousGlobalAlias(&self, GA: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetPreviousGlobalAlias
            .as_ref()
            .expect("Expected function, got error."))(GA)
    }
    #[doc = " Retrieve the target value of an alias."]
    pub unsafe fn LLVMAliasGetAliasee(&self, Alias: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMAliasGetAliasee
            .as_ref()
            .expect("Expected function, got error."))(Alias)
    }
    #[doc = " Set the target value of an alias."]
    pub unsafe fn LLVMAliasSetAliasee(&self, Alias: LLVMValueRef, Aliasee: LLVMValueRef) {
        (self
            .LLVMAliasSetAliasee
            .as_ref()
            .expect("Expected function, got error."))(Alias, Aliasee)
    }
    #[doc = " Remove a function from its containing module and deletes it.\n\n @see llvm::Function::eraseFromParent()"]
    pub unsafe fn LLVMDeleteFunction(&self, Fn: LLVMValueRef) {
        (self
            .LLVMDeleteFunction
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Check whether the given function has a personality function.\n\n @see llvm::Function::hasPersonalityFn()"]
    pub unsafe fn LLVMHasPersonalityFn(&self, Fn: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMHasPersonalityFn
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Obtain the personality function attached to the function.\n\n @see llvm::Function::getPersonalityFn()"]
    pub unsafe fn LLVMGetPersonalityFn(&self, Fn: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetPersonalityFn
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Set the personality function attached to the function.\n\n @see llvm::Function::setPersonalityFn()"]
    pub unsafe fn LLVMSetPersonalityFn(&self, Fn: LLVMValueRef, PersonalityFn: LLVMValueRef) {
        (self
            .LLVMSetPersonalityFn
            .as_ref()
            .expect("Expected function, got error."))(Fn, PersonalityFn)
    }
    #[doc = " Obtain the intrinsic ID number which matches the given function name.\n\n @see llvm::Function::lookupIntrinsicID()"]
    pub unsafe fn LLVMLookupIntrinsicID(
        &self,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMLookupIntrinsicID
            .as_ref()
            .expect("Expected function, got error."))(Name, NameLen)
    }
    #[doc = " Obtain the ID number from a function instance.\n\n @see llvm::Function::getIntrinsicID()"]
    pub unsafe fn LLVMGetIntrinsicID(&self, Fn: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetIntrinsicID
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Create or insert the declaration of an intrinsic.  For overloaded intrinsics,\n parameter types must be provided to uniquely identify an overload.\n\n @see llvm::Intrinsic::getDeclaration()"]
    pub unsafe fn LLVMGetIntrinsicDeclaration(
        &self,
        Mod: LLVMModuleRef,
        ID: ::std::os::raw::c_uint,
        ParamTypes: *mut LLVMTypeRef,
        ParamCount: usize,
    ) -> LLVMValueRef {
        (self
            .LLVMGetIntrinsicDeclaration
            .as_ref()
            .expect("Expected function, got error."))(Mod, ID, ParamTypes, ParamCount)
    }
    #[doc = " Retrieves the type of an intrinsic.  For overloaded intrinsics, parameter\n types must be provided to uniquely identify an overload.\n\n @see llvm::Intrinsic::getType()"]
    pub unsafe fn LLVMIntrinsicGetType(
        &self,
        Ctx: LLVMContextRef,
        ID: ::std::os::raw::c_uint,
        ParamTypes: *mut LLVMTypeRef,
        ParamCount: usize,
    ) -> LLVMTypeRef {
        (self
            .LLVMIntrinsicGetType
            .as_ref()
            .expect("Expected function, got error."))(Ctx, ID, ParamTypes, ParamCount)
    }
    #[doc = " Retrieves the name of an intrinsic.\n\n @see llvm::Intrinsic::getName()"]
    pub unsafe fn LLVMIntrinsicGetName(
        &self,
        ID: ::std::os::raw::c_uint,
        NameLength: *mut usize,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMIntrinsicGetName
            .as_ref()
            .expect("Expected function, got error."))(ID, NameLength)
    }
    #[doc = " Deprecated: Use LLVMIntrinsicCopyOverloadedName2 instead."]
    pub unsafe fn LLVMIntrinsicCopyOverloadedName(
        &self,
        ID: ::std::os::raw::c_uint,
        ParamTypes: *mut LLVMTypeRef,
        ParamCount: usize,
        NameLength: *mut usize,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMIntrinsicCopyOverloadedName
            .as_ref()
            .expect("Expected function, got error."))(ID, ParamTypes, ParamCount, NameLength)
    }
    #[doc = " Copies the name of an overloaded intrinsic identified by a given list of\n parameter types.\n\n Unlike LLVMIntrinsicGetName, the caller is responsible for freeing the\n returned string.\n\n This version also supports unnamed types.\n\n @see llvm::Intrinsic::getName()"]
    pub unsafe fn LLVMIntrinsicCopyOverloadedName2(
        &self,
        Mod: LLVMModuleRef,
        ID: ::std::os::raw::c_uint,
        ParamTypes: *mut LLVMTypeRef,
        ParamCount: usize,
        NameLength: *mut usize,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMIntrinsicCopyOverloadedName2
            .as_ref()
            .expect("Expected function, got error."))(
            Mod, ID, ParamTypes, ParamCount, NameLength
        )
    }
    #[doc = " Obtain if the intrinsic identified by the given ID is overloaded.\n\n @see llvm::Intrinsic::isOverloaded()"]
    pub unsafe fn LLVMIntrinsicIsOverloaded(&self, ID: ::std::os::raw::c_uint) -> LLVMBool {
        (self
            .LLVMIntrinsicIsOverloaded
            .as_ref()
            .expect("Expected function, got error."))(ID)
    }
    #[doc = " Obtain the calling function of a function.\n\n The returned value corresponds to the LLVMCallConv enumeration.\n\n @see llvm::Function::getCallingConv()"]
    pub unsafe fn LLVMGetFunctionCallConv(&self, Fn: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetFunctionCallConv
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Set the calling convention of a function.\n\n @see llvm::Function::setCallingConv()\n\n @param Fn Function to operate on\n @param CC LLVMCallConv to set calling convention to"]
    pub unsafe fn LLVMSetFunctionCallConv(&self, Fn: LLVMValueRef, CC: ::std::os::raw::c_uint) {
        (self
            .LLVMSetFunctionCallConv
            .as_ref()
            .expect("Expected function, got error."))(Fn, CC)
    }
    #[doc = " Obtain the name of the garbage collector to use during code\n generation.\n\n @see llvm::Function::getGC()"]
    pub unsafe fn LLVMGetGC(&self, Fn: LLVMValueRef) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetGC
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Define the garbage collector to use during code generation.\n\n @see llvm::Function::setGC()"]
    pub unsafe fn LLVMSetGC(&self, Fn: LLVMValueRef, Name: *const ::std::os::raw::c_char) {
        (self
            .LLVMSetGC
            .as_ref()
            .expect("Expected function, got error."))(Fn, Name)
    }
    #[doc = " Add an attribute to a function.\n\n @see llvm::Function::addAttribute()"]
    pub unsafe fn LLVMAddAttributeAtIndex(
        &self,
        F: LLVMValueRef,
        Idx: LLVMAttributeIndex,
        A: LLVMAttributeRef,
    ) {
        (self
            .LLVMAddAttributeAtIndex
            .as_ref()
            .expect("Expected function, got error."))(F, Idx, A)
    }
    pub unsafe fn LLVMGetAttributeCountAtIndex(
        &self,
        F: LLVMValueRef,
        Idx: LLVMAttributeIndex,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetAttributeCountAtIndex
            .as_ref()
            .expect("Expected function, got error."))(F, Idx)
    }
    pub unsafe fn LLVMGetAttributesAtIndex(
        &self,
        F: LLVMValueRef,
        Idx: LLVMAttributeIndex,
        Attrs: *mut LLVMAttributeRef,
    ) {
        (self
            .LLVMGetAttributesAtIndex
            .as_ref()
            .expect("Expected function, got error."))(F, Idx, Attrs)
    }
    pub unsafe fn LLVMGetEnumAttributeAtIndex(
        &self,
        F: LLVMValueRef,
        Idx: LLVMAttributeIndex,
        KindID: ::std::os::raw::c_uint,
    ) -> LLVMAttributeRef {
        (self
            .LLVMGetEnumAttributeAtIndex
            .as_ref()
            .expect("Expected function, got error."))(F, Idx, KindID)
    }
    pub unsafe fn LLVMGetStringAttributeAtIndex(
        &self,
        F: LLVMValueRef,
        Idx: LLVMAttributeIndex,
        K: *const ::std::os::raw::c_char,
        KLen: ::std::os::raw::c_uint,
    ) -> LLVMAttributeRef {
        (self
            .LLVMGetStringAttributeAtIndex
            .as_ref()
            .expect("Expected function, got error."))(F, Idx, K, KLen)
    }
    pub unsafe fn LLVMRemoveEnumAttributeAtIndex(
        &self,
        F: LLVMValueRef,
        Idx: LLVMAttributeIndex,
        KindID: ::std::os::raw::c_uint,
    ) {
        (self
            .LLVMRemoveEnumAttributeAtIndex
            .as_ref()
            .expect("Expected function, got error."))(F, Idx, KindID)
    }
    pub unsafe fn LLVMRemoveStringAttributeAtIndex(
        &self,
        F: LLVMValueRef,
        Idx: LLVMAttributeIndex,
        K: *const ::std::os::raw::c_char,
        KLen: ::std::os::raw::c_uint,
    ) {
        (self
            .LLVMRemoveStringAttributeAtIndex
            .as_ref()
            .expect("Expected function, got error."))(F, Idx, K, KLen)
    }
    #[doc = " Add a target-dependent attribute to a function\n @see llvm::AttrBuilder::addAttribute()"]
    pub unsafe fn LLVMAddTargetDependentFunctionAttr(
        &self,
        Fn: LLVMValueRef,
        A: *const ::std::os::raw::c_char,
        V: *const ::std::os::raw::c_char,
    ) {
        (self
            .LLVMAddTargetDependentFunctionAttr
            .as_ref()
            .expect("Expected function, got error."))(Fn, A, V)
    }
    #[doc = " Obtain the number of parameters in a function.\n\n @see llvm::Function::arg_size()"]
    pub unsafe fn LLVMCountParams(&self, Fn: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMCountParams
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Obtain the parameters in a function.\n\n The takes a pointer to a pre-allocated array of LLVMValueRef that is\n at least LLVMCountParams() long. This array will be filled with\n LLVMValueRef instances which correspond to the parameters the\n function receives. Each LLVMValueRef corresponds to a llvm::Argument\n instance.\n\n @see llvm::Function::arg_begin()"]
    pub unsafe fn LLVMGetParams(&self, Fn: LLVMValueRef, Params: *mut LLVMValueRef) {
        (self
            .LLVMGetParams
            .as_ref()
            .expect("Expected function, got error."))(Fn, Params)
    }
    #[doc = " Obtain the parameter at the specified index.\n\n Parameters are indexed from 0.\n\n @see llvm::Function::arg_begin()"]
    pub unsafe fn LLVMGetParam(
        &self,
        Fn: LLVMValueRef,
        Index: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMGetParam
            .as_ref()
            .expect("Expected function, got error."))(Fn, Index)
    }
    #[doc = " Obtain the function to which this argument belongs.\n\n Unlike other functions in this group, this one takes an LLVMValueRef\n that corresponds to a llvm::Attribute.\n\n The returned LLVMValueRef is the llvm::Function to which this\n argument belongs."]
    pub unsafe fn LLVMGetParamParent(&self, Inst: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetParamParent
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Obtain the first parameter to a function.\n\n @see llvm::Function::arg_begin()"]
    pub unsafe fn LLVMGetFirstParam(&self, Fn: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetFirstParam
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Obtain the last parameter to a function.\n\n @see llvm::Function::arg_end()"]
    pub unsafe fn LLVMGetLastParam(&self, Fn: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetLastParam
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Obtain the next parameter to a function.\n\n This takes an LLVMValueRef obtained from LLVMGetFirstParam() (which is\n actually a wrapped iterator) and obtains the next parameter from the\n underlying iterator."]
    pub unsafe fn LLVMGetNextParam(&self, Arg: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetNextParam
            .as_ref()
            .expect("Expected function, got error."))(Arg)
    }
    #[doc = " Obtain the previous parameter to a function.\n\n This is the opposite of LLVMGetNextParam()."]
    pub unsafe fn LLVMGetPreviousParam(&self, Arg: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetPreviousParam
            .as_ref()
            .expect("Expected function, got error."))(Arg)
    }
    #[doc = " Set the alignment for a function parameter.\n\n @see llvm::Argument::addAttr()\n @see llvm::AttrBuilder::addAlignmentAttr()"]
    pub unsafe fn LLVMSetParamAlignment(&self, Arg: LLVMValueRef, Align: ::std::os::raw::c_uint) {
        (self
            .LLVMSetParamAlignment
            .as_ref()
            .expect("Expected function, got error."))(Arg, Align)
    }
    #[doc = " Add a global indirect function to a module under a specified name.\n\n @see llvm::GlobalIFunc::create()"]
    pub unsafe fn LLVMAddGlobalIFunc(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        Ty: LLVMTypeRef,
        AddrSpace: ::std::os::raw::c_uint,
        Resolver: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMAddGlobalIFunc
            .as_ref()
            .expect("Expected function, got error."))(
            M, Name, NameLen, Ty, AddrSpace, Resolver
        )
    }
    #[doc = " Obtain a GlobalIFunc value from a Module by its name.\n\n The returned value corresponds to a llvm::GlobalIFunc value.\n\n @see llvm::Module::getNamedIFunc()"]
    pub unsafe fn LLVMGetNamedGlobalIFunc(
        &self,
        M: LLVMModuleRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
    ) -> LLVMValueRef {
        (self
            .LLVMGetNamedGlobalIFunc
            .as_ref()
            .expect("Expected function, got error."))(M, Name, NameLen)
    }
    #[doc = " Obtain an iterator to the first GlobalIFunc in a Module.\n\n @see llvm::Module::ifunc_begin()"]
    pub unsafe fn LLVMGetFirstGlobalIFunc(&self, M: LLVMModuleRef) -> LLVMValueRef {
        (self
            .LLVMGetFirstGlobalIFunc
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Obtain an iterator to the last GlobalIFunc in a Module.\n\n @see llvm::Module::ifunc_end()"]
    pub unsafe fn LLVMGetLastGlobalIFunc(&self, M: LLVMModuleRef) -> LLVMValueRef {
        (self
            .LLVMGetLastGlobalIFunc
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Advance a GlobalIFunc iterator to the next GlobalIFunc.\n\n Returns NULL if the iterator was already at the end and there are no more\n global aliases."]
    pub unsafe fn LLVMGetNextGlobalIFunc(&self, IFunc: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetNextGlobalIFunc
            .as_ref()
            .expect("Expected function, got error."))(IFunc)
    }
    #[doc = " Decrement a GlobalIFunc iterator to the previous GlobalIFunc.\n\n Returns NULL if the iterator was already at the beginning and there are\n no previous global aliases."]
    pub unsafe fn LLVMGetPreviousGlobalIFunc(&self, IFunc: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetPreviousGlobalIFunc
            .as_ref()
            .expect("Expected function, got error."))(IFunc)
    }
    #[doc = " Retrieves the resolver function associated with this indirect function, or\n NULL if it doesn't not exist.\n\n @see llvm::GlobalIFunc::getResolver()"]
    pub unsafe fn LLVMGetGlobalIFuncResolver(&self, IFunc: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetGlobalIFuncResolver
            .as_ref()
            .expect("Expected function, got error."))(IFunc)
    }
    #[doc = " Sets the resolver function associated with this indirect function.\n\n @see llvm::GlobalIFunc::setResolver()"]
    pub unsafe fn LLVMSetGlobalIFuncResolver(&self, IFunc: LLVMValueRef, Resolver: LLVMValueRef) {
        (self
            .LLVMSetGlobalIFuncResolver
            .as_ref()
            .expect("Expected function, got error."))(IFunc, Resolver)
    }
    #[doc = " Remove a global indirect function from its parent module and delete it.\n\n @see llvm::GlobalIFunc::eraseFromParent()"]
    pub unsafe fn LLVMEraseGlobalIFunc(&self, IFunc: LLVMValueRef) {
        (self
            .LLVMEraseGlobalIFunc
            .as_ref()
            .expect("Expected function, got error."))(IFunc)
    }
    #[doc = " Remove a global indirect function from its parent module.\n\n This unlinks the global indirect function from its containing module but\n keeps it alive.\n\n @see llvm::GlobalIFunc::removeFromParent()"]
    pub unsafe fn LLVMRemoveGlobalIFunc(&self, IFunc: LLVMValueRef) {
        (self
            .LLVMRemoveGlobalIFunc
            .as_ref()
            .expect("Expected function, got error."))(IFunc)
    }
    #[doc = " Create an MDString value from a given string value.\n\n The MDString value does not take ownership of the given string, it remains\n the responsibility of the caller to free it.\n\n @see llvm::MDString::get()"]
    pub unsafe fn LLVMMDStringInContext2(
        &self,
        C: LLVMContextRef,
        Str: *const ::std::os::raw::c_char,
        SLen: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMMDStringInContext2
            .as_ref()
            .expect("Expected function, got error."))(C, Str, SLen)
    }
    #[doc = " Create an MDNode value with the given array of operands.\n\n @see llvm::MDNode::get()"]
    pub unsafe fn LLVMMDNodeInContext2(
        &self,
        C: LLVMContextRef,
        MDs: *mut LLVMMetadataRef,
        Count: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMMDNodeInContext2
            .as_ref()
            .expect("Expected function, got error."))(C, MDs, Count)
    }
    #[doc = " Obtain a Metadata as a Value."]
    pub unsafe fn LLVMMetadataAsValue(
        &self,
        C: LLVMContextRef,
        MD: LLVMMetadataRef,
    ) -> LLVMValueRef {
        (self
            .LLVMMetadataAsValue
            .as_ref()
            .expect("Expected function, got error."))(C, MD)
    }
    #[doc = " Obtain a Value as a Metadata."]
    pub unsafe fn LLVMValueAsMetadata(&self, Val: LLVMValueRef) -> LLVMMetadataRef {
        (self
            .LLVMValueAsMetadata
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Obtain the underlying string from a MDString value.\n\n @param V Instance to obtain string from.\n @param Length Memory address which will hold length of returned string.\n @return String data in MDString."]
    pub unsafe fn LLVMGetMDString(
        &self,
        V: LLVMValueRef,
        Length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetMDString
            .as_ref()
            .expect("Expected function, got error."))(V, Length)
    }
    #[doc = " Obtain the number of operands from an MDNode value.\n\n @param V MDNode to get number of operands from.\n @return Number of operands of the MDNode."]
    pub unsafe fn LLVMGetMDNodeNumOperands(&self, V: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetMDNodeNumOperands
            .as_ref()
            .expect("Expected function, got error."))(V)
    }
    #[doc = " Obtain the given MDNode's operands.\n\n The passed LLVMValueRef pointer should point to enough memory to hold all of\n the operands of the given MDNode (see LLVMGetMDNodeNumOperands) as\n LLVMValueRefs. This memory will be populated with the LLVMValueRefs of the\n MDNode's operands.\n\n @param V MDNode to get the operands from.\n @param Dest Destination array for operands."]
    pub unsafe fn LLVMGetMDNodeOperands(&self, V: LLVMValueRef, Dest: *mut LLVMValueRef) {
        (self
            .LLVMGetMDNodeOperands
            .as_ref()
            .expect("Expected function, got error."))(V, Dest)
    }
    #[doc = " Replace an operand at a specific index in a llvm::MDNode value.\n\n @see llvm::MDNode::replaceOperandWith()"]
    pub unsafe fn LLVMReplaceMDNodeOperandWith(
        &self,
        V: LLVMValueRef,
        Index: ::std::os::raw::c_uint,
        Replacement: LLVMMetadataRef,
    ) {
        (self
            .LLVMReplaceMDNodeOperandWith
            .as_ref()
            .expect("Expected function, got error."))(V, Index, Replacement)
    }
    #[doc = " Deprecated: Use LLVMMDStringInContext2 instead."]
    pub unsafe fn LLVMMDStringInContext(
        &self,
        C: LLVMContextRef,
        Str: *const ::std::os::raw::c_char,
        SLen: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMMDStringInContext
            .as_ref()
            .expect("Expected function, got error."))(C, Str, SLen)
    }
    #[doc = " Deprecated: Use LLVMMDStringInContext2 instead."]
    pub unsafe fn LLVMMDString(
        &self,
        Str: *const ::std::os::raw::c_char,
        SLen: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMMDString
            .as_ref()
            .expect("Expected function, got error."))(Str, SLen)
    }
    #[doc = " Deprecated: Use LLVMMDNodeInContext2 instead."]
    pub unsafe fn LLVMMDNodeInContext(
        &self,
        C: LLVMContextRef,
        Vals: *mut LLVMValueRef,
        Count: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMMDNodeInContext
            .as_ref()
            .expect("Expected function, got error."))(C, Vals, Count)
    }
    #[doc = " Deprecated: Use LLVMMDNodeInContext2 instead."]
    pub unsafe fn LLVMMDNode(
        &self,
        Vals: *mut LLVMValueRef,
        Count: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMMDNode
            .as_ref()
            .expect("Expected function, got error."))(Vals, Count)
    }
    #[doc = " Convert a basic block instance to a value type."]
    pub unsafe fn LLVMBasicBlockAsValue(&self, BB: LLVMBasicBlockRef) -> LLVMValueRef {
        (self
            .LLVMBasicBlockAsValue
            .as_ref()
            .expect("Expected function, got error."))(BB)
    }
    #[doc = " Determine whether an LLVMValueRef is itself a basic block."]
    pub unsafe fn LLVMValueIsBasicBlock(&self, Val: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMValueIsBasicBlock
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Convert an LLVMValueRef to an LLVMBasicBlockRef instance."]
    pub unsafe fn LLVMValueAsBasicBlock(&self, Val: LLVMValueRef) -> LLVMBasicBlockRef {
        (self
            .LLVMValueAsBasicBlock
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Obtain the string name of a basic block."]
    pub unsafe fn LLVMGetBasicBlockName(
        &self,
        BB: LLVMBasicBlockRef,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetBasicBlockName
            .as_ref()
            .expect("Expected function, got error."))(BB)
    }
    #[doc = " Obtain the function to which a basic block belongs.\n\n @see llvm::BasicBlock::getParent()"]
    pub unsafe fn LLVMGetBasicBlockParent(&self, BB: LLVMBasicBlockRef) -> LLVMValueRef {
        (self
            .LLVMGetBasicBlockParent
            .as_ref()
            .expect("Expected function, got error."))(BB)
    }
    #[doc = " Obtain the terminator instruction for a basic block.\n\n If the basic block does not have a terminator (it is not well-formed\n if it doesn't), then NULL is returned.\n\n The returned LLVMValueRef corresponds to an llvm::Instruction.\n\n @see llvm::BasicBlock::getTerminator()"]
    pub unsafe fn LLVMGetBasicBlockTerminator(&self, BB: LLVMBasicBlockRef) -> LLVMValueRef {
        (self
            .LLVMGetBasicBlockTerminator
            .as_ref()
            .expect("Expected function, got error."))(BB)
    }
    #[doc = " Obtain the number of basic blocks in a function.\n\n @param Fn Function value to operate on."]
    pub unsafe fn LLVMCountBasicBlocks(&self, Fn: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMCountBasicBlocks
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Obtain all of the basic blocks in a function.\n\n This operates on a function value. The BasicBlocks parameter is a\n pointer to a pre-allocated array of LLVMBasicBlockRef of at least\n LLVMCountBasicBlocks() in length. This array is populated with\n LLVMBasicBlockRef instances."]
    pub unsafe fn LLVMGetBasicBlocks(&self, Fn: LLVMValueRef, BasicBlocks: *mut LLVMBasicBlockRef) {
        (self
            .LLVMGetBasicBlocks
            .as_ref()
            .expect("Expected function, got error."))(Fn, BasicBlocks)
    }
    #[doc = " Obtain the first basic block in a function.\n\n The returned basic block can be used as an iterator. You will likely\n eventually call into LLVMGetNextBasicBlock() with it.\n\n @see llvm::Function::begin()"]
    pub unsafe fn LLVMGetFirstBasicBlock(&self, Fn: LLVMValueRef) -> LLVMBasicBlockRef {
        (self
            .LLVMGetFirstBasicBlock
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Obtain the last basic block in a function.\n\n @see llvm::Function::end()"]
    pub unsafe fn LLVMGetLastBasicBlock(&self, Fn: LLVMValueRef) -> LLVMBasicBlockRef {
        (self
            .LLVMGetLastBasicBlock
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Advance a basic block iterator."]
    pub unsafe fn LLVMGetNextBasicBlock(&self, BB: LLVMBasicBlockRef) -> LLVMBasicBlockRef {
        (self
            .LLVMGetNextBasicBlock
            .as_ref()
            .expect("Expected function, got error."))(BB)
    }
    #[doc = " Go backwards in a basic block iterator."]
    pub unsafe fn LLVMGetPreviousBasicBlock(&self, BB: LLVMBasicBlockRef) -> LLVMBasicBlockRef {
        (self
            .LLVMGetPreviousBasicBlock
            .as_ref()
            .expect("Expected function, got error."))(BB)
    }
    #[doc = " Obtain the basic block that corresponds to the entry point of a\n function.\n\n @see llvm::Function::getEntryBlock()"]
    pub unsafe fn LLVMGetEntryBasicBlock(&self, Fn: LLVMValueRef) -> LLVMBasicBlockRef {
        (self
            .LLVMGetEntryBasicBlock
            .as_ref()
            .expect("Expected function, got error."))(Fn)
    }
    #[doc = " Insert the given basic block after the insertion point of the given builder.\n\n The insertion point must be valid.\n\n @see llvm::Function::BasicBlockListType::insertAfter()"]
    pub unsafe fn LLVMInsertExistingBasicBlockAfterInsertBlock(
        &self,
        Builder: LLVMBuilderRef,
        BB: LLVMBasicBlockRef,
    ) {
        (self
            .LLVMInsertExistingBasicBlockAfterInsertBlock
            .as_ref()
            .expect("Expected function, got error."))(Builder, BB)
    }
    #[doc = " Append the given basic block to the basic block list of the given function.\n\n @see llvm::Function::BasicBlockListType::push_back()"]
    pub unsafe fn LLVMAppendExistingBasicBlock(&self, Fn: LLVMValueRef, BB: LLVMBasicBlockRef) {
        (self
            .LLVMAppendExistingBasicBlock
            .as_ref()
            .expect("Expected function, got error."))(Fn, BB)
    }
    #[doc = " Create a new basic block without inserting it into a function.\n\n @see llvm::BasicBlock::Create()"]
    pub unsafe fn LLVMCreateBasicBlockInContext(
        &self,
        C: LLVMContextRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMBasicBlockRef {
        (self
            .LLVMCreateBasicBlockInContext
            .as_ref()
            .expect("Expected function, got error."))(C, Name)
    }
    #[doc = " Append a basic block to the end of a function.\n\n @see llvm::BasicBlock::Create()"]
    pub unsafe fn LLVMAppendBasicBlockInContext(
        &self,
        C: LLVMContextRef,
        Fn: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMBasicBlockRef {
        (self
            .LLVMAppendBasicBlockInContext
            .as_ref()
            .expect("Expected function, got error."))(C, Fn, Name)
    }
    #[doc = " Append a basic block to the end of a function using the global\n context.\n\n @see llvm::BasicBlock::Create()"]
    pub unsafe fn LLVMAppendBasicBlock(
        &self,
        Fn: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMBasicBlockRef {
        (self
            .LLVMAppendBasicBlock
            .as_ref()
            .expect("Expected function, got error."))(Fn, Name)
    }
    #[doc = " Insert a basic block in a function before another basic block.\n\n The function to add to is determined by the function of the\n passed basic block.\n\n @see llvm::BasicBlock::Create()"]
    pub unsafe fn LLVMInsertBasicBlockInContext(
        &self,
        C: LLVMContextRef,
        BB: LLVMBasicBlockRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMBasicBlockRef {
        (self
            .LLVMInsertBasicBlockInContext
            .as_ref()
            .expect("Expected function, got error."))(C, BB, Name)
    }
    #[doc = " Insert a basic block in a function using the global context.\n\n @see llvm::BasicBlock::Create()"]
    pub unsafe fn LLVMInsertBasicBlock(
        &self,
        InsertBeforeBB: LLVMBasicBlockRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMBasicBlockRef {
        (self
            .LLVMInsertBasicBlock
            .as_ref()
            .expect("Expected function, got error."))(InsertBeforeBB, Name)
    }
    #[doc = " Remove a basic block from a function and delete it.\n\n This deletes the basic block from its containing function and deletes\n the basic block itself.\n\n @see llvm::BasicBlock::eraseFromParent()"]
    pub unsafe fn LLVMDeleteBasicBlock(&self, BB: LLVMBasicBlockRef) {
        (self
            .LLVMDeleteBasicBlock
            .as_ref()
            .expect("Expected function, got error."))(BB)
    }
    #[doc = " Remove a basic block from a function.\n\n This deletes the basic block from its containing function but keep\n the basic block alive.\n\n @see llvm::BasicBlock::removeFromParent()"]
    pub unsafe fn LLVMRemoveBasicBlockFromParent(&self, BB: LLVMBasicBlockRef) {
        (self
            .LLVMRemoveBasicBlockFromParent
            .as_ref()
            .expect("Expected function, got error."))(BB)
    }
    #[doc = " Move a basic block to before another one.\n\n @see llvm::BasicBlock::moveBefore()"]
    pub unsafe fn LLVMMoveBasicBlockBefore(
        &self,
        BB: LLVMBasicBlockRef,
        MovePos: LLVMBasicBlockRef,
    ) {
        (self
            .LLVMMoveBasicBlockBefore
            .as_ref()
            .expect("Expected function, got error."))(BB, MovePos)
    }
    #[doc = " Move a basic block to after another one.\n\n @see llvm::BasicBlock::moveAfter()"]
    pub unsafe fn LLVMMoveBasicBlockAfter(
        &self,
        BB: LLVMBasicBlockRef,
        MovePos: LLVMBasicBlockRef,
    ) {
        (self
            .LLVMMoveBasicBlockAfter
            .as_ref()
            .expect("Expected function, got error."))(BB, MovePos)
    }
    #[doc = " Obtain the first instruction in a basic block.\n\n The returned LLVMValueRef corresponds to a llvm::Instruction\n instance."]
    pub unsafe fn LLVMGetFirstInstruction(&self, BB: LLVMBasicBlockRef) -> LLVMValueRef {
        (self
            .LLVMGetFirstInstruction
            .as_ref()
            .expect("Expected function, got error."))(BB)
    }
    #[doc = " Obtain the last instruction in a basic block.\n\n The returned LLVMValueRef corresponds to an LLVM:Instruction."]
    pub unsafe fn LLVMGetLastInstruction(&self, BB: LLVMBasicBlockRef) -> LLVMValueRef {
        (self
            .LLVMGetLastInstruction
            .as_ref()
            .expect("Expected function, got error."))(BB)
    }
    #[doc = " Determine whether an instruction has any metadata attached."]
    pub unsafe fn LLVMHasMetadata(&self, Val: LLVMValueRef) -> ::std::os::raw::c_int {
        (self
            .LLVMHasMetadata
            .as_ref()
            .expect("Expected function, got error."))(Val)
    }
    #[doc = " Return metadata associated with an instruction value."]
    pub unsafe fn LLVMGetMetadata(
        &self,
        Val: LLVMValueRef,
        KindID: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMGetMetadata
            .as_ref()
            .expect("Expected function, got error."))(Val, KindID)
    }
    #[doc = " Set metadata associated with an instruction value."]
    pub unsafe fn LLVMSetMetadata(
        &self,
        Val: LLVMValueRef,
        KindID: ::std::os::raw::c_uint,
        Node: LLVMValueRef,
    ) {
        (self
            .LLVMSetMetadata
            .as_ref()
            .expect("Expected function, got error."))(Val, KindID, Node)
    }
    #[doc = " Returns the metadata associated with an instruction value, but filters out\n all the debug locations.\n\n @see llvm::Instruction::getAllMetadataOtherThanDebugLoc()"]
    pub unsafe fn LLVMInstructionGetAllMetadataOtherThanDebugLoc(
        &self,
        Instr: LLVMValueRef,
        NumEntries: *mut usize,
    ) -> *mut LLVMValueMetadataEntry {
        (self
            .LLVMInstructionGetAllMetadataOtherThanDebugLoc
            .as_ref()
            .expect("Expected function, got error."))(Instr, NumEntries)
    }
    #[doc = " Obtain the basic block to which an instruction belongs.\n\n @see llvm::Instruction::getParent()"]
    pub unsafe fn LLVMGetInstructionParent(&self, Inst: LLVMValueRef) -> LLVMBasicBlockRef {
        (self
            .LLVMGetInstructionParent
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Obtain the instruction that occurs after the one specified.\n\n The next instruction will be from the same basic block.\n\n If this is the last instruction in a basic block, NULL will be\n returned."]
    pub unsafe fn LLVMGetNextInstruction(&self, Inst: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetNextInstruction
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Obtain the instruction that occurred before this one.\n\n If the instruction is the first instruction in a basic block, NULL\n will be returned."]
    pub unsafe fn LLVMGetPreviousInstruction(&self, Inst: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetPreviousInstruction
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Remove an instruction.\n\n The instruction specified is removed from its containing building\n block but is kept alive.\n\n @see llvm::Instruction::removeFromParent()"]
    pub unsafe fn LLVMInstructionRemoveFromParent(&self, Inst: LLVMValueRef) {
        (self
            .LLVMInstructionRemoveFromParent
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Remove and delete an instruction.\n\n The instruction specified is removed from its containing building\n block and then deleted.\n\n @see llvm::Instruction::eraseFromParent()"]
    pub unsafe fn LLVMInstructionEraseFromParent(&self, Inst: LLVMValueRef) {
        (self
            .LLVMInstructionEraseFromParent
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Delete an instruction.\n\n The instruction specified is deleted. It must have previously been\n removed from its containing building block.\n\n @see llvm::Value::deleteValue()"]
    pub unsafe fn LLVMDeleteInstruction(&self, Inst: LLVMValueRef) {
        (self
            .LLVMDeleteInstruction
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Obtain the code opcode for an individual instruction.\n\n @see llvm::Instruction::getOpCode()"]
    pub unsafe fn LLVMGetInstructionOpcode(&self, Inst: LLVMValueRef) -> LLVMOpcode {
        (self
            .LLVMGetInstructionOpcode
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Obtain the predicate of an instruction.\n\n This is only valid for instructions that correspond to llvm::ICmpInst\n or llvm::ConstantExpr whose opcode is llvm::Instruction::ICmp.\n\n @see llvm::ICmpInst::getPredicate()"]
    pub unsafe fn LLVMGetICmpPredicate(&self, Inst: LLVMValueRef) -> LLVMIntPredicate {
        (self
            .LLVMGetICmpPredicate
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Obtain the float predicate of an instruction.\n\n This is only valid for instructions that correspond to llvm::FCmpInst\n or llvm::ConstantExpr whose opcode is llvm::Instruction::FCmp.\n\n @see llvm::FCmpInst::getPredicate()"]
    pub unsafe fn LLVMGetFCmpPredicate(&self, Inst: LLVMValueRef) -> LLVMRealPredicate {
        (self
            .LLVMGetFCmpPredicate
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Create a copy of 'this' instruction that is identical in all ways\n except the following:\n   * The instruction has no parent\n   * The instruction has no name\n\n @see llvm::Instruction::clone()"]
    pub unsafe fn LLVMInstructionClone(&self, Inst: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMInstructionClone
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Determine whether an instruction is a terminator. This routine is named to\n be compatible with historical functions that did this by querying the\n underlying C++ type.\n\n @see llvm::Instruction::isTerminator()"]
    pub unsafe fn LLVMIsATerminatorInst(&self, Inst: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMIsATerminatorInst
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Obtain the argument count for a call instruction.\n\n This expects an LLVMValueRef that corresponds to a llvm::CallInst,\n llvm::InvokeInst, or llvm:FuncletPadInst.\n\n @see llvm::CallInst::getNumArgOperands()\n @see llvm::InvokeInst::getNumArgOperands()\n @see llvm::FuncletPadInst::getNumArgOperands()"]
    pub unsafe fn LLVMGetNumArgOperands(&self, Instr: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetNumArgOperands
            .as_ref()
            .expect("Expected function, got error."))(Instr)
    }
    #[doc = " Set the calling convention for a call instruction.\n\n This expects an LLVMValueRef that corresponds to a llvm::CallInst or\n llvm::InvokeInst.\n\n @see llvm::CallInst::setCallingConv()\n @see llvm::InvokeInst::setCallingConv()"]
    pub unsafe fn LLVMSetInstructionCallConv(
        &self,
        Instr: LLVMValueRef,
        CC: ::std::os::raw::c_uint,
    ) {
        (self
            .LLVMSetInstructionCallConv
            .as_ref()
            .expect("Expected function, got error."))(Instr, CC)
    }
    #[doc = " Obtain the calling convention for a call instruction.\n\n This is the opposite of LLVMSetInstructionCallConv(). Reads its\n usage.\n\n @see LLVMSetInstructionCallConv()"]
    pub unsafe fn LLVMGetInstructionCallConv(&self, Instr: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetInstructionCallConv
            .as_ref()
            .expect("Expected function, got error."))(Instr)
    }
    pub unsafe fn LLVMSetInstrParamAlignment(
        &self,
        Instr: LLVMValueRef,
        Idx: LLVMAttributeIndex,
        Align: ::std::os::raw::c_uint,
    ) {
        (self
            .LLVMSetInstrParamAlignment
            .as_ref()
            .expect("Expected function, got error."))(Instr, Idx, Align)
    }
    pub unsafe fn LLVMAddCallSiteAttribute(
        &self,
        C: LLVMValueRef,
        Idx: LLVMAttributeIndex,
        A: LLVMAttributeRef,
    ) {
        (self
            .LLVMAddCallSiteAttribute
            .as_ref()
            .expect("Expected function, got error."))(C, Idx, A)
    }
    pub unsafe fn LLVMGetCallSiteAttributeCount(
        &self,
        C: LLVMValueRef,
        Idx: LLVMAttributeIndex,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetCallSiteAttributeCount
            .as_ref()
            .expect("Expected function, got error."))(C, Idx)
    }
    pub unsafe fn LLVMGetCallSiteAttributes(
        &self,
        C: LLVMValueRef,
        Idx: LLVMAttributeIndex,
        Attrs: *mut LLVMAttributeRef,
    ) {
        (self
            .LLVMGetCallSiteAttributes
            .as_ref()
            .expect("Expected function, got error."))(C, Idx, Attrs)
    }
    pub unsafe fn LLVMGetCallSiteEnumAttribute(
        &self,
        C: LLVMValueRef,
        Idx: LLVMAttributeIndex,
        KindID: ::std::os::raw::c_uint,
    ) -> LLVMAttributeRef {
        (self
            .LLVMGetCallSiteEnumAttribute
            .as_ref()
            .expect("Expected function, got error."))(C, Idx, KindID)
    }
    pub unsafe fn LLVMGetCallSiteStringAttribute(
        &self,
        C: LLVMValueRef,
        Idx: LLVMAttributeIndex,
        K: *const ::std::os::raw::c_char,
        KLen: ::std::os::raw::c_uint,
    ) -> LLVMAttributeRef {
        (self
            .LLVMGetCallSiteStringAttribute
            .as_ref()
            .expect("Expected function, got error."))(C, Idx, K, KLen)
    }
    pub unsafe fn LLVMRemoveCallSiteEnumAttribute(
        &self,
        C: LLVMValueRef,
        Idx: LLVMAttributeIndex,
        KindID: ::std::os::raw::c_uint,
    ) {
        (self
            .LLVMRemoveCallSiteEnumAttribute
            .as_ref()
            .expect("Expected function, got error."))(C, Idx, KindID)
    }
    pub unsafe fn LLVMRemoveCallSiteStringAttribute(
        &self,
        C: LLVMValueRef,
        Idx: LLVMAttributeIndex,
        K: *const ::std::os::raw::c_char,
        KLen: ::std::os::raw::c_uint,
    ) {
        (self
            .LLVMRemoveCallSiteStringAttribute
            .as_ref()
            .expect("Expected function, got error."))(C, Idx, K, KLen)
    }
    #[doc = " Obtain the function type called by this instruction.\n\n @see llvm::CallBase::getFunctionType()"]
    pub unsafe fn LLVMGetCalledFunctionType(&self, C: LLVMValueRef) -> LLVMTypeRef {
        (self
            .LLVMGetCalledFunctionType
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    #[doc = " Obtain the pointer to the function invoked by this instruction.\n\n This expects an LLVMValueRef that corresponds to a llvm::CallInst or\n llvm::InvokeInst.\n\n @see llvm::CallInst::getCalledOperand()\n @see llvm::InvokeInst::getCalledOperand()"]
    pub unsafe fn LLVMGetCalledValue(&self, Instr: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetCalledValue
            .as_ref()
            .expect("Expected function, got error."))(Instr)
    }
    #[doc = " Obtain whether a call instruction is a tail call.\n\n This only works on llvm::CallInst instructions.\n\n @see llvm::CallInst::isTailCall()"]
    pub unsafe fn LLVMIsTailCall(&self, CallInst: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsTailCall
            .as_ref()
            .expect("Expected function, got error."))(CallInst)
    }
    #[doc = " Set whether a call instruction is a tail call.\n\n This only works on llvm::CallInst instructions.\n\n @see llvm::CallInst::setTailCall()"]
    pub unsafe fn LLVMSetTailCall(&self, CallInst: LLVMValueRef, IsTailCall: LLVMBool) {
        (self
            .LLVMSetTailCall
            .as_ref()
            .expect("Expected function, got error."))(CallInst, IsTailCall)
    }
    #[doc = " Return the normal destination basic block.\n\n This only works on llvm::InvokeInst instructions.\n\n @see llvm::InvokeInst::getNormalDest()"]
    pub unsafe fn LLVMGetNormalDest(&self, InvokeInst: LLVMValueRef) -> LLVMBasicBlockRef {
        (self
            .LLVMGetNormalDest
            .as_ref()
            .expect("Expected function, got error."))(InvokeInst)
    }
    #[doc = " Return the unwind destination basic block.\n\n Works on llvm::InvokeInst, llvm::CleanupReturnInst, and\n llvm::CatchSwitchInst instructions.\n\n @see llvm::InvokeInst::getUnwindDest()\n @see llvm::CleanupReturnInst::getUnwindDest()\n @see llvm::CatchSwitchInst::getUnwindDest()"]
    pub unsafe fn LLVMGetUnwindDest(&self, InvokeInst: LLVMValueRef) -> LLVMBasicBlockRef {
        (self
            .LLVMGetUnwindDest
            .as_ref()
            .expect("Expected function, got error."))(InvokeInst)
    }
    #[doc = " Set the normal destination basic block.\n\n This only works on llvm::InvokeInst instructions.\n\n @see llvm::InvokeInst::setNormalDest()"]
    pub unsafe fn LLVMSetNormalDest(&self, InvokeInst: LLVMValueRef, B: LLVMBasicBlockRef) {
        (self
            .LLVMSetNormalDest
            .as_ref()
            .expect("Expected function, got error."))(InvokeInst, B)
    }
    #[doc = " Set the unwind destination basic block.\n\n Works on llvm::InvokeInst, llvm::CleanupReturnInst, and\n llvm::CatchSwitchInst instructions.\n\n @see llvm::InvokeInst::setUnwindDest()\n @see llvm::CleanupReturnInst::setUnwindDest()\n @see llvm::CatchSwitchInst::setUnwindDest()"]
    pub unsafe fn LLVMSetUnwindDest(&self, InvokeInst: LLVMValueRef, B: LLVMBasicBlockRef) {
        (self
            .LLVMSetUnwindDest
            .as_ref()
            .expect("Expected function, got error."))(InvokeInst, B)
    }
    #[doc = " Return the number of successors that this terminator has.\n\n @see llvm::Instruction::getNumSuccessors"]
    pub unsafe fn LLVMGetNumSuccessors(&self, Term: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetNumSuccessors
            .as_ref()
            .expect("Expected function, got error."))(Term)
    }
    #[doc = " Return the specified successor.\n\n @see llvm::Instruction::getSuccessor"]
    pub unsafe fn LLVMGetSuccessor(
        &self,
        Term: LLVMValueRef,
        i: ::std::os::raw::c_uint,
    ) -> LLVMBasicBlockRef {
        (self
            .LLVMGetSuccessor
            .as_ref()
            .expect("Expected function, got error."))(Term, i)
    }
    #[doc = " Update the specified successor to point at the provided block.\n\n @see llvm::Instruction::setSuccessor"]
    pub unsafe fn LLVMSetSuccessor(
        &self,
        Term: LLVMValueRef,
        i: ::std::os::raw::c_uint,
        block: LLVMBasicBlockRef,
    ) {
        (self
            .LLVMSetSuccessor
            .as_ref()
            .expect("Expected function, got error."))(Term, i, block)
    }
    #[doc = " Return if a branch is conditional.\n\n This only works on llvm::BranchInst instructions.\n\n @see llvm::BranchInst::isConditional"]
    pub unsafe fn LLVMIsConditional(&self, Branch: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsConditional
            .as_ref()
            .expect("Expected function, got error."))(Branch)
    }
    #[doc = " Return the condition of a branch instruction.\n\n This only works on llvm::BranchInst instructions.\n\n @see llvm::BranchInst::getCondition"]
    pub unsafe fn LLVMGetCondition(&self, Branch: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetCondition
            .as_ref()
            .expect("Expected function, got error."))(Branch)
    }
    #[doc = " Set the condition of a branch instruction.\n\n This only works on llvm::BranchInst instructions.\n\n @see llvm::BranchInst::setCondition"]
    pub unsafe fn LLVMSetCondition(&self, Branch: LLVMValueRef, Cond: LLVMValueRef) {
        (self
            .LLVMSetCondition
            .as_ref()
            .expect("Expected function, got error."))(Branch, Cond)
    }
    #[doc = " Obtain the default destination basic block of a switch instruction.\n\n This only works on llvm::SwitchInst instructions.\n\n @see llvm::SwitchInst::getDefaultDest()"]
    pub unsafe fn LLVMGetSwitchDefaultDest(&self, SwitchInstr: LLVMValueRef) -> LLVMBasicBlockRef {
        (self
            .LLVMGetSwitchDefaultDest
            .as_ref()
            .expect("Expected function, got error."))(SwitchInstr)
    }
    #[doc = " Obtain the type that is being allocated by the alloca instruction."]
    pub unsafe fn LLVMGetAllocatedType(&self, Alloca: LLVMValueRef) -> LLVMTypeRef {
        (self
            .LLVMGetAllocatedType
            .as_ref()
            .expect("Expected function, got error."))(Alloca)
    }
    #[doc = " Check whether the given GEP operator is inbounds."]
    pub unsafe fn LLVMIsInBounds(&self, GEP: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsInBounds
            .as_ref()
            .expect("Expected function, got error."))(GEP)
    }
    #[doc = " Set the given GEP instruction to be inbounds or not."]
    pub unsafe fn LLVMSetIsInBounds(&self, GEP: LLVMValueRef, InBounds: LLVMBool) {
        (self
            .LLVMSetIsInBounds
            .as_ref()
            .expect("Expected function, got error."))(GEP, InBounds)
    }
    #[doc = " Get the source element type of the given GEP operator."]
    pub unsafe fn LLVMGetGEPSourceElementType(&self, GEP: LLVMValueRef) -> LLVMTypeRef {
        (self
            .LLVMGetGEPSourceElementType
            .as_ref()
            .expect("Expected function, got error."))(GEP)
    }
    #[doc = " Add an incoming value to the end of a PHI list."]
    pub unsafe fn LLVMAddIncoming(
        &self,
        PhiNode: LLVMValueRef,
        IncomingValues: *mut LLVMValueRef,
        IncomingBlocks: *mut LLVMBasicBlockRef,
        Count: ::std::os::raw::c_uint,
    ) {
        (self
            .LLVMAddIncoming
            .as_ref()
            .expect("Expected function, got error."))(
            PhiNode,
            IncomingValues,
            IncomingBlocks,
            Count,
        )
    }
    #[doc = " Obtain the number of incoming basic blocks to a PHI node."]
    pub unsafe fn LLVMCountIncoming(&self, PhiNode: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMCountIncoming
            .as_ref()
            .expect("Expected function, got error."))(PhiNode)
    }
    #[doc = " Obtain an incoming value to a PHI node as an LLVMValueRef."]
    pub unsafe fn LLVMGetIncomingValue(
        &self,
        PhiNode: LLVMValueRef,
        Index: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMGetIncomingValue
            .as_ref()
            .expect("Expected function, got error."))(PhiNode, Index)
    }
    #[doc = " Obtain an incoming value to a PHI node as an LLVMBasicBlockRef."]
    pub unsafe fn LLVMGetIncomingBlock(
        &self,
        PhiNode: LLVMValueRef,
        Index: ::std::os::raw::c_uint,
    ) -> LLVMBasicBlockRef {
        (self
            .LLVMGetIncomingBlock
            .as_ref()
            .expect("Expected function, got error."))(PhiNode, Index)
    }
    #[doc = " Obtain the number of indices.\n NB: This also works on GEP operators."]
    pub unsafe fn LLVMGetNumIndices(&self, Inst: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetNumIndices
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Obtain the indices as an array."]
    pub unsafe fn LLVMGetIndices(&self, Inst: LLVMValueRef) -> *const ::std::os::raw::c_uint {
        (self
            .LLVMGetIndices
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " @defgroup LLVMCCoreInstructionBuilder Instruction Builders\n\n An instruction builder represents a point within a basic block and is\n the exclusive means of building instructions using the C interface.\n\n @{"]
    pub unsafe fn LLVMCreateBuilderInContext(&self, C: LLVMContextRef) -> LLVMBuilderRef {
        (self
            .LLVMCreateBuilderInContext
            .as_ref()
            .expect("Expected function, got error."))(C)
    }
    pub unsafe fn LLVMCreateBuilder(&self) -> LLVMBuilderRef {
        (self
            .LLVMCreateBuilder
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMPositionBuilder(
        &self,
        Builder: LLVMBuilderRef,
        Block: LLVMBasicBlockRef,
        Instr: LLVMValueRef,
    ) {
        (self
            .LLVMPositionBuilder
            .as_ref()
            .expect("Expected function, got error."))(Builder, Block, Instr)
    }
    pub unsafe fn LLVMPositionBuilderBefore(&self, Builder: LLVMBuilderRef, Instr: LLVMValueRef) {
        (self
            .LLVMPositionBuilderBefore
            .as_ref()
            .expect("Expected function, got error."))(Builder, Instr)
    }
    pub unsafe fn LLVMPositionBuilderAtEnd(
        &self,
        Builder: LLVMBuilderRef,
        Block: LLVMBasicBlockRef,
    ) {
        (self
            .LLVMPositionBuilderAtEnd
            .as_ref()
            .expect("Expected function, got error."))(Builder, Block)
    }
    pub unsafe fn LLVMGetInsertBlock(&self, Builder: LLVMBuilderRef) -> LLVMBasicBlockRef {
        (self
            .LLVMGetInsertBlock
            .as_ref()
            .expect("Expected function, got error."))(Builder)
    }
    pub unsafe fn LLVMClearInsertionPosition(&self, Builder: LLVMBuilderRef) {
        (self
            .LLVMClearInsertionPosition
            .as_ref()
            .expect("Expected function, got error."))(Builder)
    }
    pub unsafe fn LLVMInsertIntoBuilder(&self, Builder: LLVMBuilderRef, Instr: LLVMValueRef) {
        (self
            .LLVMInsertIntoBuilder
            .as_ref()
            .expect("Expected function, got error."))(Builder, Instr)
    }
    pub unsafe fn LLVMInsertIntoBuilderWithName(
        &self,
        Builder: LLVMBuilderRef,
        Instr: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) {
        (self
            .LLVMInsertIntoBuilderWithName
            .as_ref()
            .expect("Expected function, got error."))(Builder, Instr, Name)
    }
    pub unsafe fn LLVMDisposeBuilder(&self, Builder: LLVMBuilderRef) {
        (self
            .LLVMDisposeBuilder
            .as_ref()
            .expect("Expected function, got error."))(Builder)
    }
    #[doc = " Get location information used by debugging information.\n\n @see llvm::IRBuilder::getCurrentDebugLocation()"]
    pub unsafe fn LLVMGetCurrentDebugLocation2(&self, Builder: LLVMBuilderRef) -> LLVMMetadataRef {
        (self
            .LLVMGetCurrentDebugLocation2
            .as_ref()
            .expect("Expected function, got error."))(Builder)
    }
    #[doc = " Set location information used by debugging information.\n\n To clear the location metadata of the given instruction, pass NULL to \\p Loc.\n\n @see llvm::IRBuilder::SetCurrentDebugLocation()"]
    pub unsafe fn LLVMSetCurrentDebugLocation2(
        &self,
        Builder: LLVMBuilderRef,
        Loc: LLVMMetadataRef,
    ) {
        (self
            .LLVMSetCurrentDebugLocation2
            .as_ref()
            .expect("Expected function, got error."))(Builder, Loc)
    }
    #[doc = " Attempts to set the debug location for the given instruction using the\n current debug location for the given builder.  If the builder has no current\n debug location, this function is a no-op.\n\n @deprecated LLVMSetInstDebugLocation is deprecated in favor of the more general\n             LLVMAddMetadataToInst.\n\n @see llvm::IRBuilder::SetInstDebugLocation()"]
    pub unsafe fn LLVMSetInstDebugLocation(&self, Builder: LLVMBuilderRef, Inst: LLVMValueRef) {
        (self
            .LLVMSetInstDebugLocation
            .as_ref()
            .expect("Expected function, got error."))(Builder, Inst)
    }
    #[doc = " Adds the metadata registered with the given builder to the given instruction.\n\n @see llvm::IRBuilder::AddMetadataToInst()"]
    pub unsafe fn LLVMAddMetadataToInst(&self, Builder: LLVMBuilderRef, Inst: LLVMValueRef) {
        (self
            .LLVMAddMetadataToInst
            .as_ref()
            .expect("Expected function, got error."))(Builder, Inst)
    }
    #[doc = " Get the dafult floating-point math metadata for a given builder.\n\n @see llvm::IRBuilder::getDefaultFPMathTag()"]
    pub unsafe fn LLVMBuilderGetDefaultFPMathTag(
        &self,
        Builder: LLVMBuilderRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMBuilderGetDefaultFPMathTag
            .as_ref()
            .expect("Expected function, got error."))(Builder)
    }
    #[doc = " Set the default floating-point math metadata for the given builder.\n\n To clear the metadata, pass NULL to \\p FPMathTag.\n\n @see llvm::IRBuilder::setDefaultFPMathTag()"]
    pub unsafe fn LLVMBuilderSetDefaultFPMathTag(
        &self,
        Builder: LLVMBuilderRef,
        FPMathTag: LLVMMetadataRef,
    ) {
        (self
            .LLVMBuilderSetDefaultFPMathTag
            .as_ref()
            .expect("Expected function, got error."))(Builder, FPMathTag)
    }
    #[doc = " Deprecated: Passing the NULL location will crash.\n Use LLVMGetCurrentDebugLocation2 instead."]
    pub unsafe fn LLVMSetCurrentDebugLocation(&self, Builder: LLVMBuilderRef, L: LLVMValueRef) {
        (self
            .LLVMSetCurrentDebugLocation
            .as_ref()
            .expect("Expected function, got error."))(Builder, L)
    }
    #[doc = " Deprecated: Returning the NULL location will crash.\n Use LLVMGetCurrentDebugLocation2 instead."]
    pub unsafe fn LLVMGetCurrentDebugLocation(&self, Builder: LLVMBuilderRef) -> LLVMValueRef {
        (self
            .LLVMGetCurrentDebugLocation
            .as_ref()
            .expect("Expected function, got error."))(Builder)
    }
    pub unsafe fn LLVMBuildRetVoid(&self, arg1: LLVMBuilderRef) -> LLVMValueRef {
        (self
            .LLVMBuildRetVoid
            .as_ref()
            .expect("Expected function, got error."))(arg1)
    }
    pub unsafe fn LLVMBuildRet(&self, arg1: LLVMBuilderRef, V: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMBuildRet
            .as_ref()
            .expect("Expected function, got error."))(arg1, V)
    }
    pub unsafe fn LLVMBuildAggregateRet(
        &self,
        arg1: LLVMBuilderRef,
        RetVals: *mut LLVMValueRef,
        N: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildAggregateRet
            .as_ref()
            .expect("Expected function, got error."))(arg1, RetVals, N)
    }
    pub unsafe fn LLVMBuildBr(
        &self,
        arg1: LLVMBuilderRef,
        Dest: LLVMBasicBlockRef,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildBr
            .as_ref()
            .expect("Expected function, got error."))(arg1, Dest)
    }
    pub unsafe fn LLVMBuildCondBr(
        &self,
        arg1: LLVMBuilderRef,
        If: LLVMValueRef,
        Then: LLVMBasicBlockRef,
        Else: LLVMBasicBlockRef,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildCondBr
            .as_ref()
            .expect("Expected function, got error."))(arg1, If, Then, Else)
    }
    pub unsafe fn LLVMBuildSwitch(
        &self,
        arg1: LLVMBuilderRef,
        V: LLVMValueRef,
        Else: LLVMBasicBlockRef,
        NumCases: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildSwitch
            .as_ref()
            .expect("Expected function, got error."))(arg1, V, Else, NumCases)
    }
    pub unsafe fn LLVMBuildIndirectBr(
        &self,
        B: LLVMBuilderRef,
        Addr: LLVMValueRef,
        NumDests: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildIndirectBr
            .as_ref()
            .expect("Expected function, got error."))(B, Addr, NumDests)
    }
    pub unsafe fn LLVMBuildInvoke2(
        &self,
        arg1: LLVMBuilderRef,
        Ty: LLVMTypeRef,
        Fn: LLVMValueRef,
        Args: *mut LLVMValueRef,
        NumArgs: ::std::os::raw::c_uint,
        Then: LLVMBasicBlockRef,
        Catch: LLVMBasicBlockRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildInvoke2
            .as_ref()
            .expect("Expected function, got error."))(
            arg1, Ty, Fn, Args, NumArgs, Then, Catch, Name,
        )
    }
    pub unsafe fn LLVMBuildUnreachable(&self, arg1: LLVMBuilderRef) -> LLVMValueRef {
        (self
            .LLVMBuildUnreachable
            .as_ref()
            .expect("Expected function, got error."))(arg1)
    }
    pub unsafe fn LLVMBuildResume(&self, B: LLVMBuilderRef, Exn: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMBuildResume
            .as_ref()
            .expect("Expected function, got error."))(B, Exn)
    }
    pub unsafe fn LLVMBuildLandingPad(
        &self,
        B: LLVMBuilderRef,
        Ty: LLVMTypeRef,
        PersFn: LLVMValueRef,
        NumClauses: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildLandingPad
            .as_ref()
            .expect("Expected function, got error."))(B, Ty, PersFn, NumClauses, Name)
    }
    pub unsafe fn LLVMBuildCleanupRet(
        &self,
        B: LLVMBuilderRef,
        CatchPad: LLVMValueRef,
        BB: LLVMBasicBlockRef,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildCleanupRet
            .as_ref()
            .expect("Expected function, got error."))(B, CatchPad, BB)
    }
    pub unsafe fn LLVMBuildCatchRet(
        &self,
        B: LLVMBuilderRef,
        CatchPad: LLVMValueRef,
        BB: LLVMBasicBlockRef,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildCatchRet
            .as_ref()
            .expect("Expected function, got error."))(B, CatchPad, BB)
    }
    pub unsafe fn LLVMBuildCatchPad(
        &self,
        B: LLVMBuilderRef,
        ParentPad: LLVMValueRef,
        Args: *mut LLVMValueRef,
        NumArgs: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildCatchPad
            .as_ref()
            .expect("Expected function, got error."))(B, ParentPad, Args, NumArgs, Name)
    }
    pub unsafe fn LLVMBuildCleanupPad(
        &self,
        B: LLVMBuilderRef,
        ParentPad: LLVMValueRef,
        Args: *mut LLVMValueRef,
        NumArgs: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildCleanupPad
            .as_ref()
            .expect("Expected function, got error."))(B, ParentPad, Args, NumArgs, Name)
    }
    pub unsafe fn LLVMBuildCatchSwitch(
        &self,
        B: LLVMBuilderRef,
        ParentPad: LLVMValueRef,
        UnwindBB: LLVMBasicBlockRef,
        NumHandlers: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildCatchSwitch
            .as_ref()
            .expect("Expected function, got error."))(
            B, ParentPad, UnwindBB, NumHandlers, Name
        )
    }
    pub unsafe fn LLVMAddCase(
        &self,
        Switch: LLVMValueRef,
        OnVal: LLVMValueRef,
        Dest: LLVMBasicBlockRef,
    ) {
        (self
            .LLVMAddCase
            .as_ref()
            .expect("Expected function, got error."))(Switch, OnVal, Dest)
    }
    pub unsafe fn LLVMAddDestination(&self, IndirectBr: LLVMValueRef, Dest: LLVMBasicBlockRef) {
        (self
            .LLVMAddDestination
            .as_ref()
            .expect("Expected function, got error."))(IndirectBr, Dest)
    }
    pub unsafe fn LLVMGetNumClauses(&self, LandingPad: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetNumClauses
            .as_ref()
            .expect("Expected function, got error."))(LandingPad)
    }
    pub unsafe fn LLVMGetClause(
        &self,
        LandingPad: LLVMValueRef,
        Idx: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMGetClause
            .as_ref()
            .expect("Expected function, got error."))(LandingPad, Idx)
    }
    pub unsafe fn LLVMAddClause(&self, LandingPad: LLVMValueRef, ClauseVal: LLVMValueRef) {
        (self
            .LLVMAddClause
            .as_ref()
            .expect("Expected function, got error."))(LandingPad, ClauseVal)
    }
    pub unsafe fn LLVMIsCleanup(&self, LandingPad: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsCleanup
            .as_ref()
            .expect("Expected function, got error."))(LandingPad)
    }
    pub unsafe fn LLVMSetCleanup(&self, LandingPad: LLVMValueRef, Val: LLVMBool) {
        (self
            .LLVMSetCleanup
            .as_ref()
            .expect("Expected function, got error."))(LandingPad, Val)
    }
    pub unsafe fn LLVMAddHandler(&self, CatchSwitch: LLVMValueRef, Dest: LLVMBasicBlockRef) {
        (self
            .LLVMAddHandler
            .as_ref()
            .expect("Expected function, got error."))(CatchSwitch, Dest)
    }
    pub unsafe fn LLVMGetNumHandlers(&self, CatchSwitch: LLVMValueRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetNumHandlers
            .as_ref()
            .expect("Expected function, got error."))(CatchSwitch)
    }
    #[doc = " Obtain the basic blocks acting as handlers for a catchswitch instruction.\n\n The Handlers parameter should point to a pre-allocated array of\n LLVMBasicBlockRefs at least LLVMGetNumHandlers() large. On return, the\n first LLVMGetNumHandlers() entries in the array will be populated\n with LLVMBasicBlockRef instances.\n\n @param CatchSwitch The catchswitch instruction to operate on.\n @param Handlers Memory address of an array to be filled with basic blocks."]
    pub unsafe fn LLVMGetHandlers(
        &self,
        CatchSwitch: LLVMValueRef,
        Handlers: *mut LLVMBasicBlockRef,
    ) {
        (self
            .LLVMGetHandlers
            .as_ref()
            .expect("Expected function, got error."))(CatchSwitch, Handlers)
    }
    pub unsafe fn LLVMGetArgOperand(
        &self,
        Funclet: LLVMValueRef,
        i: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMGetArgOperand
            .as_ref()
            .expect("Expected function, got error."))(Funclet, i)
    }
    pub unsafe fn LLVMSetArgOperand(
        &self,
        Funclet: LLVMValueRef,
        i: ::std::os::raw::c_uint,
        value: LLVMValueRef,
    ) {
        (self
            .LLVMSetArgOperand
            .as_ref()
            .expect("Expected function, got error."))(Funclet, i, value)
    }
    #[doc = " Get the parent catchswitch instruction of a catchpad instruction.\n\n This only works on llvm::CatchPadInst instructions.\n\n @see llvm::CatchPadInst::getCatchSwitch()"]
    pub unsafe fn LLVMGetParentCatchSwitch(&self, CatchPad: LLVMValueRef) -> LLVMValueRef {
        (self
            .LLVMGetParentCatchSwitch
            .as_ref()
            .expect("Expected function, got error."))(CatchPad)
    }
    #[doc = " Set the parent catchswitch instruction of a catchpad instruction.\n\n This only works on llvm::CatchPadInst instructions.\n\n @see llvm::CatchPadInst::setCatchSwitch()"]
    pub unsafe fn LLVMSetParentCatchSwitch(
        &self,
        CatchPad: LLVMValueRef,
        CatchSwitch: LLVMValueRef,
    ) {
        (self
            .LLVMSetParentCatchSwitch
            .as_ref()
            .expect("Expected function, got error."))(CatchPad, CatchSwitch)
    }
    pub unsafe fn LLVMBuildAdd(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildAdd
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildNSWAdd(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildNSWAdd
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildNUWAdd(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildNUWAdd
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildFAdd(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFAdd
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildSub(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildSub
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildNSWSub(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildNSWSub
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildNUWSub(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildNUWSub
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildFSub(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFSub
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildMul(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildMul
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildNSWMul(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildNSWMul
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildNUWMul(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildNUWMul
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildFMul(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFMul
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildUDiv(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildUDiv
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildExactUDiv(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildExactUDiv
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildSDiv(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildSDiv
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildExactSDiv(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildExactSDiv
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildFDiv(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFDiv
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildURem(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildURem
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildSRem(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildSRem
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildFRem(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFRem
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildShl(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildShl
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildLShr(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildLShr
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildAShr(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildAShr
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildAnd(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildAnd
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildOr(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildOr
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildXor(
        &self,
        arg1: LLVMBuilderRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildXor
            .as_ref()
            .expect("Expected function, got error."))(arg1, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildBinOp(
        &self,
        B: LLVMBuilderRef,
        Op: LLVMOpcode,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildBinOp
            .as_ref()
            .expect("Expected function, got error."))(B, Op, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildNeg(
        &self,
        arg1: LLVMBuilderRef,
        V: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildNeg
            .as_ref()
            .expect("Expected function, got error."))(arg1, V, Name)
    }
    pub unsafe fn LLVMBuildNSWNeg(
        &self,
        B: LLVMBuilderRef,
        V: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildNSWNeg
            .as_ref()
            .expect("Expected function, got error."))(B, V, Name)
    }
    pub unsafe fn LLVMBuildNUWNeg(
        &self,
        B: LLVMBuilderRef,
        V: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildNUWNeg
            .as_ref()
            .expect("Expected function, got error."))(B, V, Name)
    }
    pub unsafe fn LLVMBuildFNeg(
        &self,
        arg1: LLVMBuilderRef,
        V: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFNeg
            .as_ref()
            .expect("Expected function, got error."))(arg1, V, Name)
    }
    pub unsafe fn LLVMBuildNot(
        &self,
        arg1: LLVMBuilderRef,
        V: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildNot
            .as_ref()
            .expect("Expected function, got error."))(arg1, V, Name)
    }
    pub unsafe fn LLVMGetNUW(&self, ArithInst: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMGetNUW
            .as_ref()
            .expect("Expected function, got error."))(ArithInst)
    }
    pub unsafe fn LLVMSetNUW(&self, ArithInst: LLVMValueRef, HasNUW: LLVMBool) {
        (self
            .LLVMSetNUW
            .as_ref()
            .expect("Expected function, got error."))(ArithInst, HasNUW)
    }
    pub unsafe fn LLVMGetNSW(&self, ArithInst: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMGetNSW
            .as_ref()
            .expect("Expected function, got error."))(ArithInst)
    }
    pub unsafe fn LLVMSetNSW(&self, ArithInst: LLVMValueRef, HasNSW: LLVMBool) {
        (self
            .LLVMSetNSW
            .as_ref()
            .expect("Expected function, got error."))(ArithInst, HasNSW)
    }
    pub unsafe fn LLVMGetExact(&self, DivOrShrInst: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMGetExact
            .as_ref()
            .expect("Expected function, got error."))(DivOrShrInst)
    }
    pub unsafe fn LLVMSetExact(&self, DivOrShrInst: LLVMValueRef, IsExact: LLVMBool) {
        (self
            .LLVMSetExact
            .as_ref()
            .expect("Expected function, got error."))(DivOrShrInst, IsExact)
    }
    pub unsafe fn LLVMBuildMalloc(
        &self,
        arg1: LLVMBuilderRef,
        Ty: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildMalloc
            .as_ref()
            .expect("Expected function, got error."))(arg1, Ty, Name)
    }
    pub unsafe fn LLVMBuildArrayMalloc(
        &self,
        arg1: LLVMBuilderRef,
        Ty: LLVMTypeRef,
        Val: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildArrayMalloc
            .as_ref()
            .expect("Expected function, got error."))(arg1, Ty, Val, Name)
    }
    #[doc = " Creates and inserts a memset to the specified pointer and the\n specified value.\n\n @see llvm::IRRBuilder::CreateMemSet()"]
    pub unsafe fn LLVMBuildMemSet(
        &self,
        B: LLVMBuilderRef,
        Ptr: LLVMValueRef,
        Val: LLVMValueRef,
        Len: LLVMValueRef,
        Align: ::std::os::raw::c_uint,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildMemSet
            .as_ref()
            .expect("Expected function, got error."))(B, Ptr, Val, Len, Align)
    }
    #[doc = " Creates and inserts a memcpy between the specified pointers.\n\n @see llvm::IRRBuilder::CreateMemCpy()"]
    pub unsafe fn LLVMBuildMemCpy(
        &self,
        B: LLVMBuilderRef,
        Dst: LLVMValueRef,
        DstAlign: ::std::os::raw::c_uint,
        Src: LLVMValueRef,
        SrcAlign: ::std::os::raw::c_uint,
        Size: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildMemCpy
            .as_ref()
            .expect("Expected function, got error."))(B, Dst, DstAlign, Src, SrcAlign, Size)
    }
    #[doc = " Creates and inserts a memmove between the specified pointers.\n\n @see llvm::IRRBuilder::CreateMemMove()"]
    pub unsafe fn LLVMBuildMemMove(
        &self,
        B: LLVMBuilderRef,
        Dst: LLVMValueRef,
        DstAlign: ::std::os::raw::c_uint,
        Src: LLVMValueRef,
        SrcAlign: ::std::os::raw::c_uint,
        Size: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildMemMove
            .as_ref()
            .expect("Expected function, got error."))(B, Dst, DstAlign, Src, SrcAlign, Size)
    }
    pub unsafe fn LLVMBuildAlloca(
        &self,
        arg1: LLVMBuilderRef,
        Ty: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildAlloca
            .as_ref()
            .expect("Expected function, got error."))(arg1, Ty, Name)
    }
    pub unsafe fn LLVMBuildArrayAlloca(
        &self,
        arg1: LLVMBuilderRef,
        Ty: LLVMTypeRef,
        Val: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildArrayAlloca
            .as_ref()
            .expect("Expected function, got error."))(arg1, Ty, Val, Name)
    }
    pub unsafe fn LLVMBuildFree(
        &self,
        arg1: LLVMBuilderRef,
        PointerVal: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFree
            .as_ref()
            .expect("Expected function, got error."))(arg1, PointerVal)
    }
    pub unsafe fn LLVMBuildLoad2(
        &self,
        arg1: LLVMBuilderRef,
        Ty: LLVMTypeRef,
        PointerVal: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildLoad2
            .as_ref()
            .expect("Expected function, got error."))(arg1, Ty, PointerVal, Name)
    }
    pub unsafe fn LLVMBuildStore(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        Ptr: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildStore
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, Ptr)
    }
    pub unsafe fn LLVMBuildGEP2(
        &self,
        B: LLVMBuilderRef,
        Ty: LLVMTypeRef,
        Pointer: LLVMValueRef,
        Indices: *mut LLVMValueRef,
        NumIndices: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildGEP2
            .as_ref()
            .expect("Expected function, got error."))(
            B, Ty, Pointer, Indices, NumIndices, Name
        )
    }
    pub unsafe fn LLVMBuildInBoundsGEP2(
        &self,
        B: LLVMBuilderRef,
        Ty: LLVMTypeRef,
        Pointer: LLVMValueRef,
        Indices: *mut LLVMValueRef,
        NumIndices: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildInBoundsGEP2
            .as_ref()
            .expect("Expected function, got error."))(
            B, Ty, Pointer, Indices, NumIndices, Name
        )
    }
    pub unsafe fn LLVMBuildStructGEP2(
        &self,
        B: LLVMBuilderRef,
        Ty: LLVMTypeRef,
        Pointer: LLVMValueRef,
        Idx: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildStructGEP2
            .as_ref()
            .expect("Expected function, got error."))(B, Ty, Pointer, Idx, Name)
    }
    pub unsafe fn LLVMBuildGlobalString(
        &self,
        B: LLVMBuilderRef,
        Str: *const ::std::os::raw::c_char,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildGlobalString
            .as_ref()
            .expect("Expected function, got error."))(B, Str, Name)
    }
    pub unsafe fn LLVMBuildGlobalStringPtr(
        &self,
        B: LLVMBuilderRef,
        Str: *const ::std::os::raw::c_char,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildGlobalStringPtr
            .as_ref()
            .expect("Expected function, got error."))(B, Str, Name)
    }
    pub unsafe fn LLVMGetVolatile(&self, MemoryAccessInst: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMGetVolatile
            .as_ref()
            .expect("Expected function, got error."))(MemoryAccessInst)
    }
    pub unsafe fn LLVMSetVolatile(&self, MemoryAccessInst: LLVMValueRef, IsVolatile: LLVMBool) {
        (self
            .LLVMSetVolatile
            .as_ref()
            .expect("Expected function, got error."))(MemoryAccessInst, IsVolatile)
    }
    pub unsafe fn LLVMGetWeak(&self, CmpXchgInst: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMGetWeak
            .as_ref()
            .expect("Expected function, got error."))(CmpXchgInst)
    }
    pub unsafe fn LLVMSetWeak(&self, CmpXchgInst: LLVMValueRef, IsWeak: LLVMBool) {
        (self
            .LLVMSetWeak
            .as_ref()
            .expect("Expected function, got error."))(CmpXchgInst, IsWeak)
    }
    pub unsafe fn LLVMGetOrdering(&self, MemoryAccessInst: LLVMValueRef) -> LLVMAtomicOrdering {
        (self
            .LLVMGetOrdering
            .as_ref()
            .expect("Expected function, got error."))(MemoryAccessInst)
    }
    pub unsafe fn LLVMSetOrdering(
        &self,
        MemoryAccessInst: LLVMValueRef,
        Ordering: LLVMAtomicOrdering,
    ) {
        (self
            .LLVMSetOrdering
            .as_ref()
            .expect("Expected function, got error."))(MemoryAccessInst, Ordering)
    }
    pub unsafe fn LLVMGetAtomicRMWBinOp(&self, AtomicRMWInst: LLVMValueRef) -> LLVMAtomicRMWBinOp {
        (self
            .LLVMGetAtomicRMWBinOp
            .as_ref()
            .expect("Expected function, got error."))(AtomicRMWInst)
    }
    pub unsafe fn LLVMSetAtomicRMWBinOp(
        &self,
        AtomicRMWInst: LLVMValueRef,
        BinOp: LLVMAtomicRMWBinOp,
    ) {
        (self
            .LLVMSetAtomicRMWBinOp
            .as_ref()
            .expect("Expected function, got error."))(AtomicRMWInst, BinOp)
    }
    pub unsafe fn LLVMBuildTrunc(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildTrunc
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildZExt(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildZExt
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildSExt(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildSExt
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildFPToUI(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFPToUI
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildFPToSI(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFPToSI
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildUIToFP(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildUIToFP
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildSIToFP(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildSIToFP
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildFPTrunc(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFPTrunc
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildFPExt(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFPExt
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildPtrToInt(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildPtrToInt
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildIntToPtr(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildIntToPtr
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildBitCast(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildBitCast
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildAddrSpaceCast(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildAddrSpaceCast
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildZExtOrBitCast(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildZExtOrBitCast
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildSExtOrBitCast(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildSExtOrBitCast
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildTruncOrBitCast(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildTruncOrBitCast
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildCast(
        &self,
        B: LLVMBuilderRef,
        Op: LLVMOpcode,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildCast
            .as_ref()
            .expect("Expected function, got error."))(B, Op, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildPointerCast(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildPointerCast
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMBuildIntCast2(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        IsSigned: LLVMBool,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildIntCast2
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, IsSigned, Name)
    }
    pub unsafe fn LLVMBuildFPCast(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFPCast
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    #[doc = " Deprecated: This cast is always signed. Use LLVMBuildIntCast2 instead."]
    pub unsafe fn LLVMBuildIntCast(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        DestTy: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildIntCast
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, DestTy, Name)
    }
    pub unsafe fn LLVMGetCastOpcode(
        &self,
        Src: LLVMValueRef,
        SrcIsSigned: LLVMBool,
        DestTy: LLVMTypeRef,
        DestIsSigned: LLVMBool,
    ) -> LLVMOpcode {
        (self
            .LLVMGetCastOpcode
            .as_ref()
            .expect("Expected function, got error."))(Src, SrcIsSigned, DestTy, DestIsSigned)
    }
    pub unsafe fn LLVMBuildICmp(
        &self,
        arg1: LLVMBuilderRef,
        Op: LLVMIntPredicate,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildICmp
            .as_ref()
            .expect("Expected function, got error."))(arg1, Op, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildFCmp(
        &self,
        arg1: LLVMBuilderRef,
        Op: LLVMRealPredicate,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFCmp
            .as_ref()
            .expect("Expected function, got error."))(arg1, Op, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildPhi(
        &self,
        arg1: LLVMBuilderRef,
        Ty: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildPhi
            .as_ref()
            .expect("Expected function, got error."))(arg1, Ty, Name)
    }
    pub unsafe fn LLVMBuildCall2(
        &self,
        arg1: LLVMBuilderRef,
        arg2: LLVMTypeRef,
        Fn: LLVMValueRef,
        Args: *mut LLVMValueRef,
        NumArgs: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildCall2
            .as_ref()
            .expect("Expected function, got error."))(arg1, arg2, Fn, Args, NumArgs, Name)
    }
    pub unsafe fn LLVMBuildSelect(
        &self,
        arg1: LLVMBuilderRef,
        If: LLVMValueRef,
        Then: LLVMValueRef,
        Else: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildSelect
            .as_ref()
            .expect("Expected function, got error."))(arg1, If, Then, Else, Name)
    }
    pub unsafe fn LLVMBuildVAArg(
        &self,
        arg1: LLVMBuilderRef,
        List: LLVMValueRef,
        Ty: LLVMTypeRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildVAArg
            .as_ref()
            .expect("Expected function, got error."))(arg1, List, Ty, Name)
    }
    pub unsafe fn LLVMBuildExtractElement(
        &self,
        arg1: LLVMBuilderRef,
        VecVal: LLVMValueRef,
        Index: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildExtractElement
            .as_ref()
            .expect("Expected function, got error."))(arg1, VecVal, Index, Name)
    }
    pub unsafe fn LLVMBuildInsertElement(
        &self,
        arg1: LLVMBuilderRef,
        VecVal: LLVMValueRef,
        EltVal: LLVMValueRef,
        Index: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildInsertElement
            .as_ref()
            .expect("Expected function, got error."))(arg1, VecVal, EltVal, Index, Name)
    }
    pub unsafe fn LLVMBuildShuffleVector(
        &self,
        arg1: LLVMBuilderRef,
        V1: LLVMValueRef,
        V2: LLVMValueRef,
        Mask: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildShuffleVector
            .as_ref()
            .expect("Expected function, got error."))(arg1, V1, V2, Mask, Name)
    }
    pub unsafe fn LLVMBuildExtractValue(
        &self,
        arg1: LLVMBuilderRef,
        AggVal: LLVMValueRef,
        Index: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildExtractValue
            .as_ref()
            .expect("Expected function, got error."))(arg1, AggVal, Index, Name)
    }
    pub unsafe fn LLVMBuildInsertValue(
        &self,
        arg1: LLVMBuilderRef,
        AggVal: LLVMValueRef,
        EltVal: LLVMValueRef,
        Index: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildInsertValue
            .as_ref()
            .expect("Expected function, got error."))(arg1, AggVal, EltVal, Index, Name)
    }
    pub unsafe fn LLVMBuildFreeze(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFreeze
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, Name)
    }
    pub unsafe fn LLVMBuildIsNull(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildIsNull
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, Name)
    }
    pub unsafe fn LLVMBuildIsNotNull(
        &self,
        arg1: LLVMBuilderRef,
        Val: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildIsNotNull
            .as_ref()
            .expect("Expected function, got error."))(arg1, Val, Name)
    }
    pub unsafe fn LLVMBuildPtrDiff2(
        &self,
        arg1: LLVMBuilderRef,
        ElemTy: LLVMTypeRef,
        LHS: LLVMValueRef,
        RHS: LLVMValueRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildPtrDiff2
            .as_ref()
            .expect("Expected function, got error."))(arg1, ElemTy, LHS, RHS, Name)
    }
    pub unsafe fn LLVMBuildFence(
        &self,
        B: LLVMBuilderRef,
        ordering: LLVMAtomicOrdering,
        singleThread: LLVMBool,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildFence
            .as_ref()
            .expect("Expected function, got error."))(B, ordering, singleThread, Name)
    }
    pub unsafe fn LLVMBuildAtomicRMW(
        &self,
        B: LLVMBuilderRef,
        op: LLVMAtomicRMWBinOp,
        PTR: LLVMValueRef,
        Val: LLVMValueRef,
        ordering: LLVMAtomicOrdering,
        singleThread: LLVMBool,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildAtomicRMW
            .as_ref()
            .expect("Expected function, got error."))(
            B, op, PTR, Val, ordering, singleThread
        )
    }
    pub unsafe fn LLVMBuildAtomicCmpXchg(
        &self,
        B: LLVMBuilderRef,
        Ptr: LLVMValueRef,
        Cmp: LLVMValueRef,
        New: LLVMValueRef,
        SuccessOrdering: LLVMAtomicOrdering,
        FailureOrdering: LLVMAtomicOrdering,
        SingleThread: LLVMBool,
    ) -> LLVMValueRef {
        (self
            .LLVMBuildAtomicCmpXchg
            .as_ref()
            .expect("Expected function, got error."))(
            B,
            Ptr,
            Cmp,
            New,
            SuccessOrdering,
            FailureOrdering,
            SingleThread,
        )
    }
    #[doc = " Get the number of elements in the mask of a ShuffleVector instruction."]
    pub unsafe fn LLVMGetNumMaskElements(
        &self,
        ShuffleVectorInst: LLVMValueRef,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetNumMaskElements
            .as_ref()
            .expect("Expected function, got error."))(ShuffleVectorInst)
    }
    #[doc = " \\returns a constant that specifies that the result of a \\c ShuffleVectorInst\n is undefined."]
    pub unsafe fn LLVMGetUndefMaskElem(&self) -> ::std::os::raw::c_int {
        (self
            .LLVMGetUndefMaskElem
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Get the mask value at position Elt in the mask of a ShuffleVector\n instruction.\n\n \\Returns the result of \\c LLVMGetUndefMaskElem() if the mask value is\n poison at that position."]
    pub unsafe fn LLVMGetMaskValue(
        &self,
        ShuffleVectorInst: LLVMValueRef,
        Elt: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int {
        (self
            .LLVMGetMaskValue
            .as_ref()
            .expect("Expected function, got error."))(ShuffleVectorInst, Elt)
    }
    pub unsafe fn LLVMIsAtomicSingleThread(&self, AtomicInst: LLVMValueRef) -> LLVMBool {
        (self
            .LLVMIsAtomicSingleThread
            .as_ref()
            .expect("Expected function, got error."))(AtomicInst)
    }
    pub unsafe fn LLVMSetAtomicSingleThread(
        &self,
        AtomicInst: LLVMValueRef,
        SingleThread: LLVMBool,
    ) {
        (self
            .LLVMSetAtomicSingleThread
            .as_ref()
            .expect("Expected function, got error."))(AtomicInst, SingleThread)
    }
    pub unsafe fn LLVMGetCmpXchgSuccessOrdering(
        &self,
        CmpXchgInst: LLVMValueRef,
    ) -> LLVMAtomicOrdering {
        (self
            .LLVMGetCmpXchgSuccessOrdering
            .as_ref()
            .expect("Expected function, got error."))(CmpXchgInst)
    }
    pub unsafe fn LLVMSetCmpXchgSuccessOrdering(
        &self,
        CmpXchgInst: LLVMValueRef,
        Ordering: LLVMAtomicOrdering,
    ) {
        (self
            .LLVMSetCmpXchgSuccessOrdering
            .as_ref()
            .expect("Expected function, got error."))(CmpXchgInst, Ordering)
    }
    pub unsafe fn LLVMGetCmpXchgFailureOrdering(
        &self,
        CmpXchgInst: LLVMValueRef,
    ) -> LLVMAtomicOrdering {
        (self
            .LLVMGetCmpXchgFailureOrdering
            .as_ref()
            .expect("Expected function, got error."))(CmpXchgInst)
    }
    pub unsafe fn LLVMSetCmpXchgFailureOrdering(
        &self,
        CmpXchgInst: LLVMValueRef,
        Ordering: LLVMAtomicOrdering,
    ) {
        (self
            .LLVMSetCmpXchgFailureOrdering
            .as_ref()
            .expect("Expected function, got error."))(CmpXchgInst, Ordering)
    }
    #[doc = " Changes the type of M so it can be passed to FunctionPassManagers and the\n JIT.  They take ModuleProviders for historical reasons."]
    pub unsafe fn LLVMCreateModuleProviderForExistingModule(
        &self,
        M: LLVMModuleRef,
    ) -> LLVMModuleProviderRef {
        (self
            .LLVMCreateModuleProviderForExistingModule
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Destroys the module M."]
    pub unsafe fn LLVMDisposeModuleProvider(&self, M: LLVMModuleProviderRef) {
        (self
            .LLVMDisposeModuleProvider
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " @defgroup LLVMCCoreMemoryBuffers Memory Buffers\n\n @{"]
    pub unsafe fn LLVMCreateMemoryBufferWithContentsOfFile(
        &self,
        Path: *const ::std::os::raw::c_char,
        OutMemBuf: *mut LLVMMemoryBufferRef,
        OutMessage: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMCreateMemoryBufferWithContentsOfFile
            .as_ref()
            .expect("Expected function, got error."))(Path, OutMemBuf, OutMessage)
    }
    pub unsafe fn LLVMCreateMemoryBufferWithSTDIN(
        &self,
        OutMemBuf: *mut LLVMMemoryBufferRef,
        OutMessage: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMCreateMemoryBufferWithSTDIN
            .as_ref()
            .expect("Expected function, got error."))(OutMemBuf, OutMessage)
    }
    pub unsafe fn LLVMCreateMemoryBufferWithMemoryRange(
        &self,
        InputData: *const ::std::os::raw::c_char,
        InputDataLength: usize,
        BufferName: *const ::std::os::raw::c_char,
        RequiresNullTerminator: LLVMBool,
    ) -> LLVMMemoryBufferRef {
        (self
            .LLVMCreateMemoryBufferWithMemoryRange
            .as_ref()
            .expect("Expected function, got error."))(
            InputData,
            InputDataLength,
            BufferName,
            RequiresNullTerminator,
        )
    }
    pub unsafe fn LLVMCreateMemoryBufferWithMemoryRangeCopy(
        &self,
        InputData: *const ::std::os::raw::c_char,
        InputDataLength: usize,
        BufferName: *const ::std::os::raw::c_char,
    ) -> LLVMMemoryBufferRef {
        (self
            .LLVMCreateMemoryBufferWithMemoryRangeCopy
            .as_ref()
            .expect("Expected function, got error."))(InputData, InputDataLength, BufferName)
    }
    pub unsafe fn LLVMGetBufferStart(
        &self,
        MemBuf: LLVMMemoryBufferRef,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetBufferStart
            .as_ref()
            .expect("Expected function, got error."))(MemBuf)
    }
    pub unsafe fn LLVMGetBufferSize(&self, MemBuf: LLVMMemoryBufferRef) -> usize {
        (self
            .LLVMGetBufferSize
            .as_ref()
            .expect("Expected function, got error."))(MemBuf)
    }
    pub unsafe fn LLVMDisposeMemoryBuffer(&self, MemBuf: LLVMMemoryBufferRef) {
        (self
            .LLVMDisposeMemoryBuffer
            .as_ref()
            .expect("Expected function, got error."))(MemBuf)
    }
    #[doc = " Constructs a new whole-module pass pipeline. This type of pipeline is\nsuitable for link-time optimization and whole-module transformations.\n@see llvm::PassManager::PassManager"]
    pub unsafe fn LLVMCreatePassManager(&self) -> LLVMPassManagerRef {
        (self
            .LLVMCreatePassManager
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Constructs a new function-by-function pass pipeline over the module\nprovider. It does not take ownership of the module provider. This type of\npipeline is suitable for code generation and JIT compilation tasks.\n@see llvm::FunctionPassManager::FunctionPassManager"]
    pub unsafe fn LLVMCreateFunctionPassManagerForModule(
        &self,
        M: LLVMModuleRef,
    ) -> LLVMPassManagerRef {
        (self
            .LLVMCreateFunctionPassManagerForModule
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Deprecated: Use LLVMCreateFunctionPassManagerForModule instead."]
    pub unsafe fn LLVMCreateFunctionPassManager(
        &self,
        MP: LLVMModuleProviderRef,
    ) -> LLVMPassManagerRef {
        (self
            .LLVMCreateFunctionPassManager
            .as_ref()
            .expect("Expected function, got error."))(MP)
    }
    #[doc = " Initializes, executes on the provided module, and finalizes all of the\npasses scheduled in the pass manager. Returns 1 if any of the passes\nmodified the module, 0 otherwise.\n@see llvm::PassManager::run(Module&)"]
    pub unsafe fn LLVMRunPassManager(&self, PM: LLVMPassManagerRef, M: LLVMModuleRef) -> LLVMBool {
        (self
            .LLVMRunPassManager
            .as_ref()
            .expect("Expected function, got error."))(PM, M)
    }
    #[doc = " Initializes all of the function passes scheduled in the function pass\nmanager. Returns 1 if any of the passes modified the module, 0 otherwise.\n@see llvm::FunctionPassManager::doInitialization"]
    pub unsafe fn LLVMInitializeFunctionPassManager(&self, FPM: LLVMPassManagerRef) -> LLVMBool {
        (self
            .LLVMInitializeFunctionPassManager
            .as_ref()
            .expect("Expected function, got error."))(FPM)
    }
    #[doc = " Executes all of the function passes scheduled in the function pass manager\non the provided function. Returns 1 if any of the passes modified the\nfunction, false otherwise.\n@see llvm::FunctionPassManager::run(Function&)"]
    pub unsafe fn LLVMRunFunctionPassManager(
        &self,
        FPM: LLVMPassManagerRef,
        F: LLVMValueRef,
    ) -> LLVMBool {
        (self
            .LLVMRunFunctionPassManager
            .as_ref()
            .expect("Expected function, got error."))(FPM, F)
    }
    #[doc = " Finalizes all of the function passes scheduled in the function pass\nmanager. Returns 1 if any of the passes modified the module, 0 otherwise.\n@see llvm::FunctionPassManager::doFinalization"]
    pub unsafe fn LLVMFinalizeFunctionPassManager(&self, FPM: LLVMPassManagerRef) -> LLVMBool {
        (self
            .LLVMFinalizeFunctionPassManager
            .as_ref()
            .expect("Expected function, got error."))(FPM)
    }
    #[doc = " Frees the memory of a pass pipeline. For function pipelines, does not free\nthe module provider.\n@see llvm::PassManagerBase::~PassManagerBase."]
    pub unsafe fn LLVMDisposePassManager(&self, PM: LLVMPassManagerRef) {
        (self
            .LLVMDisposePassManager
            .as_ref()
            .expect("Expected function, got error."))(PM)
    }
    #[doc = " Deprecated: Multi-threading can only be enabled/disabled with the compile\ntime define LLVM_ENABLE_THREADS.  This function always returns\nLLVMIsMultithreaded()."]
    pub unsafe fn LLVMStartMultithreaded(&self) -> LLVMBool {
        (self
            .LLVMStartMultithreaded
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Deprecated: Multi-threading can only be enabled/disabled with the compile\ntime define LLVM_ENABLE_THREADS."]
    pub unsafe fn LLVMStopMultithreaded(&self) {
        (self
            .LLVMStopMultithreaded
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Check whether LLVM is executing in thread-safe mode or not.\n@see llvm::llvm_is_multithreaded"]
    pub unsafe fn LLVMIsMultithreaded(&self) -> LLVMBool {
        (self
            .LLVMIsMultithreaded
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " The current debug metadata version number."]
    pub unsafe fn LLVMDebugMetadataVersion(&self) -> ::std::os::raw::c_uint {
        (self
            .LLVMDebugMetadataVersion
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " The version of debug metadata that's present in the provided \\c Module."]
    pub unsafe fn LLVMGetModuleDebugMetadataVersion(
        &self,
        Module: LLVMModuleRef,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMGetModuleDebugMetadataVersion
            .as_ref()
            .expect("Expected function, got error."))(Module)
    }
    #[doc = " Strip debug info in the module if it exists.\n To do this, we remove all calls to the debugger intrinsics and any named\n metadata for debugging. We also remove debug locations for instructions.\n Return true if module is modified."]
    pub unsafe fn LLVMStripModuleDebugInfo(&self, Module: LLVMModuleRef) -> LLVMBool {
        (self
            .LLVMStripModuleDebugInfo
            .as_ref()
            .expect("Expected function, got error."))(Module)
    }
    #[doc = " Construct a builder for a module, and do not allow for unresolved nodes\n attached to the module."]
    pub unsafe fn LLVMCreateDIBuilderDisallowUnresolved(
        &self,
        M: LLVMModuleRef,
    ) -> LLVMDIBuilderRef {
        (self
            .LLVMCreateDIBuilderDisallowUnresolved
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Construct a builder for a module and collect unresolved nodes attached\n to the module in order to resolve cycles during a call to\n \\c LLVMDIBuilderFinalize."]
    pub unsafe fn LLVMCreateDIBuilder(&self, M: LLVMModuleRef) -> LLVMDIBuilderRef {
        (self
            .LLVMCreateDIBuilder
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Deallocates the \\c DIBuilder and everything it owns.\n @note You must call \\c LLVMDIBuilderFinalize before this"]
    pub unsafe fn LLVMDisposeDIBuilder(&self, Builder: LLVMDIBuilderRef) {
        (self
            .LLVMDisposeDIBuilder
            .as_ref()
            .expect("Expected function, got error."))(Builder)
    }
    #[doc = " Construct any deferred debug info descriptors."]
    pub unsafe fn LLVMDIBuilderFinalize(&self, Builder: LLVMDIBuilderRef) {
        (self
            .LLVMDIBuilderFinalize
            .as_ref()
            .expect("Expected function, got error."))(Builder)
    }
    #[doc = " Finalize a specific subprogram.\n No new variables may be added to this subprogram afterwards."]
    pub unsafe fn LLVMDIBuilderFinalizeSubprogram(
        &self,
        Builder: LLVMDIBuilderRef,
        Subprogram: LLVMMetadataRef,
    ) {
        (self
            .LLVMDIBuilderFinalizeSubprogram
            .as_ref()
            .expect("Expected function, got error."))(Builder, Subprogram)
    }
    #[doc = " A CompileUnit provides an anchor for all debugging\n information generated during this instance of compilation.\n \\param Lang          Source programming language, eg.\n                      \\c LLVMDWARFSourceLanguageC99\n \\param FileRef       File info.\n \\param Producer      Identify the producer of debugging information\n                      and code.  Usually this is a compiler\n                      version string.\n \\param ProducerLen   The length of the C string passed to \\c Producer.\n \\param isOptimized   A boolean flag which indicates whether optimization\n                      is enabled or not.\n \\param Flags         This string lists command line options. This\n                      string is directly embedded in debug info\n                      output which may be used by a tool\n                      analyzing generated debugging information.\n \\param FlagsLen      The length of the C string passed to \\c Flags.\n \\param RuntimeVer    This indicates runtime version for languages like\n                      Objective-C.\n \\param SplitName     The name of the file that we'll split debug info\n                      out into.\n \\param SplitNameLen  The length of the C string passed to \\c SplitName.\n \\param Kind          The kind of debug information to generate.\n \\param DWOId         The DWOId if this is a split skeleton compile unit.\n \\param SplitDebugInlining    Whether to emit inline debug info.\n \\param DebugInfoForProfiling Whether to emit extra debug info for\n                              profile collection.\n \\param SysRoot         The Clang system root (value of -isysroot).\n \\param SysRootLen      The length of the C string passed to \\c SysRoot.\n \\param SDK           The SDK. On Darwin, the last component of the sysroot.\n \\param SDKLen        The length of the C string passed to \\c SDK."]
    pub unsafe fn LLVMDIBuilderCreateCompileUnit(
        &self,
        Builder: LLVMDIBuilderRef,
        Lang: LLVMDWARFSourceLanguage,
        FileRef: LLVMMetadataRef,
        Producer: *const ::std::os::raw::c_char,
        ProducerLen: usize,
        isOptimized: LLVMBool,
        Flags: *const ::std::os::raw::c_char,
        FlagsLen: usize,
        RuntimeVer: ::std::os::raw::c_uint,
        SplitName: *const ::std::os::raw::c_char,
        SplitNameLen: usize,
        Kind: LLVMDWARFEmissionKind,
        DWOId: ::std::os::raw::c_uint,
        SplitDebugInlining: LLVMBool,
        DebugInfoForProfiling: LLVMBool,
        SysRoot: *const ::std::os::raw::c_char,
        SysRootLen: usize,
        SDK: *const ::std::os::raw::c_char,
        SDKLen: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateCompileUnit
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Lang,
            FileRef,
            Producer,
            ProducerLen,
            isOptimized,
            Flags,
            FlagsLen,
            RuntimeVer,
            SplitName,
            SplitNameLen,
            Kind,
            DWOId,
            SplitDebugInlining,
            DebugInfoForProfiling,
            SysRoot,
            SysRootLen,
            SDK,
            SDKLen,
        )
    }
    #[doc = " Create a file descriptor to hold debugging information for a file.\n \\param Builder      The \\c DIBuilder.\n \\param Filename     File name.\n \\param FilenameLen  The length of the C string passed to \\c Filename.\n \\param Directory    Directory.\n \\param DirectoryLen The length of the C string passed to \\c Directory."]
    pub unsafe fn LLVMDIBuilderCreateFile(
        &self,
        Builder: LLVMDIBuilderRef,
        Filename: *const ::std::os::raw::c_char,
        FilenameLen: usize,
        Directory: *const ::std::os::raw::c_char,
        DirectoryLen: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateFile
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Filename,
            FilenameLen,
            Directory,
            DirectoryLen,
        )
    }
    #[doc = " Creates a new descriptor for a module with the specified parent scope.\n \\param Builder         The \\c DIBuilder.\n \\param ParentScope     The parent scope containing this module declaration.\n \\param Name            Module name.\n \\param NameLen         The length of the C string passed to \\c Name.\n \\param ConfigMacros    A space-separated shell-quoted list of -D macro\ndefinitions as they would appear on a command line.\n \\param ConfigMacrosLen The length of the C string passed to \\c ConfigMacros.\n \\param IncludePath     The path to the module map file.\n \\param IncludePathLen  The length of the C string passed to \\c IncludePath.\n \\param APINotesFile    The path to an API notes file for the module.\n \\param APINotesFileLen The length of the C string passed to \\c APINotestFile."]
    pub unsafe fn LLVMDIBuilderCreateModule(
        &self,
        Builder: LLVMDIBuilderRef,
        ParentScope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        ConfigMacros: *const ::std::os::raw::c_char,
        ConfigMacrosLen: usize,
        IncludePath: *const ::std::os::raw::c_char,
        IncludePathLen: usize,
        APINotesFile: *const ::std::os::raw::c_char,
        APINotesFileLen: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateModule
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            ParentScope,
            Name,
            NameLen,
            ConfigMacros,
            ConfigMacrosLen,
            IncludePath,
            IncludePathLen,
            APINotesFile,
            APINotesFileLen,
        )
    }
    #[doc = " Creates a new descriptor for a namespace with the specified parent scope.\n \\param Builder          The \\c DIBuilder.\n \\param ParentScope      The parent scope containing this module declaration.\n \\param Name             NameSpace name.\n \\param NameLen          The length of the C string passed to \\c Name.\n \\param ExportSymbols    Whether or not the namespace exports symbols, e.g.\n                         this is true of C++ inline namespaces."]
    pub unsafe fn LLVMDIBuilderCreateNameSpace(
        &self,
        Builder: LLVMDIBuilderRef,
        ParentScope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        ExportSymbols: LLVMBool,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateNameSpace
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            ParentScope,
            Name,
            NameLen,
            ExportSymbols,
        )
    }
    #[doc = " Create a new descriptor for the specified subprogram.\n \\param Builder         The \\c DIBuilder.\n \\param Scope           Function scope.\n \\param Name            Function name.\n \\param NameLen         Length of enumeration name.\n \\param LinkageName     Mangled function name.\n \\param LinkageNameLen  Length of linkage name.\n \\param File            File where this variable is defined.\n \\param LineNo          Line number.\n \\param Ty              Function type.\n \\param IsLocalToUnit   True if this function is not externally visible.\n \\param IsDefinition    True if this is a function definition.\n \\param ScopeLine       Set to the beginning of the scope this starts\n \\param Flags           E.g.: \\c LLVMDIFlagLValueReference. These flags are\n                        used to emit dwarf attributes.\n \\param IsOptimized     True if optimization is ON."]
    pub unsafe fn LLVMDIBuilderCreateFunction(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        LinkageName: *const ::std::os::raw::c_char,
        LinkageNameLen: usize,
        File: LLVMMetadataRef,
        LineNo: ::std::os::raw::c_uint,
        Ty: LLVMMetadataRef,
        IsLocalToUnit: LLVMBool,
        IsDefinition: LLVMBool,
        ScopeLine: ::std::os::raw::c_uint,
        Flags: LLVMDIFlags,
        IsOptimized: LLVMBool,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateFunction
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            Name,
            NameLen,
            LinkageName,
            LinkageNameLen,
            File,
            LineNo,
            Ty,
            IsLocalToUnit,
            IsDefinition,
            ScopeLine,
            Flags,
            IsOptimized,
        )
    }
    #[doc = " Create a descriptor for a lexical block with the specified parent context.\n \\param Builder      The \\c DIBuilder.\n \\param Scope        Parent lexical block.\n \\param File         Source file.\n \\param Line         The line in the source file.\n \\param Column       The column in the source file."]
    pub unsafe fn LLVMDIBuilderCreateLexicalBlock(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        File: LLVMMetadataRef,
        Line: ::std::os::raw::c_uint,
        Column: ::std::os::raw::c_uint,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateLexicalBlock
            .as_ref()
            .expect("Expected function, got error."))(Builder, Scope, File, Line, Column)
    }
    #[doc = " Create a descriptor for a lexical block with a new file attached.\n \\param Builder        The \\c DIBuilder.\n \\param Scope          Lexical block.\n \\param File           Source file.\n \\param Discriminator  DWARF path discriminator value."]
    pub unsafe fn LLVMDIBuilderCreateLexicalBlockFile(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        File: LLVMMetadataRef,
        Discriminator: ::std::os::raw::c_uint,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateLexicalBlockFile
            .as_ref()
            .expect("Expected function, got error."))(Builder, Scope, File, Discriminator)
    }
    #[doc = " Create a descriptor for an imported namespace. Suitable for e.g. C++\n using declarations.\n \\param Builder    The \\c DIBuilder.\n \\param Scope      The scope this module is imported into\n \\param File       File where the declaration is located.\n \\param Line       Line number of the declaration."]
    pub unsafe fn LLVMDIBuilderCreateImportedModuleFromNamespace(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        NS: LLVMMetadataRef,
        File: LLVMMetadataRef,
        Line: ::std::os::raw::c_uint,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateImportedModuleFromNamespace
            .as_ref()
            .expect("Expected function, got error."))(Builder, Scope, NS, File, Line)
    }
    #[doc = " Create a descriptor for an imported module that aliases another\n imported entity descriptor.\n \\param Builder        The \\c DIBuilder.\n \\param Scope          The scope this module is imported into\n \\param ImportedEntity Previous imported entity to alias.\n \\param File           File where the declaration is located.\n \\param Line           Line number of the declaration.\n \\param Elements       Renamed elements.\n \\param NumElements    Number of renamed elements."]
    pub unsafe fn LLVMDIBuilderCreateImportedModuleFromAlias(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        ImportedEntity: LLVMMetadataRef,
        File: LLVMMetadataRef,
        Line: ::std::os::raw::c_uint,
        Elements: *mut LLVMMetadataRef,
        NumElements: ::std::os::raw::c_uint,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateImportedModuleFromAlias
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            ImportedEntity,
            File,
            Line,
            Elements,
            NumElements,
        )
    }
    #[doc = " Create a descriptor for an imported module.\n \\param Builder        The \\c DIBuilder.\n \\param Scope          The scope this module is imported into\n \\param M              The module being imported here\n \\param File           File where the declaration is located.\n \\param Line           Line number of the declaration.\n \\param Elements       Renamed elements.\n \\param NumElements    Number of renamed elements."]
    pub unsafe fn LLVMDIBuilderCreateImportedModuleFromModule(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        M: LLVMMetadataRef,
        File: LLVMMetadataRef,
        Line: ::std::os::raw::c_uint,
        Elements: *mut LLVMMetadataRef,
        NumElements: ::std::os::raw::c_uint,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateImportedModuleFromModule
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            M,
            File,
            Line,
            Elements,
            NumElements,
        )
    }
    #[doc = " Create a descriptor for an imported function, type, or variable.  Suitable\n for e.g. FORTRAN-style USE declarations.\n \\param Builder        The DIBuilder.\n \\param Scope          The scope this module is imported into.\n \\param Decl           The declaration (or definition) of a function, type,\nor variable.\n \\param File           File where the declaration is located.\n \\param Line           Line number of the declaration.\n \\param Name           A name that uniquely identifies this imported\ndeclaration.\n \\param NameLen        The length of the C string passed to \\c Name.\n \\param Elements       Renamed elements.\n \\param NumElements    Number of renamed elements."]
    pub unsafe fn LLVMDIBuilderCreateImportedDeclaration(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        Decl: LLVMMetadataRef,
        File: LLVMMetadataRef,
        Line: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        Elements: *mut LLVMMetadataRef,
        NumElements: ::std::os::raw::c_uint,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateImportedDeclaration
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            Decl,
            File,
            Line,
            Name,
            NameLen,
            Elements,
            NumElements,
        )
    }
    #[doc = " Creates a new DebugLocation that describes a source location.\n \\param Line The line in the source file.\n \\param Column The column in the source file.\n \\param Scope The scope in which the location resides.\n \\param InlinedAt The scope where this location was inlined, if at all.\n                  (optional).\n \\note If the item to which this location is attached cannot be\n       attributed to a source line, pass 0 for the line and column."]
    pub unsafe fn LLVMDIBuilderCreateDebugLocation(
        &self,
        Ctx: LLVMContextRef,
        Line: ::std::os::raw::c_uint,
        Column: ::std::os::raw::c_uint,
        Scope: LLVMMetadataRef,
        InlinedAt: LLVMMetadataRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateDebugLocation
            .as_ref()
            .expect("Expected function, got error."))(Ctx, Line, Column, Scope, InlinedAt)
    }
    #[doc = " Get the line number of this debug location.\n \\param Location     The debug location.\n\n @see DILocation::getLine()"]
    pub unsafe fn LLVMDILocationGetLine(
        &self,
        Location: LLVMMetadataRef,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMDILocationGetLine
            .as_ref()
            .expect("Expected function, got error."))(Location)
    }
    #[doc = " Get the column number of this debug location.\n \\param Location     The debug location.\n\n @see DILocation::getColumn()"]
    pub unsafe fn LLVMDILocationGetColumn(
        &self,
        Location: LLVMMetadataRef,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMDILocationGetColumn
            .as_ref()
            .expect("Expected function, got error."))(Location)
    }
    #[doc = " Get the local scope associated with this debug location.\n \\param Location     The debug location.\n\n @see DILocation::getScope()"]
    pub unsafe fn LLVMDILocationGetScope(&self, Location: LLVMMetadataRef) -> LLVMMetadataRef {
        (self
            .LLVMDILocationGetScope
            .as_ref()
            .expect("Expected function, got error."))(Location)
    }
    #[doc = " Get the \"inline at\" location associated with this debug location.\n \\param Location     The debug location.\n\n @see DILocation::getInlinedAt()"]
    pub unsafe fn LLVMDILocationGetInlinedAt(&self, Location: LLVMMetadataRef) -> LLVMMetadataRef {
        (self
            .LLVMDILocationGetInlinedAt
            .as_ref()
            .expect("Expected function, got error."))(Location)
    }
    #[doc = " Get the metadata of the file associated with a given scope.\n \\param Scope     The scope object.\n\n @see DIScope::getFile()"]
    pub unsafe fn LLVMDIScopeGetFile(&self, Scope: LLVMMetadataRef) -> LLVMMetadataRef {
        (self
            .LLVMDIScopeGetFile
            .as_ref()
            .expect("Expected function, got error."))(Scope)
    }
    #[doc = " Get the directory of a given file.\n \\param File     The file object.\n \\param Len      The length of the returned string.\n\n @see DIFile::getDirectory()"]
    pub unsafe fn LLVMDIFileGetDirectory(
        &self,
        File: LLVMMetadataRef,
        Len: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMDIFileGetDirectory
            .as_ref()
            .expect("Expected function, got error."))(File, Len)
    }
    #[doc = " Get the name of a given file.\n \\param File     The file object.\n \\param Len      The length of the returned string.\n\n @see DIFile::getFilename()"]
    pub unsafe fn LLVMDIFileGetFilename(
        &self,
        File: LLVMMetadataRef,
        Len: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMDIFileGetFilename
            .as_ref()
            .expect("Expected function, got error."))(File, Len)
    }
    #[doc = " Get the source of a given file.\n \\param File     The file object.\n \\param Len      The length of the returned string.\n\n @see DIFile::getSource()"]
    pub unsafe fn LLVMDIFileGetSource(
        &self,
        File: LLVMMetadataRef,
        Len: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMDIFileGetSource
            .as_ref()
            .expect("Expected function, got error."))(File, Len)
    }
    #[doc = " Create a type array.\n \\param Builder        The DIBuilder.\n \\param Data           The type elements.\n \\param NumElements    Number of type elements."]
    pub unsafe fn LLVMDIBuilderGetOrCreateTypeArray(
        &self,
        Builder: LLVMDIBuilderRef,
        Data: *mut LLVMMetadataRef,
        NumElements: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderGetOrCreateTypeArray
            .as_ref()
            .expect("Expected function, got error."))(Builder, Data, NumElements)
    }
    #[doc = " Create subroutine type.\n \\param Builder        The DIBuilder.\n \\param File            The file in which the subroutine resides.\n \\param ParameterTypes  An array of subroutine parameter types. This\n                        includes return type at 0th index.\n \\param NumParameterTypes The number of parameter types in \\c ParameterTypes\n \\param Flags           E.g.: \\c LLVMDIFlagLValueReference.\n                        These flags are used to emit dwarf attributes."]
    pub unsafe fn LLVMDIBuilderCreateSubroutineType(
        &self,
        Builder: LLVMDIBuilderRef,
        File: LLVMMetadataRef,
        ParameterTypes: *mut LLVMMetadataRef,
        NumParameterTypes: ::std::os::raw::c_uint,
        Flags: LLVMDIFlags,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateSubroutineType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            File,
            ParameterTypes,
            NumParameterTypes,
            Flags,
        )
    }
    #[doc = " Create debugging information entry for a macro.\n @param Builder         The DIBuilder.\n @param ParentMacroFile Macro parent (could be NULL).\n @param Line            Source line number where the macro is defined.\n @param RecordType      DW_MACINFO_define or DW_MACINFO_undef.\n @param Name            Macro name.\n @param NameLen         Macro name length.\n @param Value           Macro value.\n @param ValueLen        Macro value length."]
    pub unsafe fn LLVMDIBuilderCreateMacro(
        &self,
        Builder: LLVMDIBuilderRef,
        ParentMacroFile: LLVMMetadataRef,
        Line: ::std::os::raw::c_uint,
        RecordType: LLVMDWARFMacinfoRecordType,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        Value: *const ::std::os::raw::c_char,
        ValueLen: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateMacro
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            ParentMacroFile,
            Line,
            RecordType,
            Name,
            NameLen,
            Value,
            ValueLen,
        )
    }
    #[doc = " Create debugging information temporary entry for a macro file.\n List of macro node direct children will be calculated by DIBuilder,\n using the \\p ParentMacroFile relationship.\n @param Builder         The DIBuilder.\n @param ParentMacroFile Macro parent (could be NULL).\n @param Line            Source line number where the macro file is included.\n @param File            File descriptor containing the name of the macro file."]
    pub unsafe fn LLVMDIBuilderCreateTempMacroFile(
        &self,
        Builder: LLVMDIBuilderRef,
        ParentMacroFile: LLVMMetadataRef,
        Line: ::std::os::raw::c_uint,
        File: LLVMMetadataRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateTempMacroFile
            .as_ref()
            .expect("Expected function, got error."))(Builder, ParentMacroFile, Line, File)
    }
    #[doc = " Create debugging information entry for an enumerator.\n @param Builder        The DIBuilder.\n @param Name           Enumerator name.\n @param NameLen        Length of enumerator name.\n @param Value          Enumerator value.\n @param IsUnsigned     True if the value is unsigned."]
    pub unsafe fn LLVMDIBuilderCreateEnumerator(
        &self,
        Builder: LLVMDIBuilderRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        Value: i64,
        IsUnsigned: LLVMBool,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateEnumerator
            .as_ref()
            .expect("Expected function, got error."))(
            Builder, Name, NameLen, Value, IsUnsigned
        )
    }
    #[doc = " Create debugging information entry for an enumeration.\n \\param Builder        The DIBuilder.\n \\param Scope          Scope in which this enumeration is defined.\n \\param Name           Enumeration name.\n \\param NameLen        Length of enumeration name.\n \\param File           File where this member is defined.\n \\param LineNumber     Line number.\n \\param SizeInBits     Member size.\n \\param AlignInBits    Member alignment.\n \\param Elements       Enumeration elements.\n \\param NumElements    Number of enumeration elements.\n \\param ClassTy        Underlying type of a C++11/ObjC fixed enum."]
    pub unsafe fn LLVMDIBuilderCreateEnumerationType(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        File: LLVMMetadataRef,
        LineNumber: ::std::os::raw::c_uint,
        SizeInBits: u64,
        AlignInBits: u32,
        Elements: *mut LLVMMetadataRef,
        NumElements: ::std::os::raw::c_uint,
        ClassTy: LLVMMetadataRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateEnumerationType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            Name,
            NameLen,
            File,
            LineNumber,
            SizeInBits,
            AlignInBits,
            Elements,
            NumElements,
            ClassTy,
        )
    }
    #[doc = " Create debugging information entry for a union.\n \\param Builder      The DIBuilder.\n \\param Scope        Scope in which this union is defined.\n \\param Name         Union name.\n \\param NameLen      Length of union name.\n \\param File         File where this member is defined.\n \\param LineNumber   Line number.\n \\param SizeInBits   Member size.\n \\param AlignInBits  Member alignment.\n \\param Flags        Flags to encode member attribute, e.g. private\n \\param Elements     Union elements.\n \\param NumElements  Number of union elements.\n \\param RunTimeLang  Optional parameter, Objective-C runtime version.\n \\param UniqueId     A unique identifier for the union.\n \\param UniqueIdLen  Length of unique identifier."]
    pub unsafe fn LLVMDIBuilderCreateUnionType(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        File: LLVMMetadataRef,
        LineNumber: ::std::os::raw::c_uint,
        SizeInBits: u64,
        AlignInBits: u32,
        Flags: LLVMDIFlags,
        Elements: *mut LLVMMetadataRef,
        NumElements: ::std::os::raw::c_uint,
        RunTimeLang: ::std::os::raw::c_uint,
        UniqueId: *const ::std::os::raw::c_char,
        UniqueIdLen: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateUnionType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            Name,
            NameLen,
            File,
            LineNumber,
            SizeInBits,
            AlignInBits,
            Flags,
            Elements,
            NumElements,
            RunTimeLang,
            UniqueId,
            UniqueIdLen,
        )
    }
    #[doc = " Create debugging information entry for an array.\n \\param Builder      The DIBuilder.\n \\param Size         Array size.\n \\param AlignInBits  Alignment.\n \\param Ty           Element type.\n \\param Subscripts   Subscripts.\n \\param NumSubscripts Number of subscripts."]
    pub unsafe fn LLVMDIBuilderCreateArrayType(
        &self,
        Builder: LLVMDIBuilderRef,
        Size: u64,
        AlignInBits: u32,
        Ty: LLVMMetadataRef,
        Subscripts: *mut LLVMMetadataRef,
        NumSubscripts: ::std::os::raw::c_uint,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateArrayType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Size,
            AlignInBits,
            Ty,
            Subscripts,
            NumSubscripts,
        )
    }
    #[doc = " Create debugging information entry for a vector type.\n \\param Builder      The DIBuilder.\n \\param Size         Vector size.\n \\param AlignInBits  Alignment.\n \\param Ty           Element type.\n \\param Subscripts   Subscripts.\n \\param NumSubscripts Number of subscripts."]
    pub unsafe fn LLVMDIBuilderCreateVectorType(
        &self,
        Builder: LLVMDIBuilderRef,
        Size: u64,
        AlignInBits: u32,
        Ty: LLVMMetadataRef,
        Subscripts: *mut LLVMMetadataRef,
        NumSubscripts: ::std::os::raw::c_uint,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateVectorType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Size,
            AlignInBits,
            Ty,
            Subscripts,
            NumSubscripts,
        )
    }
    #[doc = " Create a DWARF unspecified type.\n \\param Builder   The DIBuilder.\n \\param Name      The unspecified type's name.\n \\param NameLen   Length of type name."]
    pub unsafe fn LLVMDIBuilderCreateUnspecifiedType(
        &self,
        Builder: LLVMDIBuilderRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateUnspecifiedType
            .as_ref()
            .expect("Expected function, got error."))(Builder, Name, NameLen)
    }
    #[doc = " Create debugging information entry for a basic\n type.\n \\param Builder     The DIBuilder.\n \\param Name        Type name.\n \\param NameLen     Length of type name.\n \\param SizeInBits  Size of the type.\n \\param Encoding    DWARF encoding code, e.g. \\c LLVMDWARFTypeEncoding_float.\n \\param Flags       Flags to encode optional attribute like endianity"]
    pub unsafe fn LLVMDIBuilderCreateBasicType(
        &self,
        Builder: LLVMDIBuilderRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        SizeInBits: u64,
        Encoding: LLVMDWARFTypeEncoding,
        Flags: LLVMDIFlags,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateBasicType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder, Name, NameLen, SizeInBits, Encoding, Flags,
        )
    }
    #[doc = " Create debugging information entry for a pointer.\n \\param Builder     The DIBuilder.\n \\param PointeeTy         Type pointed by this pointer.\n \\param SizeInBits        Size.\n \\param AlignInBits       Alignment. (optional, pass 0 to ignore)\n \\param AddressSpace      DWARF address space. (optional, pass 0 to ignore)\n \\param Name              Pointer type name. (optional)\n \\param NameLen           Length of pointer type name. (optional)"]
    pub unsafe fn LLVMDIBuilderCreatePointerType(
        &self,
        Builder: LLVMDIBuilderRef,
        PointeeTy: LLVMMetadataRef,
        SizeInBits: u64,
        AlignInBits: u32,
        AddressSpace: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreatePointerType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            PointeeTy,
            SizeInBits,
            AlignInBits,
            AddressSpace,
            Name,
            NameLen,
        )
    }
    #[doc = " Create debugging information entry for a struct.\n \\param Builder     The DIBuilder.\n \\param Scope        Scope in which this struct is defined.\n \\param Name         Struct name.\n \\param NameLen      Struct name length.\n \\param File         File where this member is defined.\n \\param LineNumber   Line number.\n \\param SizeInBits   Member size.\n \\param AlignInBits  Member alignment.\n \\param Flags        Flags to encode member attribute, e.g. private\n \\param Elements     Struct elements.\n \\param NumElements  Number of struct elements.\n \\param RunTimeLang  Optional parameter, Objective-C runtime version.\n \\param VTableHolder The object containing the vtable for the struct.\n \\param UniqueId     A unique identifier for the struct.\n \\param UniqueIdLen  Length of the unique identifier for the struct."]
    pub unsafe fn LLVMDIBuilderCreateStructType(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        File: LLVMMetadataRef,
        LineNumber: ::std::os::raw::c_uint,
        SizeInBits: u64,
        AlignInBits: u32,
        Flags: LLVMDIFlags,
        DerivedFrom: LLVMMetadataRef,
        Elements: *mut LLVMMetadataRef,
        NumElements: ::std::os::raw::c_uint,
        RunTimeLang: ::std::os::raw::c_uint,
        VTableHolder: LLVMMetadataRef,
        UniqueId: *const ::std::os::raw::c_char,
        UniqueIdLen: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateStructType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            Name,
            NameLen,
            File,
            LineNumber,
            SizeInBits,
            AlignInBits,
            Flags,
            DerivedFrom,
            Elements,
            NumElements,
            RunTimeLang,
            VTableHolder,
            UniqueId,
            UniqueIdLen,
        )
    }
    #[doc = " Create debugging information entry for a member.\n \\param Builder      The DIBuilder.\n \\param Scope        Member scope.\n \\param Name         Member name.\n \\param NameLen      Length of member name.\n \\param File         File where this member is defined.\n \\param LineNo       Line number.\n \\param SizeInBits   Member size.\n \\param AlignInBits  Member alignment.\n \\param OffsetInBits Member offset.\n \\param Flags        Flags to encode member attribute, e.g. private\n \\param Ty           Parent type."]
    pub unsafe fn LLVMDIBuilderCreateMemberType(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        File: LLVMMetadataRef,
        LineNo: ::std::os::raw::c_uint,
        SizeInBits: u64,
        AlignInBits: u32,
        OffsetInBits: u64,
        Flags: LLVMDIFlags,
        Ty: LLVMMetadataRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateMemberType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            Name,
            NameLen,
            File,
            LineNo,
            SizeInBits,
            AlignInBits,
            OffsetInBits,
            Flags,
            Ty,
        )
    }
    #[doc = " Create debugging information entry for a\n C++ static data member.\n \\param Builder      The DIBuilder.\n \\param Scope        Member scope.\n \\param Name         Member name.\n \\param NameLen      Length of member name.\n \\param File         File where this member is declared.\n \\param LineNumber   Line number.\n \\param Type         Type of the static member.\n \\param Flags        Flags to encode member attribute, e.g. private.\n \\param ConstantVal  Const initializer of the member.\n \\param AlignInBits  Member alignment."]
    pub unsafe fn LLVMDIBuilderCreateStaticMemberType(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        File: LLVMMetadataRef,
        LineNumber: ::std::os::raw::c_uint,
        Type: LLVMMetadataRef,
        Flags: LLVMDIFlags,
        ConstantVal: LLVMValueRef,
        AlignInBits: u32,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateStaticMemberType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            Name,
            NameLen,
            File,
            LineNumber,
            Type,
            Flags,
            ConstantVal,
            AlignInBits,
        )
    }
    #[doc = " Create debugging information entry for a pointer to member.\n \\param Builder      The DIBuilder.\n \\param PointeeType  Type pointed to by this pointer.\n \\param ClassType    Type for which this pointer points to members of.\n \\param SizeInBits   Size.\n \\param AlignInBits  Alignment.\n \\param Flags        Flags."]
    pub unsafe fn LLVMDIBuilderCreateMemberPointerType(
        &self,
        Builder: LLVMDIBuilderRef,
        PointeeType: LLVMMetadataRef,
        ClassType: LLVMMetadataRef,
        SizeInBits: u64,
        AlignInBits: u32,
        Flags: LLVMDIFlags,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateMemberPointerType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            PointeeType,
            ClassType,
            SizeInBits,
            AlignInBits,
            Flags,
        )
    }
    #[doc = " Create debugging information entry for Objective-C instance variable.\n \\param Builder      The DIBuilder.\n \\param Name         Member name.\n \\param NameLen      The length of the C string passed to \\c Name.\n \\param File         File where this member is defined.\n \\param LineNo       Line number.\n \\param SizeInBits   Member size.\n \\param AlignInBits  Member alignment.\n \\param OffsetInBits Member offset.\n \\param Flags        Flags to encode member attribute, e.g. private\n \\param Ty           Parent type.\n \\param PropertyNode Property associated with this ivar."]
    pub unsafe fn LLVMDIBuilderCreateObjCIVar(
        &self,
        Builder: LLVMDIBuilderRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        File: LLVMMetadataRef,
        LineNo: ::std::os::raw::c_uint,
        SizeInBits: u64,
        AlignInBits: u32,
        OffsetInBits: u64,
        Flags: LLVMDIFlags,
        Ty: LLVMMetadataRef,
        PropertyNode: LLVMMetadataRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateObjCIVar
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Name,
            NameLen,
            File,
            LineNo,
            SizeInBits,
            AlignInBits,
            OffsetInBits,
            Flags,
            Ty,
            PropertyNode,
        )
    }
    #[doc = " Create debugging information entry for Objective-C property.\n \\param Builder            The DIBuilder.\n \\param Name               Property name.\n \\param NameLen            The length of the C string passed to \\c Name.\n \\param File               File where this property is defined.\n \\param LineNo             Line number.\n \\param GetterName         Name of the Objective C property getter selector.\n \\param GetterNameLen      The length of the C string passed to \\c GetterName.\n \\param SetterName         Name of the Objective C property setter selector.\n \\param SetterNameLen      The length of the C string passed to \\c SetterName.\n \\param PropertyAttributes Objective C property attributes.\n \\param Ty                 Type."]
    pub unsafe fn LLVMDIBuilderCreateObjCProperty(
        &self,
        Builder: LLVMDIBuilderRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        File: LLVMMetadataRef,
        LineNo: ::std::os::raw::c_uint,
        GetterName: *const ::std::os::raw::c_char,
        GetterNameLen: usize,
        SetterName: *const ::std::os::raw::c_char,
        SetterNameLen: usize,
        PropertyAttributes: ::std::os::raw::c_uint,
        Ty: LLVMMetadataRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateObjCProperty
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Name,
            NameLen,
            File,
            LineNo,
            GetterName,
            GetterNameLen,
            SetterName,
            SetterNameLen,
            PropertyAttributes,
            Ty,
        )
    }
    #[doc = " Create a uniqued DIType* clone with FlagObjectPointer and FlagArtificial set.\n \\param Builder   The DIBuilder.\n \\param Type      The underlying type to which this pointer points."]
    pub unsafe fn LLVMDIBuilderCreateObjectPointerType(
        &self,
        Builder: LLVMDIBuilderRef,
        Type: LLVMMetadataRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateObjectPointerType
            .as_ref()
            .expect("Expected function, got error."))(Builder, Type)
    }
    #[doc = " Create debugging information entry for a qualified\n type, e.g. 'const int'.\n \\param Builder     The DIBuilder.\n \\param Tag         Tag identifying type,\n                    e.g. LLVMDWARFTypeQualifier_volatile_type\n \\param Type        Base Type."]
    pub unsafe fn LLVMDIBuilderCreateQualifiedType(
        &self,
        Builder: LLVMDIBuilderRef,
        Tag: ::std::os::raw::c_uint,
        Type: LLVMMetadataRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateQualifiedType
            .as_ref()
            .expect("Expected function, got error."))(Builder, Tag, Type)
    }
    #[doc = " Create debugging information entry for a c++\n style reference or rvalue reference type.\n \\param Builder   The DIBuilder.\n \\param Tag       Tag identifying type,\n \\param Type      Base Type."]
    pub unsafe fn LLVMDIBuilderCreateReferenceType(
        &self,
        Builder: LLVMDIBuilderRef,
        Tag: ::std::os::raw::c_uint,
        Type: LLVMMetadataRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateReferenceType
            .as_ref()
            .expect("Expected function, got error."))(Builder, Tag, Type)
    }
    #[doc = " Create C++11 nullptr type.\n \\param Builder   The DIBuilder."]
    pub unsafe fn LLVMDIBuilderCreateNullPtrType(
        &self,
        Builder: LLVMDIBuilderRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateNullPtrType
            .as_ref()
            .expect("Expected function, got error."))(Builder)
    }
    #[doc = " Create debugging information entry for a typedef.\n \\param Builder    The DIBuilder.\n \\param Type       Original type.\n \\param Name       Typedef name.\n \\param File       File where this type is defined.\n \\param LineNo     Line number.\n \\param Scope      The surrounding context for the typedef."]
    pub unsafe fn LLVMDIBuilderCreateTypedef(
        &self,
        Builder: LLVMDIBuilderRef,
        Type: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        File: LLVMMetadataRef,
        LineNo: ::std::os::raw::c_uint,
        Scope: LLVMMetadataRef,
        AlignInBits: u32,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateTypedef
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Type,
            Name,
            NameLen,
            File,
            LineNo,
            Scope,
            AlignInBits,
        )
    }
    #[doc = " Create debugging information entry to establish inheritance relationship\n between two types.\n \\param Builder       The DIBuilder.\n \\param Ty            Original type.\n \\param BaseTy        Base type. Ty is inherits from base.\n \\param BaseOffset    Base offset.\n \\param VBPtrOffset  Virtual base pointer offset.\n \\param Flags         Flags to describe inheritance attribute, e.g. private"]
    pub unsafe fn LLVMDIBuilderCreateInheritance(
        &self,
        Builder: LLVMDIBuilderRef,
        Ty: LLVMMetadataRef,
        BaseTy: LLVMMetadataRef,
        BaseOffset: u64,
        VBPtrOffset: u32,
        Flags: LLVMDIFlags,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateInheritance
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Ty,
            BaseTy,
            BaseOffset,
            VBPtrOffset,
            Flags,
        )
    }
    #[doc = " Create a permanent forward-declared type.\n \\param Builder             The DIBuilder.\n \\param Tag                 A unique tag for this type.\n \\param Name                Type name.\n \\param NameLen             Length of type name.\n \\param Scope               Type scope.\n \\param File                File where this type is defined.\n \\param Line                Line number where this type is defined.\n \\param RuntimeLang         Indicates runtime version for languages like\n                            Objective-C.\n \\param SizeInBits          Member size.\n \\param AlignInBits         Member alignment.\n \\param UniqueIdentifier    A unique identifier for the type.\n \\param UniqueIdentifierLen Length of the unique identifier."]
    pub unsafe fn LLVMDIBuilderCreateForwardDecl(
        &self,
        Builder: LLVMDIBuilderRef,
        Tag: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        Scope: LLVMMetadataRef,
        File: LLVMMetadataRef,
        Line: ::std::os::raw::c_uint,
        RuntimeLang: ::std::os::raw::c_uint,
        SizeInBits: u64,
        AlignInBits: u32,
        UniqueIdentifier: *const ::std::os::raw::c_char,
        UniqueIdentifierLen: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateForwardDecl
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Tag,
            Name,
            NameLen,
            Scope,
            File,
            Line,
            RuntimeLang,
            SizeInBits,
            AlignInBits,
            UniqueIdentifier,
            UniqueIdentifierLen,
        )
    }
    #[doc = " Create a temporary forward-declared type.\n \\param Builder             The DIBuilder.\n \\param Tag                 A unique tag for this type.\n \\param Name                Type name.\n \\param NameLen             Length of type name.\n \\param Scope               Type scope.\n \\param File                File where this type is defined.\n \\param Line                Line number where this type is defined.\n \\param RuntimeLang         Indicates runtime version for languages like\n                            Objective-C.\n \\param SizeInBits          Member size.\n \\param AlignInBits         Member alignment.\n \\param Flags               Flags.\n \\param UniqueIdentifier    A unique identifier for the type.\n \\param UniqueIdentifierLen Length of the unique identifier."]
    pub unsafe fn LLVMDIBuilderCreateReplaceableCompositeType(
        &self,
        Builder: LLVMDIBuilderRef,
        Tag: ::std::os::raw::c_uint,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        Scope: LLVMMetadataRef,
        File: LLVMMetadataRef,
        Line: ::std::os::raw::c_uint,
        RuntimeLang: ::std::os::raw::c_uint,
        SizeInBits: u64,
        AlignInBits: u32,
        Flags: LLVMDIFlags,
        UniqueIdentifier: *const ::std::os::raw::c_char,
        UniqueIdentifierLen: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateReplaceableCompositeType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Tag,
            Name,
            NameLen,
            Scope,
            File,
            Line,
            RuntimeLang,
            SizeInBits,
            AlignInBits,
            Flags,
            UniqueIdentifier,
            UniqueIdentifierLen,
        )
    }
    #[doc = " Create debugging information entry for a bit field member.\n \\param Builder             The DIBuilder.\n \\param Scope               Member scope.\n \\param Name                Member name.\n \\param NameLen             Length of member name.\n \\param File                File where this member is defined.\n \\param LineNumber          Line number.\n \\param SizeInBits          Member size.\n \\param OffsetInBits        Member offset.\n \\param StorageOffsetInBits Member storage offset.\n \\param Flags               Flags to encode member attribute.\n \\param Type                Parent type."]
    pub unsafe fn LLVMDIBuilderCreateBitFieldMemberType(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        File: LLVMMetadataRef,
        LineNumber: ::std::os::raw::c_uint,
        SizeInBits: u64,
        OffsetInBits: u64,
        StorageOffsetInBits: u64,
        Flags: LLVMDIFlags,
        Type: LLVMMetadataRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateBitFieldMemberType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            Name,
            NameLen,
            File,
            LineNumber,
            SizeInBits,
            OffsetInBits,
            StorageOffsetInBits,
            Flags,
            Type,
        )
    }
    #[doc = " Create debugging information entry for a class.\n \\param Scope               Scope in which this class is defined.\n \\param Name                Class name.\n \\param NameLen             The length of the C string passed to \\c Name.\n \\param File                File where this member is defined.\n \\param LineNumber          Line number.\n \\param SizeInBits          Member size.\n \\param AlignInBits         Member alignment.\n \\param OffsetInBits        Member offset.\n \\param Flags               Flags to encode member attribute, e.g. private.\n \\param DerivedFrom         Debug info of the base class of this type.\n \\param Elements            Class members.\n \\param NumElements         Number of class elements.\n \\param VTableHolder        Debug info of the base class that contains vtable\n                            for this type. This is used in\n                            DW_AT_containing_type. See DWARF documentation\n                            for more info.\n \\param TemplateParamsNode  Template type parameters.\n \\param UniqueIdentifier    A unique identifier for the type.\n \\param UniqueIdentifierLen Length of the unique identifier."]
    pub unsafe fn LLVMDIBuilderCreateClassType(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        File: LLVMMetadataRef,
        LineNumber: ::std::os::raw::c_uint,
        SizeInBits: u64,
        AlignInBits: u32,
        OffsetInBits: u64,
        Flags: LLVMDIFlags,
        DerivedFrom: LLVMMetadataRef,
        Elements: *mut LLVMMetadataRef,
        NumElements: ::std::os::raw::c_uint,
        VTableHolder: LLVMMetadataRef,
        TemplateParamsNode: LLVMMetadataRef,
        UniqueIdentifier: *const ::std::os::raw::c_char,
        UniqueIdentifierLen: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateClassType
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            Name,
            NameLen,
            File,
            LineNumber,
            SizeInBits,
            AlignInBits,
            OffsetInBits,
            Flags,
            DerivedFrom,
            Elements,
            NumElements,
            VTableHolder,
            TemplateParamsNode,
            UniqueIdentifier,
            UniqueIdentifierLen,
        )
    }
    #[doc = " Create a uniqued DIType* clone with FlagArtificial set.\n \\param Builder     The DIBuilder.\n \\param Type        The underlying type."]
    pub unsafe fn LLVMDIBuilderCreateArtificialType(
        &self,
        Builder: LLVMDIBuilderRef,
        Type: LLVMMetadataRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateArtificialType
            .as_ref()
            .expect("Expected function, got error."))(Builder, Type)
    }
    #[doc = " Get the name of this DIType.\n \\param DType     The DIType.\n \\param Length    The length of the returned string.\n\n @see DIType::getName()"]
    pub unsafe fn LLVMDITypeGetName(
        &self,
        DType: LLVMMetadataRef,
        Length: *mut usize,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMDITypeGetName
            .as_ref()
            .expect("Expected function, got error."))(DType, Length)
    }
    #[doc = " Get the size of this DIType in bits.\n \\param DType     The DIType.\n\n @see DIType::getSizeInBits()"]
    pub unsafe fn LLVMDITypeGetSizeInBits(&self, DType: LLVMMetadataRef) -> u64 {
        (self
            .LLVMDITypeGetSizeInBits
            .as_ref()
            .expect("Expected function, got error."))(DType)
    }
    #[doc = " Get the offset of this DIType in bits.\n \\param DType     The DIType.\n\n @see DIType::getOffsetInBits()"]
    pub unsafe fn LLVMDITypeGetOffsetInBits(&self, DType: LLVMMetadataRef) -> u64 {
        (self
            .LLVMDITypeGetOffsetInBits
            .as_ref()
            .expect("Expected function, got error."))(DType)
    }
    #[doc = " Get the alignment of this DIType in bits.\n \\param DType     The DIType.\n\n @see DIType::getAlignInBits()"]
    pub unsafe fn LLVMDITypeGetAlignInBits(&self, DType: LLVMMetadataRef) -> u32 {
        (self
            .LLVMDITypeGetAlignInBits
            .as_ref()
            .expect("Expected function, got error."))(DType)
    }
    #[doc = " Get the source line where this DIType is declared.\n \\param DType     The DIType.\n\n @see DIType::getLine()"]
    pub unsafe fn LLVMDITypeGetLine(&self, DType: LLVMMetadataRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMDITypeGetLine
            .as_ref()
            .expect("Expected function, got error."))(DType)
    }
    #[doc = " Get the flags associated with this DIType.\n \\param DType     The DIType.\n\n @see DIType::getFlags()"]
    pub unsafe fn LLVMDITypeGetFlags(&self, DType: LLVMMetadataRef) -> LLVMDIFlags {
        (self
            .LLVMDITypeGetFlags
            .as_ref()
            .expect("Expected function, got error."))(DType)
    }
    #[doc = " Create a descriptor for a value range.\n \\param Builder    The DIBuilder.\n \\param LowerBound Lower bound of the subrange, e.g. 0 for C, 1 for Fortran.\n \\param Count      Count of elements in the subrange."]
    pub unsafe fn LLVMDIBuilderGetOrCreateSubrange(
        &self,
        Builder: LLVMDIBuilderRef,
        LowerBound: i64,
        Count: i64,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderGetOrCreateSubrange
            .as_ref()
            .expect("Expected function, got error."))(Builder, LowerBound, Count)
    }
    #[doc = " Create an array of DI Nodes.\n \\param Builder        The DIBuilder.\n \\param Data           The DI Node elements.\n \\param NumElements    Number of DI Node elements."]
    pub unsafe fn LLVMDIBuilderGetOrCreateArray(
        &self,
        Builder: LLVMDIBuilderRef,
        Data: *mut LLVMMetadataRef,
        NumElements: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderGetOrCreateArray
            .as_ref()
            .expect("Expected function, got error."))(Builder, Data, NumElements)
    }
    #[doc = " Create a new descriptor for the specified variable which has a complex\n address expression for its address.\n \\param Builder     The DIBuilder.\n \\param Addr        An array of complex address operations.\n \\param Length      Length of the address operation array."]
    pub unsafe fn LLVMDIBuilderCreateExpression(
        &self,
        Builder: LLVMDIBuilderRef,
        Addr: *mut u64,
        Length: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateExpression
            .as_ref()
            .expect("Expected function, got error."))(Builder, Addr, Length)
    }
    #[doc = " Create a new descriptor for the specified variable that does not have an\n address, but does have a constant value.\n \\param Builder     The DIBuilder.\n \\param Value       The constant value."]
    pub unsafe fn LLVMDIBuilderCreateConstantValueExpression(
        &self,
        Builder: LLVMDIBuilderRef,
        Value: u64,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateConstantValueExpression
            .as_ref()
            .expect("Expected function, got error."))(Builder, Value)
    }
    #[doc = " Create a new descriptor for the specified variable.\n \\param Scope       Variable scope.\n \\param Name        Name of the variable.\n \\param NameLen     The length of the C string passed to \\c Name.\n \\param Linkage     Mangled  name of the variable.\n \\param LinkLen     The length of the C string passed to \\c Linkage.\n \\param File        File where this variable is defined.\n \\param LineNo      Line number.\n \\param Ty          Variable Type.\n \\param LocalToUnit Boolean flag indicate whether this variable is\n                    externally visible or not.\n \\param Expr        The location of the global relative to the attached\n                    GlobalVariable.\n \\param Decl        Reference to the corresponding declaration.\n                    variables.\n \\param AlignInBits Variable alignment(or 0 if no alignment attr was\n                    specified)"]
    pub unsafe fn LLVMDIBuilderCreateGlobalVariableExpression(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        Linkage: *const ::std::os::raw::c_char,
        LinkLen: usize,
        File: LLVMMetadataRef,
        LineNo: ::std::os::raw::c_uint,
        Ty: LLVMMetadataRef,
        LocalToUnit: LLVMBool,
        Expr: LLVMMetadataRef,
        Decl: LLVMMetadataRef,
        AlignInBits: u32,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateGlobalVariableExpression
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            Name,
            NameLen,
            Linkage,
            LinkLen,
            File,
            LineNo,
            Ty,
            LocalToUnit,
            Expr,
            Decl,
            AlignInBits,
        )
    }
    #[doc = " Get the dwarf::Tag of a DINode"]
    pub unsafe fn LLVMGetDINodeTag(&self, MD: LLVMMetadataRef) -> u16 {
        (self
            .LLVMGetDINodeTag
            .as_ref()
            .expect("Expected function, got error."))(MD)
    }
    #[doc = " Retrieves the \\c DIVariable associated with this global variable expression.\n \\param GVE    The global variable expression.\n\n @see llvm::DIGlobalVariableExpression::getVariable()"]
    pub unsafe fn LLVMDIGlobalVariableExpressionGetVariable(
        &self,
        GVE: LLVMMetadataRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIGlobalVariableExpressionGetVariable
            .as_ref()
            .expect("Expected function, got error."))(GVE)
    }
    #[doc = " Retrieves the \\c DIExpression associated with this global variable expression.\n \\param GVE    The global variable expression.\n\n @see llvm::DIGlobalVariableExpression::getExpression()"]
    pub unsafe fn LLVMDIGlobalVariableExpressionGetExpression(
        &self,
        GVE: LLVMMetadataRef,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIGlobalVariableExpressionGetExpression
            .as_ref()
            .expect("Expected function, got error."))(GVE)
    }
    #[doc = " Get the metadata of the file associated with a given variable.\n \\param Var     The variable object.\n\n @see DIVariable::getFile()"]
    pub unsafe fn LLVMDIVariableGetFile(&self, Var: LLVMMetadataRef) -> LLVMMetadataRef {
        (self
            .LLVMDIVariableGetFile
            .as_ref()
            .expect("Expected function, got error."))(Var)
    }
    #[doc = " Get the metadata of the scope associated with a given variable.\n \\param Var     The variable object.\n\n @see DIVariable::getScope()"]
    pub unsafe fn LLVMDIVariableGetScope(&self, Var: LLVMMetadataRef) -> LLVMMetadataRef {
        (self
            .LLVMDIVariableGetScope
            .as_ref()
            .expect("Expected function, got error."))(Var)
    }
    #[doc = " Get the source line where this \\c DIVariable is declared.\n \\param Var     The DIVariable.\n\n @see DIVariable::getLine()"]
    pub unsafe fn LLVMDIVariableGetLine(&self, Var: LLVMMetadataRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMDIVariableGetLine
            .as_ref()
            .expect("Expected function, got error."))(Var)
    }
    #[doc = " Create a new temporary \\c MDNode.  Suitable for use in constructing cyclic\n \\c MDNode structures. A temporary \\c MDNode is not uniqued, may be RAUW'd,\n and must be manually deleted with \\c LLVMDisposeTemporaryMDNode.\n \\param Ctx            The context in which to construct the temporary node.\n \\param Data           The metadata elements.\n \\param NumElements    Number of metadata elements."]
    pub unsafe fn LLVMTemporaryMDNode(
        &self,
        Ctx: LLVMContextRef,
        Data: *mut LLVMMetadataRef,
        NumElements: usize,
    ) -> LLVMMetadataRef {
        (self
            .LLVMTemporaryMDNode
            .as_ref()
            .expect("Expected function, got error."))(Ctx, Data, NumElements)
    }
    #[doc = " Deallocate a temporary node.\n\n Calls \\c replaceAllUsesWith(nullptr) before deleting, so any remaining\n references will be reset.\n \\param TempNode    The temporary metadata node."]
    pub unsafe fn LLVMDisposeTemporaryMDNode(&self, TempNode: LLVMMetadataRef) {
        (self
            .LLVMDisposeTemporaryMDNode
            .as_ref()
            .expect("Expected function, got error."))(TempNode)
    }
    #[doc = " Replace all uses of temporary metadata.\n \\param TempTargetMetadata    The temporary metadata node.\n \\param Replacement           The replacement metadata node."]
    pub unsafe fn LLVMMetadataReplaceAllUsesWith(
        &self,
        TempTargetMetadata: LLVMMetadataRef,
        Replacement: LLVMMetadataRef,
    ) {
        (self
            .LLVMMetadataReplaceAllUsesWith
            .as_ref()
            .expect("Expected function, got error."))(TempTargetMetadata, Replacement)
    }
    #[doc = " Create a new descriptor for the specified global variable that is temporary\n and meant to be RAUWed.\n \\param Scope       Variable scope.\n \\param Name        Name of the variable.\n \\param NameLen     The length of the C string passed to \\c Name.\n \\param Linkage     Mangled  name of the variable.\n \\param LnkLen      The length of the C string passed to \\c Linkage.\n \\param File        File where this variable is defined.\n \\param LineNo      Line number.\n \\param Ty          Variable Type.\n \\param LocalToUnit Boolean flag indicate whether this variable is\n                    externally visible or not.\n \\param Decl        Reference to the corresponding declaration.\n \\param AlignInBits Variable alignment(or 0 if no alignment attr was\n                    specified)"]
    pub unsafe fn LLVMDIBuilderCreateTempGlobalVariableFwdDecl(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        Linkage: *const ::std::os::raw::c_char,
        LnkLen: usize,
        File: LLVMMetadataRef,
        LineNo: ::std::os::raw::c_uint,
        Ty: LLVMMetadataRef,
        LocalToUnit: LLVMBool,
        Decl: LLVMMetadataRef,
        AlignInBits: u32,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateTempGlobalVariableFwdDecl
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            Name,
            NameLen,
            Linkage,
            LnkLen,
            File,
            LineNo,
            Ty,
            LocalToUnit,
            Decl,
            AlignInBits,
        )
    }
    #[doc = " Insert a new llvm.dbg.declare intrinsic call before the given instruction.\n \\param Builder     The DIBuilder.\n \\param Storage     The storage of the variable to declare.\n \\param VarInfo     The variable's debug info descriptor.\n \\param Expr        A complex location expression for the variable.\n \\param DebugLoc    Debug info location.\n \\param Instr       Instruction acting as a location for the new intrinsic."]
    pub unsafe fn LLVMDIBuilderInsertDeclareBefore(
        &self,
        Builder: LLVMDIBuilderRef,
        Storage: LLVMValueRef,
        VarInfo: LLVMMetadataRef,
        Expr: LLVMMetadataRef,
        DebugLoc: LLVMMetadataRef,
        Instr: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMDIBuilderInsertDeclareBefore
            .as_ref()
            .expect("Expected function, got error."))(
            Builder, Storage, VarInfo, Expr, DebugLoc, Instr,
        )
    }
    #[doc = " Insert a new llvm.dbg.declare intrinsic call at the end of the given basic\n block. If the basic block has a terminator instruction, the intrinsic is\n inserted before that terminator instruction.\n \\param Builder     The DIBuilder.\n \\param Storage     The storage of the variable to declare.\n \\param VarInfo     The variable's debug info descriptor.\n \\param Expr        A complex location expression for the variable.\n \\param DebugLoc    Debug info location.\n \\param Block       Basic block acting as a location for the new intrinsic."]
    pub unsafe fn LLVMDIBuilderInsertDeclareAtEnd(
        &self,
        Builder: LLVMDIBuilderRef,
        Storage: LLVMValueRef,
        VarInfo: LLVMMetadataRef,
        Expr: LLVMMetadataRef,
        DebugLoc: LLVMMetadataRef,
        Block: LLVMBasicBlockRef,
    ) -> LLVMValueRef {
        (self
            .LLVMDIBuilderInsertDeclareAtEnd
            .as_ref()
            .expect("Expected function, got error."))(
            Builder, Storage, VarInfo, Expr, DebugLoc, Block,
        )
    }
    #[doc = " Insert a new llvm.dbg.value intrinsic call before the given instruction.\n \\param Builder     The DIBuilder.\n \\param Val         The value of the variable.\n \\param VarInfo     The variable's debug info descriptor.\n \\param Expr        A complex location expression for the variable.\n \\param DebugLoc    Debug info location.\n \\param Instr       Instruction acting as a location for the new intrinsic."]
    pub unsafe fn LLVMDIBuilderInsertDbgValueBefore(
        &self,
        Builder: LLVMDIBuilderRef,
        Val: LLVMValueRef,
        VarInfo: LLVMMetadataRef,
        Expr: LLVMMetadataRef,
        DebugLoc: LLVMMetadataRef,
        Instr: LLVMValueRef,
    ) -> LLVMValueRef {
        (self
            .LLVMDIBuilderInsertDbgValueBefore
            .as_ref()
            .expect("Expected function, got error."))(
            Builder, Val, VarInfo, Expr, DebugLoc, Instr
        )
    }
    #[doc = " Insert a new llvm.dbg.value intrinsic call at the end of the given basic\n block. If the basic block has a terminator instruction, the intrinsic is\n inserted before that terminator instruction.\n \\param Builder     The DIBuilder.\n \\param Val         The value of the variable.\n \\param VarInfo     The variable's debug info descriptor.\n \\param Expr        A complex location expression for the variable.\n \\param DebugLoc    Debug info location.\n \\param Block       Basic block acting as a location for the new intrinsic."]
    pub unsafe fn LLVMDIBuilderInsertDbgValueAtEnd(
        &self,
        Builder: LLVMDIBuilderRef,
        Val: LLVMValueRef,
        VarInfo: LLVMMetadataRef,
        Expr: LLVMMetadataRef,
        DebugLoc: LLVMMetadataRef,
        Block: LLVMBasicBlockRef,
    ) -> LLVMValueRef {
        (self
            .LLVMDIBuilderInsertDbgValueAtEnd
            .as_ref()
            .expect("Expected function, got error."))(
            Builder, Val, VarInfo, Expr, DebugLoc, Block
        )
    }
    #[doc = " Create a new descriptor for a local auto variable.\n \\param Builder         The DIBuilder.\n \\param Scope           The local scope the variable is declared in.\n \\param Name            Variable name.\n \\param NameLen         Length of variable name.\n \\param File            File where this variable is defined.\n \\param LineNo          Line number.\n \\param Ty              Metadata describing the type of the variable.\n \\param AlwaysPreserve  If true, this descriptor will survive optimizations.\n \\param Flags           Flags.\n \\param AlignInBits     Variable alignment."]
    pub unsafe fn LLVMDIBuilderCreateAutoVariable(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        File: LLVMMetadataRef,
        LineNo: ::std::os::raw::c_uint,
        Ty: LLVMMetadataRef,
        AlwaysPreserve: LLVMBool,
        Flags: LLVMDIFlags,
        AlignInBits: u32,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateAutoVariable
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            Name,
            NameLen,
            File,
            LineNo,
            Ty,
            AlwaysPreserve,
            Flags,
            AlignInBits,
        )
    }
    #[doc = " Create a new descriptor for a function parameter variable.\n \\param Builder         The DIBuilder.\n \\param Scope           The local scope the variable is declared in.\n \\param Name            Variable name.\n \\param NameLen         Length of variable name.\n \\param ArgNo           Unique argument number for this variable; starts at 1.\n \\param File            File where this variable is defined.\n \\param LineNo          Line number.\n \\param Ty              Metadata describing the type of the variable.\n \\param AlwaysPreserve  If true, this descriptor will survive optimizations.\n \\param Flags           Flags."]
    pub unsafe fn LLVMDIBuilderCreateParameterVariable(
        &self,
        Builder: LLVMDIBuilderRef,
        Scope: LLVMMetadataRef,
        Name: *const ::std::os::raw::c_char,
        NameLen: usize,
        ArgNo: ::std::os::raw::c_uint,
        File: LLVMMetadataRef,
        LineNo: ::std::os::raw::c_uint,
        Ty: LLVMMetadataRef,
        AlwaysPreserve: LLVMBool,
        Flags: LLVMDIFlags,
    ) -> LLVMMetadataRef {
        (self
            .LLVMDIBuilderCreateParameterVariable
            .as_ref()
            .expect("Expected function, got error."))(
            Builder,
            Scope,
            Name,
            NameLen,
            ArgNo,
            File,
            LineNo,
            Ty,
            AlwaysPreserve,
            Flags,
        )
    }
    #[doc = " Get the metadata of the subprogram attached to a function.\n\n @see llvm::Function::getSubprogram()"]
    pub unsafe fn LLVMGetSubprogram(&self, Func: LLVMValueRef) -> LLVMMetadataRef {
        (self
            .LLVMGetSubprogram
            .as_ref()
            .expect("Expected function, got error."))(Func)
    }
    #[doc = " Set the subprogram attached to a function.\n\n @see llvm::Function::setSubprogram()"]
    pub unsafe fn LLVMSetSubprogram(&self, Func: LLVMValueRef, SP: LLVMMetadataRef) {
        (self
            .LLVMSetSubprogram
            .as_ref()
            .expect("Expected function, got error."))(Func, SP)
    }
    #[doc = " Get the line associated with a given subprogram.\n \\param Subprogram     The subprogram object.\n\n @see DISubprogram::getLine()"]
    pub unsafe fn LLVMDISubprogramGetLine(
        &self,
        Subprogram: LLVMMetadataRef,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMDISubprogramGetLine
            .as_ref()
            .expect("Expected function, got error."))(Subprogram)
    }
    #[doc = " Get the debug location for the given instruction.\n\n @see llvm::Instruction::getDebugLoc()"]
    pub unsafe fn LLVMInstructionGetDebugLoc(&self, Inst: LLVMValueRef) -> LLVMMetadataRef {
        (self
            .LLVMInstructionGetDebugLoc
            .as_ref()
            .expect("Expected function, got error."))(Inst)
    }
    #[doc = " Set the debug location for the given instruction.\n\n To clear the location metadata of the given instruction, pass NULL to \\p Loc.\n\n @see llvm::Instruction::setDebugLoc()"]
    pub unsafe fn LLVMInstructionSetDebugLoc(&self, Inst: LLVMValueRef, Loc: LLVMMetadataRef) {
        (self
            .LLVMInstructionSetDebugLoc
            .as_ref()
            .expect("Expected function, got error."))(Inst, Loc)
    }
    #[doc = " Obtain the enumerated type of a Metadata instance.\n\n @see llvm::Metadata::getMetadataID()"]
    pub unsafe fn LLVMGetMetadataKind(&self, Metadata: LLVMMetadataRef) -> LLVMMetadataKind {
        (self
            .LLVMGetMetadataKind
            .as_ref()
            .expect("Expected function, got error."))(Metadata)
    }
    #[doc = " Create a disassembler for the TripleName.  Symbolic disassembly is supported\n by passing a block of information in the DisInfo parameter and specifying the\n TagType and callback functions as described above.  These can all be passed\n as NULL.  If successful, this returns a disassembler context.  If not, it\n returns NULL. This function is equivalent to calling\n LLVMCreateDisasmCPUFeatures() with an empty CPU name and feature set."]
    pub unsafe fn LLVMCreateDisasm(
        &self,
        TripleName: *const ::std::os::raw::c_char,
        DisInfo: *mut ::std::os::raw::c_void,
        TagType: ::std::os::raw::c_int,
        GetOpInfo: LLVMOpInfoCallback,
        SymbolLookUp: LLVMSymbolLookupCallback,
    ) -> LLVMDisasmContextRef {
        (self
            .LLVMCreateDisasm
            .as_ref()
            .expect("Expected function, got error."))(
            TripleName,
            DisInfo,
            TagType,
            GetOpInfo,
            SymbolLookUp,
        )
    }
    #[doc = " Create a disassembler for the TripleName and a specific CPU.  Symbolic\n disassembly is supported by passing a block of information in the DisInfo\n parameter and specifying the TagType and callback functions as described\n above.  These can all be passed * as NULL.  If successful, this returns a\n disassembler context.  If not, it returns NULL. This function is equivalent\n to calling LLVMCreateDisasmCPUFeatures() with an empty feature set."]
    pub unsafe fn LLVMCreateDisasmCPU(
        &self,
        Triple: *const ::std::os::raw::c_char,
        CPU: *const ::std::os::raw::c_char,
        DisInfo: *mut ::std::os::raw::c_void,
        TagType: ::std::os::raw::c_int,
        GetOpInfo: LLVMOpInfoCallback,
        SymbolLookUp: LLVMSymbolLookupCallback,
    ) -> LLVMDisasmContextRef {
        (self
            .LLVMCreateDisasmCPU
            .as_ref()
            .expect("Expected function, got error."))(
            Triple,
            CPU,
            DisInfo,
            TagType,
            GetOpInfo,
            SymbolLookUp,
        )
    }
    #[doc = " Create a disassembler for the TripleName, a specific CPU and specific feature\n string.  Symbolic disassembly is supported by passing a block of information\n in the DisInfo parameter and specifying the TagType and callback functions as\n described above.  These can all be passed * as NULL.  If successful, this\n returns a disassembler context.  If not, it returns NULL."]
    pub unsafe fn LLVMCreateDisasmCPUFeatures(
        &self,
        Triple: *const ::std::os::raw::c_char,
        CPU: *const ::std::os::raw::c_char,
        Features: *const ::std::os::raw::c_char,
        DisInfo: *mut ::std::os::raw::c_void,
        TagType: ::std::os::raw::c_int,
        GetOpInfo: LLVMOpInfoCallback,
        SymbolLookUp: LLVMSymbolLookupCallback,
    ) -> LLVMDisasmContextRef {
        (self
            .LLVMCreateDisasmCPUFeatures
            .as_ref()
            .expect("Expected function, got error."))(
            Triple,
            CPU,
            Features,
            DisInfo,
            TagType,
            GetOpInfo,
            SymbolLookUp,
        )
    }
    #[doc = " Set the disassembler's options.  Returns 1 if it can set the Options and 0\n otherwise."]
    pub unsafe fn LLVMSetDisasmOptions(
        &self,
        DC: LLVMDisasmContextRef,
        Options: u64,
    ) -> ::std::os::raw::c_int {
        (self
            .LLVMSetDisasmOptions
            .as_ref()
            .expect("Expected function, got error."))(DC, Options)
    }
    #[doc = " Dispose of a disassembler context."]
    pub unsafe fn LLVMDisasmDispose(&self, DC: LLVMDisasmContextRef) {
        (self
            .LLVMDisasmDispose
            .as_ref()
            .expect("Expected function, got error."))(DC)
    }
    #[doc = " Disassemble a single instruction using the disassembler context specified in\n the parameter DC.  The bytes of the instruction are specified in the\n parameter Bytes, and contains at least BytesSize number of bytes.  The\n instruction is at the address specified by the PC parameter.  If a valid\n instruction can be disassembled, its string is returned indirectly in\n OutString whose size is specified in the parameter OutStringSize.  This\n function returns the number of bytes in the instruction or zero if there was\n no valid instruction."]
    pub unsafe fn LLVMDisasmInstruction(
        &self,
        DC: LLVMDisasmContextRef,
        Bytes: *mut u8,
        BytesSize: u64,
        PC: u64,
        OutString: *mut ::std::os::raw::c_char,
        OutStringSize: usize,
    ) -> usize {
        (self
            .LLVMDisasmInstruction
            .as_ref()
            .expect("Expected function, got error."))(
            DC,
            Bytes,
            BytesSize,
            PC,
            OutString,
            OutStringSize,
        )
    }
    #[doc = " Returns the type id for the given error instance, which must be a failure\n value (i.e. non-null)."]
    pub unsafe fn LLVMGetErrorTypeId(&self, err: LLVMErrorRef) -> LLVMErrorTypeId {
        (self
            .LLVMGetErrorTypeId
            .as_ref()
            .expect("Expected function, got error."))(err)
    }
    #[doc = " Dispose of the given error without handling it. This operation consumes the\n error, and the given LLVMErrorRef value is not usable once this call returns.\n Note: This method *only* needs to be called if the error is not being passed\n to some other consuming operation, e.g. LLVMGetErrorMessage."]
    pub unsafe fn LLVMConsumeError(&self, err: LLVMErrorRef) {
        (self
            .LLVMConsumeError
            .as_ref()
            .expect("Expected function, got error."))(err)
    }
    #[doc = " Returns the given string's error message. This operation consumes the error,\n and the given LLVMErrorRef value is not usable once this call returns.\n The caller is responsible for disposing of the string by calling\n LLVMDisposeErrorMessage."]
    pub unsafe fn LLVMGetErrorMessage(&self, err: LLVMErrorRef) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMGetErrorMessage
            .as_ref()
            .expect("Expected function, got error."))(err)
    }
    #[doc = " Dispose of the given error message."]
    pub unsafe fn LLVMDisposeErrorMessage(&self, ErrMsg: *mut ::std::os::raw::c_char) {
        (self
            .LLVMDisposeErrorMessage
            .as_ref()
            .expect("Expected function, got error."))(ErrMsg)
    }
    #[doc = " Returns the type id for llvm StringError."]
    pub unsafe fn LLVMGetStringErrorTypeId(&self) -> LLVMErrorTypeId {
        (self
            .LLVMGetStringErrorTypeId
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Create a StringError."]
    pub unsafe fn LLVMCreateStringError(
        &self,
        ErrMsg: *const ::std::os::raw::c_char,
    ) -> LLVMErrorRef {
        (self
            .LLVMCreateStringError
            .as_ref()
            .expect("Expected function, got error."))(ErrMsg)
    }
    pub unsafe fn LLVMInitializeAArch64TargetInfo(&self) {
        (self
            .LLVMInitializeAArch64TargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAMDGPUTargetInfo(&self) {
        (self
            .LLVMInitializeAMDGPUTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeARMTargetInfo(&self) {
        (self
            .LLVMInitializeARMTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAVRTargetInfo(&self) {
        (self
            .LLVMInitializeAVRTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeBPFTargetInfo(&self) {
        (self
            .LLVMInitializeBPFTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeHexagonTargetInfo(&self) {
        (self
            .LLVMInitializeHexagonTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeLanaiTargetInfo(&self) {
        (self
            .LLVMInitializeLanaiTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeLoongArchTargetInfo(&self) {
        (self
            .LLVMInitializeLoongArchTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeMipsTargetInfo(&self) {
        (self
            .LLVMInitializeMipsTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeMSP430TargetInfo(&self) {
        (self
            .LLVMInitializeMSP430TargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeNVPTXTargetInfo(&self) {
        (self
            .LLVMInitializeNVPTXTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializePowerPCTargetInfo(&self) {
        (self
            .LLVMInitializePowerPCTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeRISCVTargetInfo(&self) {
        (self
            .LLVMInitializeRISCVTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeSparcTargetInfo(&self) {
        (self
            .LLVMInitializeSparcTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeSystemZTargetInfo(&self) {
        (self
            .LLVMInitializeSystemZTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeVETargetInfo(&self) {
        (self
            .LLVMInitializeVETargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeWebAssemblyTargetInfo(&self) {
        (self
            .LLVMInitializeWebAssemblyTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeX86TargetInfo(&self) {
        (self
            .LLVMInitializeX86TargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeXCoreTargetInfo(&self) {
        (self
            .LLVMInitializeXCoreTargetInfo
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAArch64Target(&self) {
        (self
            .LLVMInitializeAArch64Target
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAMDGPUTarget(&self) {
        (self
            .LLVMInitializeAMDGPUTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeARMTarget(&self) {
        (self
            .LLVMInitializeARMTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAVRTarget(&self) {
        (self
            .LLVMInitializeAVRTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeBPFTarget(&self) {
        (self
            .LLVMInitializeBPFTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeHexagonTarget(&self) {
        (self
            .LLVMInitializeHexagonTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeLanaiTarget(&self) {
        (self
            .LLVMInitializeLanaiTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeLoongArchTarget(&self) {
        (self
            .LLVMInitializeLoongArchTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeMipsTarget(&self) {
        (self
            .LLVMInitializeMipsTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeMSP430Target(&self) {
        (self
            .LLVMInitializeMSP430Target
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeNVPTXTarget(&self) {
        (self
            .LLVMInitializeNVPTXTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializePowerPCTarget(&self) {
        (self
            .LLVMInitializePowerPCTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeRISCVTarget(&self) {
        (self
            .LLVMInitializeRISCVTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeSparcTarget(&self) {
        (self
            .LLVMInitializeSparcTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeSystemZTarget(&self) {
        (self
            .LLVMInitializeSystemZTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeVETarget(&self) {
        (self
            .LLVMInitializeVETarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeWebAssemblyTarget(&self) {
        (self
            .LLVMInitializeWebAssemblyTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeX86Target(&self) {
        (self
            .LLVMInitializeX86Target
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeXCoreTarget(&self) {
        (self
            .LLVMInitializeXCoreTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAArch64TargetMC(&self) {
        (self
            .LLVMInitializeAArch64TargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAMDGPUTargetMC(&self) {
        (self
            .LLVMInitializeAMDGPUTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeARMTargetMC(&self) {
        (self
            .LLVMInitializeARMTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAVRTargetMC(&self) {
        (self
            .LLVMInitializeAVRTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeBPFTargetMC(&self) {
        (self
            .LLVMInitializeBPFTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeHexagonTargetMC(&self) {
        (self
            .LLVMInitializeHexagonTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeLanaiTargetMC(&self) {
        (self
            .LLVMInitializeLanaiTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeLoongArchTargetMC(&self) {
        (self
            .LLVMInitializeLoongArchTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeMipsTargetMC(&self) {
        (self
            .LLVMInitializeMipsTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeMSP430TargetMC(&self) {
        (self
            .LLVMInitializeMSP430TargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeNVPTXTargetMC(&self) {
        (self
            .LLVMInitializeNVPTXTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializePowerPCTargetMC(&self) {
        (self
            .LLVMInitializePowerPCTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeRISCVTargetMC(&self) {
        (self
            .LLVMInitializeRISCVTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeSparcTargetMC(&self) {
        (self
            .LLVMInitializeSparcTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeSystemZTargetMC(&self) {
        (self
            .LLVMInitializeSystemZTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeVETargetMC(&self) {
        (self
            .LLVMInitializeVETargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeWebAssemblyTargetMC(&self) {
        (self
            .LLVMInitializeWebAssemblyTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeX86TargetMC(&self) {
        (self
            .LLVMInitializeX86TargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeXCoreTargetMC(&self) {
        (self
            .LLVMInitializeXCoreTargetMC
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAArch64AsmPrinter(&self) {
        (self
            .LLVMInitializeAArch64AsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAMDGPUAsmPrinter(&self) {
        (self
            .LLVMInitializeAMDGPUAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeARMAsmPrinter(&self) {
        (self
            .LLVMInitializeARMAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAVRAsmPrinter(&self) {
        (self
            .LLVMInitializeAVRAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeBPFAsmPrinter(&self) {
        (self
            .LLVMInitializeBPFAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeHexagonAsmPrinter(&self) {
        (self
            .LLVMInitializeHexagonAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeLanaiAsmPrinter(&self) {
        (self
            .LLVMInitializeLanaiAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeLoongArchAsmPrinter(&self) {
        (self
            .LLVMInitializeLoongArchAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeMipsAsmPrinter(&self) {
        (self
            .LLVMInitializeMipsAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeMSP430AsmPrinter(&self) {
        (self
            .LLVMInitializeMSP430AsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeNVPTXAsmPrinter(&self) {
        (self
            .LLVMInitializeNVPTXAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializePowerPCAsmPrinter(&self) {
        (self
            .LLVMInitializePowerPCAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeRISCVAsmPrinter(&self) {
        (self
            .LLVMInitializeRISCVAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeSparcAsmPrinter(&self) {
        (self
            .LLVMInitializeSparcAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeSystemZAsmPrinter(&self) {
        (self
            .LLVMInitializeSystemZAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeVEAsmPrinter(&self) {
        (self
            .LLVMInitializeVEAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeWebAssemblyAsmPrinter(&self) {
        (self
            .LLVMInitializeWebAssemblyAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeX86AsmPrinter(&self) {
        (self
            .LLVMInitializeX86AsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeXCoreAsmPrinter(&self) {
        (self
            .LLVMInitializeXCoreAsmPrinter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAArch64AsmParser(&self) {
        (self
            .LLVMInitializeAArch64AsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAMDGPUAsmParser(&self) {
        (self
            .LLVMInitializeAMDGPUAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeARMAsmParser(&self) {
        (self
            .LLVMInitializeARMAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAVRAsmParser(&self) {
        (self
            .LLVMInitializeAVRAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeBPFAsmParser(&self) {
        (self
            .LLVMInitializeBPFAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeHexagonAsmParser(&self) {
        (self
            .LLVMInitializeHexagonAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeLanaiAsmParser(&self) {
        (self
            .LLVMInitializeLanaiAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeLoongArchAsmParser(&self) {
        (self
            .LLVMInitializeLoongArchAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeMipsAsmParser(&self) {
        (self
            .LLVMInitializeMipsAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeMSP430AsmParser(&self) {
        (self
            .LLVMInitializeMSP430AsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializePowerPCAsmParser(&self) {
        (self
            .LLVMInitializePowerPCAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeRISCVAsmParser(&self) {
        (self
            .LLVMInitializeRISCVAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeSparcAsmParser(&self) {
        (self
            .LLVMInitializeSparcAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeSystemZAsmParser(&self) {
        (self
            .LLVMInitializeSystemZAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeVEAsmParser(&self) {
        (self
            .LLVMInitializeVEAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeWebAssemblyAsmParser(&self) {
        (self
            .LLVMInitializeWebAssemblyAsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeX86AsmParser(&self) {
        (self
            .LLVMInitializeX86AsmParser
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAArch64Disassembler(&self) {
        (self
            .LLVMInitializeAArch64Disassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAMDGPUDisassembler(&self) {
        (self
            .LLVMInitializeAMDGPUDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeARMDisassembler(&self) {
        (self
            .LLVMInitializeARMDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeAVRDisassembler(&self) {
        (self
            .LLVMInitializeAVRDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeBPFDisassembler(&self) {
        (self
            .LLVMInitializeBPFDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeHexagonDisassembler(&self) {
        (self
            .LLVMInitializeHexagonDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeLanaiDisassembler(&self) {
        (self
            .LLVMInitializeLanaiDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeLoongArchDisassembler(&self) {
        (self
            .LLVMInitializeLoongArchDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeMipsDisassembler(&self) {
        (self
            .LLVMInitializeMipsDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeMSP430Disassembler(&self) {
        (self
            .LLVMInitializeMSP430Disassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializePowerPCDisassembler(&self) {
        (self
            .LLVMInitializePowerPCDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeRISCVDisassembler(&self) {
        (self
            .LLVMInitializeRISCVDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeSparcDisassembler(&self) {
        (self
            .LLVMInitializeSparcDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeSystemZDisassembler(&self) {
        (self
            .LLVMInitializeSystemZDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeVEDisassembler(&self) {
        (self
            .LLVMInitializeVEDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeWebAssemblyDisassembler(&self) {
        (self
            .LLVMInitializeWebAssemblyDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeX86Disassembler(&self) {
        (self
            .LLVMInitializeX86Disassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMInitializeXCoreDisassembler(&self) {
        (self
            .LLVMInitializeXCoreDisassembler
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Obtain the data layout for a module.\n\n @see Module::getDataLayout()"]
    pub unsafe fn LLVMGetModuleDataLayout(&self, M: LLVMModuleRef) -> LLVMTargetDataRef {
        (self
            .LLVMGetModuleDataLayout
            .as_ref()
            .expect("Expected function, got error."))(M)
    }
    #[doc = " Set the data layout for a module.\n\n @see Module::setDataLayout()"]
    pub unsafe fn LLVMSetModuleDataLayout(&self, M: LLVMModuleRef, DL: LLVMTargetDataRef) {
        (self
            .LLVMSetModuleDataLayout
            .as_ref()
            .expect("Expected function, got error."))(M, DL)
    }
    #[doc = " Creates target data from a target layout string.\nSee the constructor llvm::DataLayout::DataLayout."]
    pub unsafe fn LLVMCreateTargetData(
        &self,
        StringRep: *const ::std::os::raw::c_char,
    ) -> LLVMTargetDataRef {
        (self
            .LLVMCreateTargetData
            .as_ref()
            .expect("Expected function, got error."))(StringRep)
    }
    #[doc = " Deallocates a TargetData.\nSee the destructor llvm::DataLayout::~DataLayout."]
    pub unsafe fn LLVMDisposeTargetData(&self, TD: LLVMTargetDataRef) {
        (self
            .LLVMDisposeTargetData
            .as_ref()
            .expect("Expected function, got error."))(TD)
    }
    #[doc = " Adds target library information to a pass manager. This does not take\nownership of the target library info.\nSee the method llvm::PassManagerBase::add."]
    pub unsafe fn LLVMAddTargetLibraryInfo(
        &self,
        TLI: LLVMTargetLibraryInfoRef,
        PM: LLVMPassManagerRef,
    ) {
        (self
            .LLVMAddTargetLibraryInfo
            .as_ref()
            .expect("Expected function, got error."))(TLI, PM)
    }
    #[doc = " Converts target data to a target layout string. The string must be disposed\nwith LLVMDisposeMessage.\nSee the constructor llvm::DataLayout::DataLayout."]
    pub unsafe fn LLVMCopyStringRepOfTargetData(
        &self,
        TD: LLVMTargetDataRef,
    ) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMCopyStringRepOfTargetData
            .as_ref()
            .expect("Expected function, got error."))(TD)
    }
    #[doc = " Returns the byte order of a target, either LLVMBigEndian or\nLLVMLittleEndian.\nSee the method llvm::DataLayout::isLittleEndian."]
    pub unsafe fn LLVMByteOrder(&self, TD: LLVMTargetDataRef) -> LLVMByteOrdering {
        (self
            .LLVMByteOrder
            .as_ref()
            .expect("Expected function, got error."))(TD)
    }
    #[doc = " Returns the pointer size in bytes for a target.\nSee the method llvm::DataLayout::getPointerSize."]
    pub unsafe fn LLVMPointerSize(&self, TD: LLVMTargetDataRef) -> ::std::os::raw::c_uint {
        (self
            .LLVMPointerSize
            .as_ref()
            .expect("Expected function, got error."))(TD)
    }
    #[doc = " Returns the pointer size in bytes for a target for a specified\naddress space.\nSee the method llvm::DataLayout::getPointerSize."]
    pub unsafe fn LLVMPointerSizeForAS(
        &self,
        TD: LLVMTargetDataRef,
        AS: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMPointerSizeForAS
            .as_ref()
            .expect("Expected function, got error."))(TD, AS)
    }
    #[doc = " Returns the integer type that is the same size as a pointer on a target.\nSee the method llvm::DataLayout::getIntPtrType."]
    pub unsafe fn LLVMIntPtrType(&self, TD: LLVMTargetDataRef) -> LLVMTypeRef {
        (self
            .LLVMIntPtrType
            .as_ref()
            .expect("Expected function, got error."))(TD)
    }
    #[doc = " Returns the integer type that is the same size as a pointer on a target.\nThis version allows the address space to be specified.\nSee the method llvm::DataLayout::getIntPtrType."]
    pub unsafe fn LLVMIntPtrTypeForAS(
        &self,
        TD: LLVMTargetDataRef,
        AS: ::std::os::raw::c_uint,
    ) -> LLVMTypeRef {
        (self
            .LLVMIntPtrTypeForAS
            .as_ref()
            .expect("Expected function, got error."))(TD, AS)
    }
    #[doc = " Returns the integer type that is the same size as a pointer on a target.\nSee the method llvm::DataLayout::getIntPtrType."]
    pub unsafe fn LLVMIntPtrTypeInContext(
        &self,
        C: LLVMContextRef,
        TD: LLVMTargetDataRef,
    ) -> LLVMTypeRef {
        (self
            .LLVMIntPtrTypeInContext
            .as_ref()
            .expect("Expected function, got error."))(C, TD)
    }
    #[doc = " Returns the integer type that is the same size as a pointer on a target.\nThis version allows the address space to be specified.\nSee the method llvm::DataLayout::getIntPtrType."]
    pub unsafe fn LLVMIntPtrTypeForASInContext(
        &self,
        C: LLVMContextRef,
        TD: LLVMTargetDataRef,
        AS: ::std::os::raw::c_uint,
    ) -> LLVMTypeRef {
        (self
            .LLVMIntPtrTypeForASInContext
            .as_ref()
            .expect("Expected function, got error."))(C, TD, AS)
    }
    #[doc = " Computes the size of a type in bytes for a target.\nSee the method llvm::DataLayout::getTypeSizeInBits."]
    pub unsafe fn LLVMSizeOfTypeInBits(
        &self,
        TD: LLVMTargetDataRef,
        Ty: LLVMTypeRef,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            .LLVMSizeOfTypeInBits
            .as_ref()
            .expect("Expected function, got error."))(TD, Ty)
    }
    #[doc = " Computes the storage size of a type in bytes for a target.\nSee the method llvm::DataLayout::getTypeStoreSize."]
    pub unsafe fn LLVMStoreSizeOfType(
        &self,
        TD: LLVMTargetDataRef,
        Ty: LLVMTypeRef,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            .LLVMStoreSizeOfType
            .as_ref()
            .expect("Expected function, got error."))(TD, Ty)
    }
    #[doc = " Computes the ABI size of a type in bytes for a target.\nSee the method llvm::DataLayout::getTypeAllocSize."]
    pub unsafe fn LLVMABISizeOfType(
        &self,
        TD: LLVMTargetDataRef,
        Ty: LLVMTypeRef,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            .LLVMABISizeOfType
            .as_ref()
            .expect("Expected function, got error."))(TD, Ty)
    }
    #[doc = " Computes the ABI alignment of a type in bytes for a target.\nSee the method llvm::DataLayout::getTypeABISize."]
    pub unsafe fn LLVMABIAlignmentOfType(
        &self,
        TD: LLVMTargetDataRef,
        Ty: LLVMTypeRef,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMABIAlignmentOfType
            .as_ref()
            .expect("Expected function, got error."))(TD, Ty)
    }
    #[doc = " Computes the call frame alignment of a type in bytes for a target.\nSee the method llvm::DataLayout::getTypeABISize."]
    pub unsafe fn LLVMCallFrameAlignmentOfType(
        &self,
        TD: LLVMTargetDataRef,
        Ty: LLVMTypeRef,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMCallFrameAlignmentOfType
            .as_ref()
            .expect("Expected function, got error."))(TD, Ty)
    }
    #[doc = " Computes the preferred alignment of a type in bytes for a target.\nSee the method llvm::DataLayout::getTypeABISize."]
    pub unsafe fn LLVMPreferredAlignmentOfType(
        &self,
        TD: LLVMTargetDataRef,
        Ty: LLVMTypeRef,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMPreferredAlignmentOfType
            .as_ref()
            .expect("Expected function, got error."))(TD, Ty)
    }
    #[doc = " Computes the preferred alignment of a global variable in bytes for a target.\nSee the method llvm::DataLayout::getPreferredAlignment."]
    pub unsafe fn LLVMPreferredAlignmentOfGlobal(
        &self,
        TD: LLVMTargetDataRef,
        GlobalVar: LLVMValueRef,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMPreferredAlignmentOfGlobal
            .as_ref()
            .expect("Expected function, got error."))(TD, GlobalVar)
    }
    #[doc = " Computes the structure element that contains the byte offset for a target.\nSee the method llvm::StructLayout::getElementContainingOffset."]
    pub unsafe fn LLVMElementAtOffset(
        &self,
        TD: LLVMTargetDataRef,
        StructTy: LLVMTypeRef,
        Offset: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMElementAtOffset
            .as_ref()
            .expect("Expected function, got error."))(TD, StructTy, Offset)
    }
    #[doc = " Computes the byte offset of the indexed struct element for a target.\nSee the method llvm::StructLayout::getElementContainingOffset."]
    pub unsafe fn LLVMOffsetOfElement(
        &self,
        TD: LLVMTargetDataRef,
        StructTy: LLVMTypeRef,
        Element: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            .LLVMOffsetOfElement
            .as_ref()
            .expect("Expected function, got error."))(TD, StructTy, Element)
    }
    #[doc = " Returns the first llvm::Target in the registered targets list."]
    pub unsafe fn LLVMGetFirstTarget(&self) -> LLVMTargetRef {
        (self
            .LLVMGetFirstTarget
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Returns the next llvm::Target given a previous one (or null if there's none)"]
    pub unsafe fn LLVMGetNextTarget(&self, T: LLVMTargetRef) -> LLVMTargetRef {
        (self
            .LLVMGetNextTarget
            .as_ref()
            .expect("Expected function, got error."))(T)
    }
    #[doc = " Finds the target corresponding to the given name and stores it in \\p T.\nReturns 0 on success."]
    pub unsafe fn LLVMGetTargetFromName(
        &self,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMTargetRef {
        (self
            .LLVMGetTargetFromName
            .as_ref()
            .expect("Expected function, got error."))(Name)
    }
    #[doc = " Finds the target corresponding to the given triple and stores it in \\p T.\nReturns 0 on success. Optionally returns any error in ErrorMessage.\nUse LLVMDisposeMessage to dispose the message."]
    pub unsafe fn LLVMGetTargetFromTriple(
        &self,
        Triple: *const ::std::os::raw::c_char,
        T: *mut LLVMTargetRef,
        ErrorMessage: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMGetTargetFromTriple
            .as_ref()
            .expect("Expected function, got error."))(Triple, T, ErrorMessage)
    }
    #[doc = " Returns the name of a target. See llvm::Target::getName"]
    pub unsafe fn LLVMGetTargetName(&self, T: LLVMTargetRef) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetTargetName
            .as_ref()
            .expect("Expected function, got error."))(T)
    }
    #[doc = " Returns the description  of a target. See llvm::Target::getDescription"]
    pub unsafe fn LLVMGetTargetDescription(
        &self,
        T: LLVMTargetRef,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetTargetDescription
            .as_ref()
            .expect("Expected function, got error."))(T)
    }
    #[doc = " Returns if the target has a JIT"]
    pub unsafe fn LLVMTargetHasJIT(&self, T: LLVMTargetRef) -> LLVMBool {
        (self
            .LLVMTargetHasJIT
            .as_ref()
            .expect("Expected function, got error."))(T)
    }
    #[doc = " Returns if the target has a TargetMachine associated"]
    pub unsafe fn LLVMTargetHasTargetMachine(&self, T: LLVMTargetRef) -> LLVMBool {
        (self
            .LLVMTargetHasTargetMachine
            .as_ref()
            .expect("Expected function, got error."))(T)
    }
    #[doc = " Returns if the target as an ASM backend (required for emitting output)"]
    pub unsafe fn LLVMTargetHasAsmBackend(&self, T: LLVMTargetRef) -> LLVMBool {
        (self
            .LLVMTargetHasAsmBackend
            .as_ref()
            .expect("Expected function, got error."))(T)
    }
    #[doc = " Creates a new llvm::TargetMachine. See llvm::Target::createTargetMachine"]
    pub unsafe fn LLVMCreateTargetMachine(
        &self,
        T: LLVMTargetRef,
        Triple: *const ::std::os::raw::c_char,
        CPU: *const ::std::os::raw::c_char,
        Features: *const ::std::os::raw::c_char,
        Level: LLVMCodeGenOptLevel,
        Reloc: LLVMRelocMode,
        CodeModel: LLVMCodeModel,
    ) -> LLVMTargetMachineRef {
        (self
            .LLVMCreateTargetMachine
            .as_ref()
            .expect("Expected function, got error."))(
            T, Triple, CPU, Features, Level, Reloc, CodeModel,
        )
    }
    #[doc = " Dispose the LLVMTargetMachineRef instance generated by\nLLVMCreateTargetMachine."]
    pub unsafe fn LLVMDisposeTargetMachine(&self, T: LLVMTargetMachineRef) {
        (self
            .LLVMDisposeTargetMachine
            .as_ref()
            .expect("Expected function, got error."))(T)
    }
    #[doc = " Returns the Target used in a TargetMachine"]
    pub unsafe fn LLVMGetTargetMachineTarget(&self, T: LLVMTargetMachineRef) -> LLVMTargetRef {
        (self
            .LLVMGetTargetMachineTarget
            .as_ref()
            .expect("Expected function, got error."))(T)
    }
    #[doc = " Returns the triple used creating this target machine. See\nllvm::TargetMachine::getTriple. The result needs to be disposed with\nLLVMDisposeMessage."]
    pub unsafe fn LLVMGetTargetMachineTriple(
        &self,
        T: LLVMTargetMachineRef,
    ) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMGetTargetMachineTriple
            .as_ref()
            .expect("Expected function, got error."))(T)
    }
    #[doc = " Returns the cpu used creating this target machine. See\nllvm::TargetMachine::getCPU. The result needs to be disposed with\nLLVMDisposeMessage."]
    pub unsafe fn LLVMGetTargetMachineCPU(
        &self,
        T: LLVMTargetMachineRef,
    ) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMGetTargetMachineCPU
            .as_ref()
            .expect("Expected function, got error."))(T)
    }
    #[doc = " Returns the feature string used creating this target machine. See\nllvm::TargetMachine::getFeatureString. The result needs to be disposed with\nLLVMDisposeMessage."]
    pub unsafe fn LLVMGetTargetMachineFeatureString(
        &self,
        T: LLVMTargetMachineRef,
    ) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMGetTargetMachineFeatureString
            .as_ref()
            .expect("Expected function, got error."))(T)
    }
    #[doc = " Create a DataLayout based on the targetMachine."]
    pub unsafe fn LLVMCreateTargetDataLayout(&self, T: LLVMTargetMachineRef) -> LLVMTargetDataRef {
        (self
            .LLVMCreateTargetDataLayout
            .as_ref()
            .expect("Expected function, got error."))(T)
    }
    #[doc = " Set the target machine's ASM verbosity."]
    pub unsafe fn LLVMSetTargetMachineAsmVerbosity(
        &self,
        T: LLVMTargetMachineRef,
        VerboseAsm: LLVMBool,
    ) {
        (self
            .LLVMSetTargetMachineAsmVerbosity
            .as_ref()
            .expect("Expected function, got error."))(T, VerboseAsm)
    }
    #[doc = " Emits an asm or object file for the given module to the filename. This\nwraps several c++ only classes (among them a file stream). Returns any\nerror in ErrorMessage. Use LLVMDisposeMessage to dispose the message."]
    pub unsafe fn LLVMTargetMachineEmitToFile(
        &self,
        T: LLVMTargetMachineRef,
        M: LLVMModuleRef,
        Filename: *const ::std::os::raw::c_char,
        codegen: LLVMCodeGenFileType,
        ErrorMessage: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMTargetMachineEmitToFile
            .as_ref()
            .expect("Expected function, got error."))(T, M, Filename, codegen, ErrorMessage)
    }
    #[doc = " Compile the LLVM IR stored in \\p M and store the result in \\p OutMemBuf."]
    pub unsafe fn LLVMTargetMachineEmitToMemoryBuffer(
        &self,
        T: LLVMTargetMachineRef,
        M: LLVMModuleRef,
        codegen: LLVMCodeGenFileType,
        ErrorMessage: *mut *mut ::std::os::raw::c_char,
        OutMemBuf: *mut LLVMMemoryBufferRef,
    ) -> LLVMBool {
        (self
            .LLVMTargetMachineEmitToMemoryBuffer
            .as_ref()
            .expect("Expected function, got error."))(T, M, codegen, ErrorMessage, OutMemBuf)
    }
    #[doc = " Get a triple for the host machine as a string. The result needs to be\ndisposed with LLVMDisposeMessage."]
    pub unsafe fn LLVMGetDefaultTargetTriple(&self) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMGetDefaultTargetTriple
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Normalize a target triple. The result needs to be disposed with\nLLVMDisposeMessage."]
    pub unsafe fn LLVMNormalizeTargetTriple(
        &self,
        triple: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMNormalizeTargetTriple
            .as_ref()
            .expect("Expected function, got error."))(triple)
    }
    #[doc = " Get the host CPU as a string. The result needs to be disposed with\nLLVMDisposeMessage."]
    pub unsafe fn LLVMGetHostCPUName(&self) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMGetHostCPUName
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Get the host CPU's features as a string. The result needs to be disposed\nwith LLVMDisposeMessage."]
    pub unsafe fn LLVMGetHostCPUFeatures(&self) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMGetHostCPUFeatures
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Adds the target-specific analysis passes to the pass manager."]
    pub unsafe fn LLVMAddAnalysisPasses(&self, T: LLVMTargetMachineRef, PM: LLVMPassManagerRef) {
        (self
            .LLVMAddAnalysisPasses
            .as_ref()
            .expect("Expected function, got error."))(T, PM)
    }
    #[doc = " @defgroup LLVMCExecutionEngine Execution Engine\n @ingroup LLVMC\n\n @{"]
    pub unsafe fn LLVMLinkInMCJIT(&self) {
        (self
            .LLVMLinkInMCJIT
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMLinkInInterpreter(&self) {
        (self
            .LLVMLinkInInterpreter
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMCreateGenericValueOfInt(
        &self,
        Ty: LLVMTypeRef,
        N: ::std::os::raw::c_ulonglong,
        IsSigned: LLVMBool,
    ) -> LLVMGenericValueRef {
        (self
            .LLVMCreateGenericValueOfInt
            .as_ref()
            .expect("Expected function, got error."))(Ty, N, IsSigned)
    }
    pub unsafe fn LLVMCreateGenericValueOfPointer(
        &self,
        P: *mut ::std::os::raw::c_void,
    ) -> LLVMGenericValueRef {
        (self
            .LLVMCreateGenericValueOfPointer
            .as_ref()
            .expect("Expected function, got error."))(P)
    }
    pub unsafe fn LLVMCreateGenericValueOfFloat(
        &self,
        Ty: LLVMTypeRef,
        N: f64,
    ) -> LLVMGenericValueRef {
        (self
            .LLVMCreateGenericValueOfFloat
            .as_ref()
            .expect("Expected function, got error."))(Ty, N)
    }
    pub unsafe fn LLVMGenericValueIntWidth(
        &self,
        GenValRef: LLVMGenericValueRef,
    ) -> ::std::os::raw::c_uint {
        (self
            .LLVMGenericValueIntWidth
            .as_ref()
            .expect("Expected function, got error."))(GenValRef)
    }
    pub unsafe fn LLVMGenericValueToInt(
        &self,
        GenVal: LLVMGenericValueRef,
        IsSigned: LLVMBool,
    ) -> ::std::os::raw::c_ulonglong {
        (self
            .LLVMGenericValueToInt
            .as_ref()
            .expect("Expected function, got error."))(GenVal, IsSigned)
    }
    pub unsafe fn LLVMGenericValueToPointer(
        &self,
        GenVal: LLVMGenericValueRef,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .LLVMGenericValueToPointer
            .as_ref()
            .expect("Expected function, got error."))(GenVal)
    }
    pub unsafe fn LLVMGenericValueToFloat(
        &self,
        TyRef: LLVMTypeRef,
        GenVal: LLVMGenericValueRef,
    ) -> f64 {
        (self
            .LLVMGenericValueToFloat
            .as_ref()
            .expect("Expected function, got error."))(TyRef, GenVal)
    }
    pub unsafe fn LLVMDisposeGenericValue(&self, GenVal: LLVMGenericValueRef) {
        (self
            .LLVMDisposeGenericValue
            .as_ref()
            .expect("Expected function, got error."))(GenVal)
    }
    pub unsafe fn LLVMCreateExecutionEngineForModule(
        &self,
        OutEE: *mut LLVMExecutionEngineRef,
        M: LLVMModuleRef,
        OutError: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMCreateExecutionEngineForModule
            .as_ref()
            .expect("Expected function, got error."))(OutEE, M, OutError)
    }
    pub unsafe fn LLVMCreateInterpreterForModule(
        &self,
        OutInterp: *mut LLVMExecutionEngineRef,
        M: LLVMModuleRef,
        OutError: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMCreateInterpreterForModule
            .as_ref()
            .expect("Expected function, got error."))(OutInterp, M, OutError)
    }
    pub unsafe fn LLVMCreateJITCompilerForModule(
        &self,
        OutJIT: *mut LLVMExecutionEngineRef,
        M: LLVMModuleRef,
        OptLevel: ::std::os::raw::c_uint,
        OutError: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMCreateJITCompilerForModule
            .as_ref()
            .expect("Expected function, got error."))(OutJIT, M, OptLevel, OutError)
    }
    pub unsafe fn LLVMInitializeMCJITCompilerOptions(
        &self,
        Options: *mut LLVMMCJITCompilerOptions,
        SizeOfOptions: usize,
    ) {
        (self
            .LLVMInitializeMCJITCompilerOptions
            .as_ref()
            .expect("Expected function, got error."))(Options, SizeOfOptions)
    }
    #[doc = " Create an MCJIT execution engine for a module, with the given options. It is\n the responsibility of the caller to ensure that all fields in Options up to\n the given SizeOfOptions are initialized. It is correct to pass a smaller\n value of SizeOfOptions that omits some fields. The canonical way of using\n this is:\n\n LLVMMCJITCompilerOptions options;\n LLVMInitializeMCJITCompilerOptions(&options, sizeof(options));\n ... fill in those options you care about\n LLVMCreateMCJITCompilerForModule(&jit, mod, &options, sizeof(options),\n                                  &error);\n\n Note that this is also correct, though possibly suboptimal:\n\n LLVMCreateMCJITCompilerForModule(&jit, mod, 0, 0, &error);"]
    pub unsafe fn LLVMCreateMCJITCompilerForModule(
        &self,
        OutJIT: *mut LLVMExecutionEngineRef,
        M: LLVMModuleRef,
        Options: *mut LLVMMCJITCompilerOptions,
        SizeOfOptions: usize,
        OutError: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMCreateMCJITCompilerForModule
            .as_ref()
            .expect("Expected function, got error."))(
            OutJIT, M, Options, SizeOfOptions, OutError
        )
    }
    pub unsafe fn LLVMDisposeExecutionEngine(&self, EE: LLVMExecutionEngineRef) {
        (self
            .LLVMDisposeExecutionEngine
            .as_ref()
            .expect("Expected function, got error."))(EE)
    }
    pub unsafe fn LLVMRunStaticConstructors(&self, EE: LLVMExecutionEngineRef) {
        (self
            .LLVMRunStaticConstructors
            .as_ref()
            .expect("Expected function, got error."))(EE)
    }
    pub unsafe fn LLVMRunStaticDestructors(&self, EE: LLVMExecutionEngineRef) {
        (self
            .LLVMRunStaticDestructors
            .as_ref()
            .expect("Expected function, got error."))(EE)
    }
    pub unsafe fn LLVMRunFunctionAsMain(
        &self,
        EE: LLVMExecutionEngineRef,
        F: LLVMValueRef,
        ArgC: ::std::os::raw::c_uint,
        ArgV: *const *const ::std::os::raw::c_char,
        EnvP: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self
            .LLVMRunFunctionAsMain
            .as_ref()
            .expect("Expected function, got error."))(EE, F, ArgC, ArgV, EnvP)
    }
    pub unsafe fn LLVMRunFunction(
        &self,
        EE: LLVMExecutionEngineRef,
        F: LLVMValueRef,
        NumArgs: ::std::os::raw::c_uint,
        Args: *mut LLVMGenericValueRef,
    ) -> LLVMGenericValueRef {
        (self
            .LLVMRunFunction
            .as_ref()
            .expect("Expected function, got error."))(EE, F, NumArgs, Args)
    }
    pub unsafe fn LLVMFreeMachineCodeForFunction(
        &self,
        EE: LLVMExecutionEngineRef,
        F: LLVMValueRef,
    ) {
        (self
            .LLVMFreeMachineCodeForFunction
            .as_ref()
            .expect("Expected function, got error."))(EE, F)
    }
    pub unsafe fn LLVMAddModule(&self, EE: LLVMExecutionEngineRef, M: LLVMModuleRef) {
        (self
            .LLVMAddModule
            .as_ref()
            .expect("Expected function, got error."))(EE, M)
    }
    pub unsafe fn LLVMRemoveModule(
        &self,
        EE: LLVMExecutionEngineRef,
        M: LLVMModuleRef,
        OutMod: *mut LLVMModuleRef,
        OutError: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMRemoveModule
            .as_ref()
            .expect("Expected function, got error."))(EE, M, OutMod, OutError)
    }
    pub unsafe fn LLVMFindFunction(
        &self,
        EE: LLVMExecutionEngineRef,
        Name: *const ::std::os::raw::c_char,
        OutFn: *mut LLVMValueRef,
    ) -> LLVMBool {
        (self
            .LLVMFindFunction
            .as_ref()
            .expect("Expected function, got error."))(EE, Name, OutFn)
    }
    pub unsafe fn LLVMRecompileAndRelinkFunction(
        &self,
        EE: LLVMExecutionEngineRef,
        Fn: LLVMValueRef,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .LLVMRecompileAndRelinkFunction
            .as_ref()
            .expect("Expected function, got error."))(EE, Fn)
    }
    pub unsafe fn LLVMGetExecutionEngineTargetData(
        &self,
        EE: LLVMExecutionEngineRef,
    ) -> LLVMTargetDataRef {
        (self
            .LLVMGetExecutionEngineTargetData
            .as_ref()
            .expect("Expected function, got error."))(EE)
    }
    pub unsafe fn LLVMGetExecutionEngineTargetMachine(
        &self,
        EE: LLVMExecutionEngineRef,
    ) -> LLVMTargetMachineRef {
        (self
            .LLVMGetExecutionEngineTargetMachine
            .as_ref()
            .expect("Expected function, got error."))(EE)
    }
    pub unsafe fn LLVMAddGlobalMapping(
        &self,
        EE: LLVMExecutionEngineRef,
        Global: LLVMValueRef,
        Addr: *mut ::std::os::raw::c_void,
    ) {
        (self
            .LLVMAddGlobalMapping
            .as_ref()
            .expect("Expected function, got error."))(EE, Global, Addr)
    }
    pub unsafe fn LLVMGetPointerToGlobal(
        &self,
        EE: LLVMExecutionEngineRef,
        Global: LLVMValueRef,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .LLVMGetPointerToGlobal
            .as_ref()
            .expect("Expected function, got error."))(EE, Global)
    }
    pub unsafe fn LLVMGetGlobalValueAddress(
        &self,
        EE: LLVMExecutionEngineRef,
        Name: *const ::std::os::raw::c_char,
    ) -> u64 {
        (self
            .LLVMGetGlobalValueAddress
            .as_ref()
            .expect("Expected function, got error."))(EE, Name)
    }
    pub unsafe fn LLVMGetFunctionAddress(
        &self,
        EE: LLVMExecutionEngineRef,
        Name: *const ::std::os::raw::c_char,
    ) -> u64 {
        (self
            .LLVMGetFunctionAddress
            .as_ref()
            .expect("Expected function, got error."))(EE, Name)
    }
    #[doc = " Returns true on error, false on success. If true is returned then the error\n message is copied to OutStr and cleared in the ExecutionEngine instance."]
    pub unsafe fn LLVMExecutionEngineGetErrMsg(
        &self,
        EE: LLVMExecutionEngineRef,
        OutError: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMExecutionEngineGetErrMsg
            .as_ref()
            .expect("Expected function, got error."))(EE, OutError)
    }
    #[doc = " Create a simple custom MCJIT memory manager. This memory manager can\n intercept allocations in a module-oblivious way. This will return NULL\n if any of the passed functions are NULL.\n\n @param Opaque An opaque client object to pass back to the callbacks.\n @param AllocateCodeSection Allocate a block of memory for executable code.\n @param AllocateDataSection Allocate a block of memory for data.\n @param FinalizeMemory Set page permissions and flush cache. Return 0 on\n   success, 1 on error."]
    pub unsafe fn LLVMCreateSimpleMCJITMemoryManager(
        &self,
        Opaque: *mut ::std::os::raw::c_void,
        AllocateCodeSection: LLVMMemoryManagerAllocateCodeSectionCallback,
        AllocateDataSection: LLVMMemoryManagerAllocateDataSectionCallback,
        FinalizeMemory: LLVMMemoryManagerFinalizeMemoryCallback,
        Destroy: LLVMMemoryManagerDestroyCallback,
    ) -> LLVMMCJITMemoryManagerRef {
        (self
            .LLVMCreateSimpleMCJITMemoryManager
            .as_ref()
            .expect("Expected function, got error."))(
            Opaque,
            AllocateCodeSection,
            AllocateDataSection,
            FinalizeMemory,
            Destroy,
        )
    }
    pub unsafe fn LLVMDisposeMCJITMemoryManager(&self, MM: LLVMMCJITMemoryManagerRef) {
        (self
            .LLVMDisposeMCJITMemoryManager
            .as_ref()
            .expect("Expected function, got error."))(MM)
    }
    pub unsafe fn LLVMCreateGDBRegistrationListener(&self) -> LLVMJITEventListenerRef {
        (self
            .LLVMCreateGDBRegistrationListener
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMCreateIntelJITEventListener(&self) -> LLVMJITEventListenerRef {
        (self
            .LLVMCreateIntelJITEventListener
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMCreateOProfileJITEventListener(&self) -> LLVMJITEventListenerRef {
        (self
            .LLVMCreateOProfileJITEventListener
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn LLVMCreatePerfJITEventListener(&self) -> LLVMJITEventListenerRef {
        (self
            .LLVMCreatePerfJITEventListener
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Read LLVM IR from a memory buffer and convert it into an in-memory Module\n object. Returns 0 on success.\n Optionally returns a human-readable description of any errors that\n occurred during parsing IR. OutMessage must be disposed with\n LLVMDisposeMessage.\n\n @see llvm::ParseIR()"]
    pub unsafe fn LLVMParseIRInContext(
        &self,
        ContextRef: LLVMContextRef,
        MemBuf: LLVMMemoryBufferRef,
        OutM: *mut LLVMModuleRef,
        OutMessage: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMParseIRInContext
            .as_ref()
            .expect("Expected function, got error."))(ContextRef, MemBuf, OutM, OutMessage)
    }
    pub unsafe fn LLVMLinkModules2(&self, Dest: LLVMModuleRef, Src: LLVMModuleRef) -> LLVMBool {
        (self
            .LLVMLinkModules2
            .as_ref()
            .expect("Expected function, got error."))(Dest, Src)
    }
    #[doc = " Attach a custom error reporter function to the ExecutionSession.\n\n The error reporter will be called to deliver failure notices that can not be\n directly reported to a caller. For example, failure to resolve symbols in\n the JIT linker is typically reported via the error reporter (callers\n requesting definitions from the JIT will typically be delivered a\n FailureToMaterialize error instead)."]
    pub unsafe fn LLVMOrcExecutionSessionSetErrorReporter(
        &self,
        ES: LLVMOrcExecutionSessionRef,
        ReportError: LLVMOrcErrorReporterFunction,
        Ctx: *mut ::std::os::raw::c_void,
    ) {
        (self
            .LLVMOrcExecutionSessionSetErrorReporter
            .as_ref()
            .expect("Expected function, got error."))(ES, ReportError, Ctx)
    }
    #[doc = " Return a reference to the SymbolStringPool for an ExecutionSession.\n\n Ownership of the pool remains with the ExecutionSession: The caller is\n not required to free the pool."]
    pub unsafe fn LLVMOrcExecutionSessionGetSymbolStringPool(
        &self,
        ES: LLVMOrcExecutionSessionRef,
    ) -> LLVMOrcSymbolStringPoolRef {
        (self
            .LLVMOrcExecutionSessionGetSymbolStringPool
            .as_ref()
            .expect("Expected function, got error."))(ES)
    }
    #[doc = " Clear all unreferenced symbol string pool entries.\n\n This can be called at any time to release unused entries in the\n ExecutionSession's string pool. Since it locks the pool (preventing\n interning of any new strings) it is recommended that it only be called\n infrequently, ideally when the caller has reason to believe that some\n entries will have become unreferenced, e.g. after removing a module or\n closing a JITDylib."]
    pub unsafe fn LLVMOrcSymbolStringPoolClearDeadEntries(&self, SSP: LLVMOrcSymbolStringPoolRef) {
        (self
            .LLVMOrcSymbolStringPoolClearDeadEntries
            .as_ref()
            .expect("Expected function, got error."))(SSP)
    }
    #[doc = " Intern a string in the ExecutionSession's SymbolStringPool and return a\n reference to it. This increments the ref-count of the pool entry, and the\n returned value should be released once the client is done with it by\n calling LLVMOrReleaseSymbolStringPoolEntry.\n\n Since strings are uniqued within the SymbolStringPool\n LLVMOrcSymbolStringPoolEntryRefs can be compared by value to test string\n equality.\n\n Note that this function does not perform linker-mangling on the string."]
    pub unsafe fn LLVMOrcExecutionSessionIntern(
        &self,
        ES: LLVMOrcExecutionSessionRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMOrcSymbolStringPoolEntryRef {
        (self
            .LLVMOrcExecutionSessionIntern
            .as_ref()
            .expect("Expected function, got error."))(ES, Name)
    }
    #[doc = " Look up symbols in an execution session.\n\n This is a wrapper around the general ExecutionSession::lookup function.\n\n The SearchOrder argument contains a list of (JITDylibs, JITDylibSearchFlags)\n pairs that describe the search order. The JITDylibs will be searched in the\n given order to try to find the symbols in the Symbols argument.\n\n The Symbols argument should contain a null-terminated array of\n (SymbolStringPtr, SymbolLookupFlags) pairs describing the symbols to be\n searched for. This function takes ownership of the elements of the Symbols\n array. The Name fields of the Symbols elements are taken to have been\n retained by the client for this function. The client should *not* release the\n Name fields, but are still responsible for destroying the array itself.\n\n The HandleResult function will be called once all searched for symbols have\n been found, or an error occurs. The HandleResult function will be passed an\n LLVMErrorRef indicating success or failure, and (on success) a\n null-terminated LLVMOrcCSymbolMapPairs array containing the function result,\n and the Ctx value passed to the lookup function.\n\n The client is fully responsible for managing the lifetime of the Ctx object.\n A common idiom is to allocate the context prior to the lookup and deallocate\n it in the handler.\n\n THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!"]
    pub unsafe fn LLVMOrcExecutionSessionLookup(
        &self,
        ES: LLVMOrcExecutionSessionRef,
        K: LLVMOrcLookupKind,
        SearchOrder: LLVMOrcCJITDylibSearchOrder,
        SearchOrderSize: usize,
        Symbols: LLVMOrcCLookupSet,
        SymbolsSize: usize,
        HandleResult: LLVMOrcExecutionSessionLookupHandleResultFunction,
        Ctx: *mut ::std::os::raw::c_void,
    ) {
        (self
            .LLVMOrcExecutionSessionLookup
            .as_ref()
            .expect("Expected function, got error."))(
            ES,
            K,
            SearchOrder,
            SearchOrderSize,
            Symbols,
            SymbolsSize,
            HandleResult,
            Ctx,
        )
    }
    #[doc = " Increments the ref-count for a SymbolStringPool entry."]
    pub unsafe fn LLVMOrcRetainSymbolStringPoolEntry(&self, S: LLVMOrcSymbolStringPoolEntryRef) {
        (self
            .LLVMOrcRetainSymbolStringPoolEntry
            .as_ref()
            .expect("Expected function, got error."))(S)
    }
    #[doc = " Reduces the ref-count for of a SymbolStringPool entry."]
    pub unsafe fn LLVMOrcReleaseSymbolStringPoolEntry(&self, S: LLVMOrcSymbolStringPoolEntryRef) {
        (self
            .LLVMOrcReleaseSymbolStringPoolEntry
            .as_ref()
            .expect("Expected function, got error."))(S)
    }
    #[doc = " Return the c-string for the given symbol. This string will remain valid until\n the entry is freed (once all LLVMOrcSymbolStringPoolEntryRefs have been\n released)."]
    pub unsafe fn LLVMOrcSymbolStringPoolEntryStr(
        &self,
        S: LLVMOrcSymbolStringPoolEntryRef,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMOrcSymbolStringPoolEntryStr
            .as_ref()
            .expect("Expected function, got error."))(S)
    }
    #[doc = " Reduces the ref-count of a ResourceTracker."]
    pub unsafe fn LLVMOrcReleaseResourceTracker(&self, RT: LLVMOrcResourceTrackerRef) {
        (self
            .LLVMOrcReleaseResourceTracker
            .as_ref()
            .expect("Expected function, got error."))(RT)
    }
    #[doc = " Transfers tracking of all resources associated with resource tracker SrcRT\n to resource tracker DstRT."]
    pub unsafe fn LLVMOrcResourceTrackerTransferTo(
        &self,
        SrcRT: LLVMOrcResourceTrackerRef,
        DstRT: LLVMOrcResourceTrackerRef,
    ) {
        (self
            .LLVMOrcResourceTrackerTransferTo
            .as_ref()
            .expect("Expected function, got error."))(SrcRT, DstRT)
    }
    #[doc = " Remove all resources associated with the given tracker. See\n ResourceTracker::remove()."]
    pub unsafe fn LLVMOrcResourceTrackerRemove(
        &self,
        RT: LLVMOrcResourceTrackerRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcResourceTrackerRemove
            .as_ref()
            .expect("Expected function, got error."))(RT)
    }
    #[doc = " Dispose of a JITDylib::DefinitionGenerator. This should only be called if\n ownership has not been passed to a JITDylib (e.g. because some error\n prevented the client from calling LLVMOrcJITDylibAddGenerator)."]
    pub unsafe fn LLVMOrcDisposeDefinitionGenerator(&self, DG: LLVMOrcDefinitionGeneratorRef) {
        (self
            .LLVMOrcDisposeDefinitionGenerator
            .as_ref()
            .expect("Expected function, got error."))(DG)
    }
    #[doc = " Dispose of a MaterializationUnit."]
    pub unsafe fn LLVMOrcDisposeMaterializationUnit(&self, MU: LLVMOrcMaterializationUnitRef) {
        (self
            .LLVMOrcDisposeMaterializationUnit
            .as_ref()
            .expect("Expected function, got error."))(MU)
    }
    #[doc = " Create a custom MaterializationUnit.\n\n Name is a name for this MaterializationUnit to be used for identification\n and logging purposes (e.g. if this MaterializationUnit produces an\n object buffer then the name of that buffer will be derived from this name).\n\n The Syms list contains the names and linkages of the symbols provided by this\n unit. This function takes ownership of the elements of the Syms array. The\n Name fields of the array elements are taken to have been retained for this\n function. The client should *not* release the elements of the array, but is\n still responsible for destroying the array itself.\n\n The InitSym argument indicates whether or not this MaterializationUnit\n contains static initializers. If three are no static initializers (the common\n case) then this argument should be null. If there are static initializers\n then InitSym should be set to a unique name that also appears in the Syms\n list with the LLVMJITSymbolGenericFlagsMaterializationSideEffectsOnly flag\n set. This function takes ownership of the InitSym, which should have been\n retained twice on behalf of this function: once for the Syms entry and once\n for InitSym. If clients wish to use the InitSym value after this function\n returns they must retain it once more for themselves.\n\n If any of the symbols in the Syms list is looked up then the Materialize\n function will be called.\n\n If any of the symbols in the Syms list is overridden then the Discard\n function will be called.\n\n The caller owns the underling MaterializationUnit and is responsible for\n either passing it to a JITDylib (via LLVMOrcJITDylibDefine) or disposing\n of it by calling LLVMOrcDisposeMaterializationUnit."]
    pub unsafe fn LLVMOrcCreateCustomMaterializationUnit(
        &self,
        Name: *const ::std::os::raw::c_char,
        Ctx: *mut ::std::os::raw::c_void,
        Syms: LLVMOrcCSymbolFlagsMapPairs,
        NumSyms: usize,
        InitSym: LLVMOrcSymbolStringPoolEntryRef,
        Materialize: LLVMOrcMaterializationUnitMaterializeFunction,
        Discard: LLVMOrcMaterializationUnitDiscardFunction,
        Destroy: LLVMOrcMaterializationUnitDestroyFunction,
    ) -> LLVMOrcMaterializationUnitRef {
        (self
            .LLVMOrcCreateCustomMaterializationUnit
            .as_ref()
            .expect("Expected function, got error."))(
            Name,
            Ctx,
            Syms,
            NumSyms,
            InitSym,
            Materialize,
            Discard,
            Destroy,
        )
    }
    #[doc = " Create a MaterializationUnit to define the given symbols as pointing to\n the corresponding raw addresses.\n\n This function takes ownership of the elements of the Syms array. The Name\n fields of the array elements are taken to have been retained for this\n function. This allows the following pattern...\n\n   size_t NumPairs;\n   LLVMOrcCSymbolMapPairs Sym;\n   -- Build Syms array --\n   LLVMOrcMaterializationUnitRef MU =\n       LLVMOrcAbsoluteSymbols(Syms, NumPairs);\n\n ... without requiring cleanup of the elements of the Sym array afterwards.\n\n The client is still responsible for deleting the Sym array itself.\n\n If a client wishes to reuse elements of the Sym array after this call they\n must explicitly retain each of the elements for themselves."]
    pub unsafe fn LLVMOrcAbsoluteSymbols(
        &self,
        Syms: LLVMOrcCSymbolMapPairs,
        NumPairs: usize,
    ) -> LLVMOrcMaterializationUnitRef {
        (self
            .LLVMOrcAbsoluteSymbols
            .as_ref()
            .expect("Expected function, got error."))(Syms, NumPairs)
    }
    #[doc = " Create a MaterializationUnit to define lazy re-expots. These are callable\n entry points that call through to the given symbols.\n\n This function takes ownership of the CallableAliases array. The Name\n fields of the array elements are taken to have been retained for this\n function. This allows the following pattern...\n\n   size_t NumPairs;\n   LLVMOrcCSymbolAliasMapPairs CallableAliases;\n   -- Build CallableAliases array --\n   LLVMOrcMaterializationUnitRef MU =\n      LLVMOrcLazyReexports(LCTM, ISM, JD, CallableAliases, NumPairs);\n\n ... without requiring cleanup of the elements of the CallableAliases array afterwards.\n\n The client is still responsible for deleting the CallableAliases array itself.\n\n If a client wishes to reuse elements of the CallableAliases array after this call they\n must explicitly retain each of the elements for themselves."]
    pub unsafe fn LLVMOrcLazyReexports(
        &self,
        LCTM: LLVMOrcLazyCallThroughManagerRef,
        ISM: LLVMOrcIndirectStubsManagerRef,
        SourceRef: LLVMOrcJITDylibRef,
        CallableAliases: LLVMOrcCSymbolAliasMapPairs,
        NumPairs: usize,
    ) -> LLVMOrcMaterializationUnitRef {
        (self
            .LLVMOrcLazyReexports
            .as_ref()
            .expect("Expected function, got error."))(
            LCTM,
            ISM,
            SourceRef,
            CallableAliases,
            NumPairs,
        )
    }
    #[doc = " Disposes of the passed MaterializationResponsibility object.\n\n This should only be done after the symbols covered by the object have either\n been resolved and emitted (via\n LLVMOrcMaterializationResponsibilityNotifyResolved and\n LLVMOrcMaterializationResponsibilityNotifyEmitted) or failed (via\n LLVMOrcMaterializationResponsibilityFailMaterialization)."]
    pub unsafe fn LLVMOrcDisposeMaterializationResponsibility(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
    ) {
        (self
            .LLVMOrcDisposeMaterializationResponsibility
            .as_ref()
            .expect("Expected function, got error."))(MR)
    }
    #[doc = " Returns the target JITDylib that these symbols are being materialized into."]
    pub unsafe fn LLVMOrcMaterializationResponsibilityGetTargetDylib(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
    ) -> LLVMOrcJITDylibRef {
        (self
            .LLVMOrcMaterializationResponsibilityGetTargetDylib
            .as_ref()
            .expect("Expected function, got error."))(MR)
    }
    #[doc = " Returns the ExecutionSession for this MaterializationResponsibility."]
    pub unsafe fn LLVMOrcMaterializationResponsibilityGetExecutionSession(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
    ) -> LLVMOrcExecutionSessionRef {
        (self
            .LLVMOrcMaterializationResponsibilityGetExecutionSession
            .as_ref()
            .expect("Expected function, got error."))(MR)
    }
    #[doc = " Returns the symbol flags map for this responsibility instance.\n\n The length of the array is returned in NumPairs and the caller is responsible\n for the returned memory and needs to call LLVMOrcDisposeCSymbolFlagsMap.\n\n To use the returned symbols beyond the livetime of the\n MaterializationResponsibility requires the caller to retain the symbols\n explicitly."]
    pub unsafe fn LLVMOrcMaterializationResponsibilityGetSymbols(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
        NumPairs: *mut usize,
    ) -> LLVMOrcCSymbolFlagsMapPairs {
        (self
            .LLVMOrcMaterializationResponsibilityGetSymbols
            .as_ref()
            .expect("Expected function, got error."))(MR, NumPairs)
    }
    #[doc = " Disposes of the passed LLVMOrcCSymbolFlagsMap.\n\n Does not release the entries themselves."]
    pub unsafe fn LLVMOrcDisposeCSymbolFlagsMap(&self, Pairs: LLVMOrcCSymbolFlagsMapPairs) {
        (self
            .LLVMOrcDisposeCSymbolFlagsMap
            .as_ref()
            .expect("Expected function, got error."))(Pairs)
    }
    #[doc = " Returns the initialization pseudo-symbol, if any. This symbol will also\n be present in the SymbolFlagsMap for this MaterializationResponsibility\n object.\n\n The returned symbol is not retained over any mutating operation of the\n MaterializationResponsbility or beyond the lifetime thereof."]
    pub unsafe fn LLVMOrcMaterializationResponsibilityGetInitializerSymbol(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
    ) -> LLVMOrcSymbolStringPoolEntryRef {
        (self
            .LLVMOrcMaterializationResponsibilityGetInitializerSymbol
            .as_ref()
            .expect("Expected function, got error."))(MR)
    }
    #[doc = " Returns the names of any symbols covered by this\n MaterializationResponsibility object that have queries pending. This\n information can be used to return responsibility for unrequested symbols\n back to the JITDylib via the delegate method."]
    pub unsafe fn LLVMOrcMaterializationResponsibilityGetRequestedSymbols(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
        NumSymbols: *mut usize,
    ) -> *mut LLVMOrcSymbolStringPoolEntryRef {
        (self
            .LLVMOrcMaterializationResponsibilityGetRequestedSymbols
            .as_ref()
            .expect("Expected function, got error."))(MR, NumSymbols)
    }
    #[doc = " Disposes of the passed LLVMOrcSymbolStringPoolEntryRef* .\n\n Does not release the symbols themselves."]
    pub unsafe fn LLVMOrcDisposeSymbols(&self, Symbols: *mut LLVMOrcSymbolStringPoolEntryRef) {
        (self
            .LLVMOrcDisposeSymbols
            .as_ref()
            .expect("Expected function, got error."))(Symbols)
    }
    #[doc = " Notifies the target JITDylib that the given symbols have been resolved.\n This will update the given symbols' addresses in the JITDylib, and notify\n any pending queries on the given symbols of their resolution. The given\n symbols must be ones covered by this MaterializationResponsibility\n instance. Individual calls to this method may resolve a subset of the\n symbols, but all symbols must have been resolved prior to calling emit.\n\n This method will return an error if any symbols being resolved have been\n moved to the error state due to the failure of a dependency. If this\n method returns an error then clients should log it and call\n LLVMOrcMaterializationResponsibilityFailMaterialization. If no dependencies\n have been registered for the symbols covered by this\n MaterializationResponsibiility then this method is guaranteed to return\n LLVMErrorSuccess."]
    pub unsafe fn LLVMOrcMaterializationResponsibilityNotifyResolved(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
        Symbols: LLVMOrcCSymbolMapPairs,
        NumPairs: usize,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcMaterializationResponsibilityNotifyResolved
            .as_ref()
            .expect("Expected function, got error."))(MR, Symbols, NumPairs)
    }
    #[doc = " Notifies the target JITDylib (and any pending queries on that JITDylib)\n that all symbols covered by this MaterializationResponsibility instance\n have been emitted.\n\n This method will return an error if any symbols being resolved have been\n moved to the error state due to the failure of a dependency. If this\n method returns an error then clients should log it and call\n LLVMOrcMaterializationResponsibilityFailMaterialization.\n If no dependencies have been registered for the symbols covered by this\n MaterializationResponsibiility then this method is guaranteed to return\n LLVMErrorSuccess."]
    pub unsafe fn LLVMOrcMaterializationResponsibilityNotifyEmitted(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcMaterializationResponsibilityNotifyEmitted
            .as_ref()
            .expect("Expected function, got error."))(MR)
    }
    #[doc = " Attempt to claim responsibility for new definitions. This method can be\n used to claim responsibility for symbols that are added to a\n materialization unit during the compilation process (e.g. literal pool\n symbols). Symbol linkage rules are the same as for symbols that are\n defined up front: duplicate strong definitions will result in errors.\n Duplicate weak definitions will be discarded (in which case they will\n not be added to this responsibility instance).\n\n This method can be used by materialization units that want to add\n additional symbols at materialization time (e.g. stubs, compile\n callbacks, metadata)"]
    pub unsafe fn LLVMOrcMaterializationResponsibilityDefineMaterializing(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
        Pairs: LLVMOrcCSymbolFlagsMapPairs,
        NumPairs: usize,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcMaterializationResponsibilityDefineMaterializing
            .as_ref()
            .expect("Expected function, got error."))(MR, Pairs, NumPairs)
    }
    #[doc = " Notify all not-yet-emitted covered by this MaterializationResponsibility\n instance that an error has occurred.\n This will remove all symbols covered by this MaterializationResponsibilty\n from the target JITDylib, and send an error to any queries waiting on\n these symbols."]
    pub unsafe fn LLVMOrcMaterializationResponsibilityFailMaterialization(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
    ) {
        (self
            .LLVMOrcMaterializationResponsibilityFailMaterialization
            .as_ref()
            .expect("Expected function, got error."))(MR)
    }
    #[doc = " Transfers responsibility to the given MaterializationUnit for all\n symbols defined by that MaterializationUnit. This allows\n materializers to break up work based on run-time information (e.g.\n by introspecting which symbols have actually been looked up and\n materializing only those)."]
    pub unsafe fn LLVMOrcMaterializationResponsibilityReplace(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
        MU: LLVMOrcMaterializationUnitRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcMaterializationResponsibilityReplace
            .as_ref()
            .expect("Expected function, got error."))(MR, MU)
    }
    #[doc = " Delegates responsibility for the given symbols to the returned\n materialization responsibility. Useful for breaking up work between\n threads, or different kinds of materialization processes.\n\n The caller retains responsibility of the the passed\n MaterializationResponsibility."]
    pub unsafe fn LLVMOrcMaterializationResponsibilityDelegate(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
        Symbols: *mut LLVMOrcSymbolStringPoolEntryRef,
        NumSymbols: usize,
        Result: *mut LLVMOrcMaterializationResponsibilityRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcMaterializationResponsibilityDelegate
            .as_ref()
            .expect("Expected function, got error."))(MR, Symbols, NumSymbols, Result)
    }
    #[doc = " Adds dependencies to a symbol that the MaterializationResponsibility is\n responsible for.\n\n This function takes ownership of Dependencies struct. The Names\n array have been retained for this function. This allows the following\n pattern...\n\n   LLVMOrcSymbolStringPoolEntryRef Names[] = {...};\n   LLVMOrcCDependenceMapPair Dependence = {JD, {Names, sizeof(Names)}}\n   LLVMOrcMaterializationResponsibilityAddDependencies(JD, Name, &Dependence,\n 1);\n\n ... without requiring cleanup of the elements of the Names array afterwards.\n\n The client is still responsible for deleting the Dependencies.Names array\n itself."]
    pub unsafe fn LLVMOrcMaterializationResponsibilityAddDependencies(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
        Name: LLVMOrcSymbolStringPoolEntryRef,
        Dependencies: LLVMOrcCDependenceMapPairs,
        NumPairs: usize,
    ) {
        (self
            .LLVMOrcMaterializationResponsibilityAddDependencies
            .as_ref()
            .expect("Expected function, got error."))(MR, Name, Dependencies, NumPairs)
    }
    #[doc = " Adds dependencies to all symbols that the MaterializationResponsibility is\n responsible for. See LLVMOrcMaterializationResponsibilityAddDependencies for\n notes about memory responsibility."]
    pub unsafe fn LLVMOrcMaterializationResponsibilityAddDependenciesForAll(
        &self,
        MR: LLVMOrcMaterializationResponsibilityRef,
        Dependencies: LLVMOrcCDependenceMapPairs,
        NumPairs: usize,
    ) {
        (self
            .LLVMOrcMaterializationResponsibilityAddDependenciesForAll
            .as_ref()
            .expect("Expected function, got error."))(MR, Dependencies, NumPairs)
    }
    #[doc = " Create a \"bare\" JITDylib.\n\n The client is responsible for ensuring that the JITDylib's name is unique,\n e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.\n\n This call does not install any library code or symbols into the newly\n created JITDylib. The client is responsible for all configuration."]
    pub unsafe fn LLVMOrcExecutionSessionCreateBareJITDylib(
        &self,
        ES: LLVMOrcExecutionSessionRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMOrcJITDylibRef {
        (self
            .LLVMOrcExecutionSessionCreateBareJITDylib
            .as_ref()
            .expect("Expected function, got error."))(ES, Name)
    }
    #[doc = " Create a JITDylib.\n\n The client is responsible for ensuring that the JITDylib's name is unique,\n e.g. by calling LLVMOrcExecutionSessionGetJTIDylibByName first.\n\n If a Platform is attached to the ExecutionSession then\n Platform::setupJITDylib will be called to install standard platform symbols\n (e.g. standard library interposes). If no Platform is installed then this\n call is equivalent to LLVMExecutionSessionRefCreateBareJITDylib and will\n always return success."]
    pub unsafe fn LLVMOrcExecutionSessionCreateJITDylib(
        &self,
        ES: LLVMOrcExecutionSessionRef,
        Result: *mut LLVMOrcJITDylibRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcExecutionSessionCreateJITDylib
            .as_ref()
            .expect("Expected function, got error."))(ES, Result, Name)
    }
    #[doc = " Returns the JITDylib with the given name, or NULL if no such JITDylib\n exists."]
    pub unsafe fn LLVMOrcExecutionSessionGetJITDylibByName(
        &self,
        ES: LLVMOrcExecutionSessionRef,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMOrcJITDylibRef {
        (self
            .LLVMOrcExecutionSessionGetJITDylibByName
            .as_ref()
            .expect("Expected function, got error."))(ES, Name)
    }
    #[doc = " Return a reference to a newly created resource tracker associated with JD.\n The tracker is returned with an initial ref-count of 1, and must be released\n with LLVMOrcReleaseResourceTracker when no longer needed."]
    pub unsafe fn LLVMOrcJITDylibCreateResourceTracker(
        &self,
        JD: LLVMOrcJITDylibRef,
    ) -> LLVMOrcResourceTrackerRef {
        (self
            .LLVMOrcJITDylibCreateResourceTracker
            .as_ref()
            .expect("Expected function, got error."))(JD)
    }
    #[doc = " Return a reference to the default resource tracker for the given JITDylib.\n This operation will increase the retain count of the tracker: Clients should\n call LLVMOrcReleaseResourceTracker when the result is no longer needed."]
    pub unsafe fn LLVMOrcJITDylibGetDefaultResourceTracker(
        &self,
        JD: LLVMOrcJITDylibRef,
    ) -> LLVMOrcResourceTrackerRef {
        (self
            .LLVMOrcJITDylibGetDefaultResourceTracker
            .as_ref()
            .expect("Expected function, got error."))(JD)
    }
    #[doc = " Add the given MaterializationUnit to the given JITDylib.\n\n If this operation succeeds then JITDylib JD will take ownership of MU.\n If the operation fails then ownership remains with the caller who should\n call LLVMOrcDisposeMaterializationUnit to destroy it."]
    pub unsafe fn LLVMOrcJITDylibDefine(
        &self,
        JD: LLVMOrcJITDylibRef,
        MU: LLVMOrcMaterializationUnitRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcJITDylibDefine
            .as_ref()
            .expect("Expected function, got error."))(JD, MU)
    }
    #[doc = " Calls remove on all trackers associated with this JITDylib, see\n JITDylib::clear()."]
    pub unsafe fn LLVMOrcJITDylibClear(&self, JD: LLVMOrcJITDylibRef) -> LLVMErrorRef {
        (self
            .LLVMOrcJITDylibClear
            .as_ref()
            .expect("Expected function, got error."))(JD)
    }
    #[doc = " Add a DefinitionGenerator to the given JITDylib.\n\n The JITDylib will take ownership of the given generator: The client is no\n longer responsible for managing its memory."]
    pub unsafe fn LLVMOrcJITDylibAddGenerator(
        &self,
        JD: LLVMOrcJITDylibRef,
        DG: LLVMOrcDefinitionGeneratorRef,
    ) {
        (self
            .LLVMOrcJITDylibAddGenerator
            .as_ref()
            .expect("Expected function, got error."))(JD, DG)
    }
    #[doc = " Create a custom generator.\n\n The F argument will be used to implement the DefinitionGenerator's\n tryToGenerate method (see\n LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction).\n\n Ctx is a context object that will be passed to F. This argument is\n permitted to be null.\n\n Dispose is the disposal function for Ctx. This argument is permitted to be\n null (in which case the client is responsible for the lifetime of Ctx)."]
    pub unsafe fn LLVMOrcCreateCustomCAPIDefinitionGenerator(
        &self,
        F: LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction,
        Ctx: *mut ::std::os::raw::c_void,
        Dispose: LLVMOrcDisposeCAPIDefinitionGeneratorFunction,
    ) -> LLVMOrcDefinitionGeneratorRef {
        (self
            .LLVMOrcCreateCustomCAPIDefinitionGenerator
            .as_ref()
            .expect("Expected function, got error."))(F, Ctx, Dispose)
    }
    #[doc = " Continue a lookup that was suspended in a generator (see\n LLVMOrcCAPIDefinitionGeneratorTryToGenerateFunction)."]
    pub unsafe fn LLVMOrcLookupStateContinueLookup(
        &self,
        S: LLVMOrcLookupStateRef,
        err: LLVMErrorRef,
    ) {
        (self
            .LLVMOrcLookupStateContinueLookup
            .as_ref()
            .expect("Expected function, got error."))(S, err)
    }
    #[doc = " Get a DynamicLibrarySearchGenerator that will reflect process symbols into\n the JITDylib. On success the resulting generator is owned by the client.\n Ownership is typically transferred by adding the instance to a JITDylib\n using LLVMOrcJITDylibAddGenerator,\n\n The GlobalPrefix argument specifies the character that appears on the front\n of linker-mangled symbols for the target platform (e.g. '_' on MachO).\n If non-null, this character will be stripped from the start of all symbol\n strings before passing the remaining substring to dlsym.\n\n The optional Filter and Ctx arguments can be used to supply a symbol name\n filter: Only symbols for which the filter returns true will be visible to\n JIT'd code. If the Filter argument is null then all process symbols will\n be visible to JIT'd code. Note that the symbol name passed to the Filter\n function is the full mangled symbol: The client is responsible for stripping\n the global prefix if present."]
    pub unsafe fn LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess(
        &self,
        Result: *mut LLVMOrcDefinitionGeneratorRef,
        GlobalPrefx: ::std::os::raw::c_char,
        Filter: LLVMOrcSymbolPredicate,
        FilterCtx: *mut ::std::os::raw::c_void,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcCreateDynamicLibrarySearchGeneratorForProcess
            .as_ref()
            .expect("Expected function, got error."))(Result, GlobalPrefx, Filter, FilterCtx)
    }
    #[doc = " Get a LLVMOrcCreateDynamicLibararySearchGeneratorForPath that will reflect\n library symbols into the JITDylib. On success the resulting generator is\n owned by the client. Ownership is typically transferred by adding the\n instance to a JITDylib using LLVMOrcJITDylibAddGenerator,\n\n The GlobalPrefix argument specifies the character that appears on the front\n of linker-mangled symbols for the target platform (e.g. '_' on MachO).\n If non-null, this character will be stripped from the start of all symbol\n strings before passing the remaining substring to dlsym.\n\n The optional Filter and Ctx arguments can be used to supply a symbol name\n filter: Only symbols for which the filter returns true will be visible to\n JIT'd code. If the Filter argument is null then all library symbols will\n be visible to JIT'd code. Note that the symbol name passed to the Filter\n function is the full mangled symbol: The client is responsible for stripping\n the global prefix if present.\n\n THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!\n"]
    pub unsafe fn LLVMOrcCreateDynamicLibrarySearchGeneratorForPath(
        &self,
        Result: *mut LLVMOrcDefinitionGeneratorRef,
        FileName: *const ::std::os::raw::c_char,
        GlobalPrefix: ::std::os::raw::c_char,
        Filter: LLVMOrcSymbolPredicate,
        FilterCtx: *mut ::std::os::raw::c_void,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcCreateDynamicLibrarySearchGeneratorForPath
            .as_ref()
            .expect("Expected function, got error."))(
            Result,
            FileName,
            GlobalPrefix,
            Filter,
            FilterCtx,
        )
    }
    #[doc = " Get a LLVMOrcCreateStaticLibrarySearchGeneratorForPath that will reflect\n static library symbols into the JITDylib. On success the resulting\n generator is owned by the client. Ownership is typically transferred by\n adding the instance to a JITDylib using LLVMOrcJITDylibAddGenerator,\n\n Call with the optional TargetTriple argument will succeed if the file at\n the given path is a static library or a MachO universal binary containing a\n static library that is compatible with the given triple. Otherwise it will\n return an error.\n\n THIS API IS EXPERIMENTAL AND LIKELY TO CHANGE IN THE NEAR FUTURE!\n"]
    pub unsafe fn LLVMOrcCreateStaticLibrarySearchGeneratorForPath(
        &self,
        Result: *mut LLVMOrcDefinitionGeneratorRef,
        ObjLayer: LLVMOrcObjectLayerRef,
        FileName: *const ::std::os::raw::c_char,
        TargetTriple: *const ::std::os::raw::c_char,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcCreateStaticLibrarySearchGeneratorForPath
            .as_ref()
            .expect("Expected function, got error."))(
            Result, ObjLayer, FileName, TargetTriple
        )
    }
    #[doc = " Create a ThreadSafeContext containing a new LLVMContext.\n\n Ownership of the underlying ThreadSafeContext data is shared: Clients\n can and should dispose of their ThreadSafeContext as soon as they no longer\n need to refer to it directly. Other references (e.g. from ThreadSafeModules)\n will keep the data alive as long as it is needed."]
    pub unsafe fn LLVMOrcCreateNewThreadSafeContext(&self) -> LLVMOrcThreadSafeContextRef {
        (self
            .LLVMOrcCreateNewThreadSafeContext
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Get a reference to the wrapped LLVMContext."]
    pub unsafe fn LLVMOrcThreadSafeContextGetContext(
        &self,
        TSCtx: LLVMOrcThreadSafeContextRef,
    ) -> LLVMContextRef {
        (self
            .LLVMOrcThreadSafeContextGetContext
            .as_ref()
            .expect("Expected function, got error."))(TSCtx)
    }
    #[doc = " Dispose of a ThreadSafeContext."]
    pub unsafe fn LLVMOrcDisposeThreadSafeContext(&self, TSCtx: LLVMOrcThreadSafeContextRef) {
        (self
            .LLVMOrcDisposeThreadSafeContext
            .as_ref()
            .expect("Expected function, got error."))(TSCtx)
    }
    #[doc = " Create a ThreadSafeModule wrapper around the given LLVM module. This takes\n ownership of the M argument which should not be disposed of or referenced\n after this function returns.\n\n Ownership of the ThreadSafeModule is unique: If it is transferred to the JIT\n (e.g. by LLVMOrcLLJITAddLLVMIRModule) then the client is no longer\n responsible for it. If it is not transferred to the JIT then the client\n should call LLVMOrcDisposeThreadSafeModule to dispose of it."]
    pub unsafe fn LLVMOrcCreateNewThreadSafeModule(
        &self,
        M: LLVMModuleRef,
        TSCtx: LLVMOrcThreadSafeContextRef,
    ) -> LLVMOrcThreadSafeModuleRef {
        (self
            .LLVMOrcCreateNewThreadSafeModule
            .as_ref()
            .expect("Expected function, got error."))(M, TSCtx)
    }
    #[doc = " Dispose of a ThreadSafeModule. This should only be called if ownership has\n not been passed to LLJIT (e.g. because some error prevented the client from\n adding this to the JIT)."]
    pub unsafe fn LLVMOrcDisposeThreadSafeModule(&self, TSM: LLVMOrcThreadSafeModuleRef) {
        (self
            .LLVMOrcDisposeThreadSafeModule
            .as_ref()
            .expect("Expected function, got error."))(TSM)
    }
    #[doc = " Apply the given function to the module contained in this ThreadSafeModule."]
    pub unsafe fn LLVMOrcThreadSafeModuleWithModuleDo(
        &self,
        TSM: LLVMOrcThreadSafeModuleRef,
        F: LLVMOrcGenericIRModuleOperationFunction,
        Ctx: *mut ::std::os::raw::c_void,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcThreadSafeModuleWithModuleDo
            .as_ref()
            .expect("Expected function, got error."))(TSM, F, Ctx)
    }
    #[doc = " Create a JITTargetMachineBuilder by detecting the host.\n\n On success the client owns the resulting JITTargetMachineBuilder. It must be\n passed to a consuming operation (e.g.\n LLVMOrcLLJITBuilderSetJITTargetMachineBuilder) or disposed of by calling\n LLVMOrcDisposeJITTargetMachineBuilder."]
    pub unsafe fn LLVMOrcJITTargetMachineBuilderDetectHost(
        &self,
        Result: *mut LLVMOrcJITTargetMachineBuilderRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcJITTargetMachineBuilderDetectHost
            .as_ref()
            .expect("Expected function, got error."))(Result)
    }
    #[doc = " Create a JITTargetMachineBuilder from the given TargetMachine template.\n\n This operation takes ownership of the given TargetMachine and destroys it\n before returing. The resulting JITTargetMachineBuilder is owned by the client\n and must be passed to a consuming operation (e.g.\n LLVMOrcLLJITBuilderSetJITTargetMachineBuilder) or disposed of by calling\n LLVMOrcDisposeJITTargetMachineBuilder."]
    pub unsafe fn LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine(
        &self,
        TM: LLVMTargetMachineRef,
    ) -> LLVMOrcJITTargetMachineBuilderRef {
        (self
            .LLVMOrcJITTargetMachineBuilderCreateFromTargetMachine
            .as_ref()
            .expect("Expected function, got error."))(TM)
    }
    #[doc = " Dispose of a JITTargetMachineBuilder."]
    pub unsafe fn LLVMOrcDisposeJITTargetMachineBuilder(
        &self,
        JTMB: LLVMOrcJITTargetMachineBuilderRef,
    ) {
        (self
            .LLVMOrcDisposeJITTargetMachineBuilder
            .as_ref()
            .expect("Expected function, got error."))(JTMB)
    }
    #[doc = " Returns the target triple for the given JITTargetMachineBuilder as a string.\n\n The caller owns the resulting string as must dispose of it by calling\n LLVMDisposeMessage"]
    pub unsafe fn LLVMOrcJITTargetMachineBuilderGetTargetTriple(
        &self,
        JTMB: LLVMOrcJITTargetMachineBuilderRef,
    ) -> *mut ::std::os::raw::c_char {
        (self
            .LLVMOrcJITTargetMachineBuilderGetTargetTriple
            .as_ref()
            .expect("Expected function, got error."))(JTMB)
    }
    #[doc = " Sets the target triple for the given JITTargetMachineBuilder to the given\n string."]
    pub unsafe fn LLVMOrcJITTargetMachineBuilderSetTargetTriple(
        &self,
        JTMB: LLVMOrcJITTargetMachineBuilderRef,
        TargetTriple: *const ::std::os::raw::c_char,
    ) {
        (self
            .LLVMOrcJITTargetMachineBuilderSetTargetTriple
            .as_ref()
            .expect("Expected function, got error."))(JTMB, TargetTriple)
    }
    #[doc = " Add an object to an ObjectLayer to the given JITDylib.\n\n Adds a buffer representing an object file to the given JITDylib using the\n given ObjectLayer instance. This operation transfers ownership of the buffer\n to the ObjectLayer instance. The buffer should not be disposed of or\n referenced once this function returns.\n\n Resources associated with the given object will be tracked by the given\n JITDylib's default ResourceTracker."]
    pub unsafe fn LLVMOrcObjectLayerAddObjectFile(
        &self,
        ObjLayer: LLVMOrcObjectLayerRef,
        JD: LLVMOrcJITDylibRef,
        ObjBuffer: LLVMMemoryBufferRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcObjectLayerAddObjectFile
            .as_ref()
            .expect("Expected function, got error."))(ObjLayer, JD, ObjBuffer)
    }
    #[doc = " Add an object to an ObjectLayer using the given ResourceTracker.\n\n Adds a buffer representing an object file to the given ResourceTracker's\n JITDylib using the given ObjectLayer instance. This operation transfers\n ownership of the buffer to the ObjectLayer instance. The buffer should not\n be disposed of or referenced once this function returns.\n\n Resources associated with the given object will be tracked by\n ResourceTracker RT."]
    pub unsafe fn LLVMOrcObjectLayerAddObjectFileWithRT(
        &self,
        ObjLayer: LLVMOrcObjectLayerRef,
        RT: LLVMOrcResourceTrackerRef,
        ObjBuffer: LLVMMemoryBufferRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcObjectLayerAddObjectFileWithRT
            .as_ref()
            .expect("Expected function, got error."))(ObjLayer, RT, ObjBuffer)
    }
    #[doc = " Emit an object buffer to an ObjectLayer.\n\n Ownership of the responsibility object and object buffer pass to this\n function. The client is not responsible for cleanup."]
    pub unsafe fn LLVMOrcObjectLayerEmit(
        &self,
        ObjLayer: LLVMOrcObjectLayerRef,
        R: LLVMOrcMaterializationResponsibilityRef,
        ObjBuffer: LLVMMemoryBufferRef,
    ) {
        (self
            .LLVMOrcObjectLayerEmit
            .as_ref()
            .expect("Expected function, got error."))(ObjLayer, R, ObjBuffer)
    }
    #[doc = " Dispose of an ObjectLayer."]
    pub unsafe fn LLVMOrcDisposeObjectLayer(&self, ObjLayer: LLVMOrcObjectLayerRef) {
        (self
            .LLVMOrcDisposeObjectLayer
            .as_ref()
            .expect("Expected function, got error."))(ObjLayer)
    }
    pub unsafe fn LLVMOrcIRTransformLayerEmit(
        &self,
        IRTransformLayer: LLVMOrcIRTransformLayerRef,
        MR: LLVMOrcMaterializationResponsibilityRef,
        TSM: LLVMOrcThreadSafeModuleRef,
    ) {
        (self
            .LLVMOrcIRTransformLayerEmit
            .as_ref()
            .expect("Expected function, got error."))(IRTransformLayer, MR, TSM)
    }
    #[doc = " Set the transform function of the provided transform layer, passing through a\n pointer to user provided context."]
    pub unsafe fn LLVMOrcIRTransformLayerSetTransform(
        &self,
        IRTransformLayer: LLVMOrcIRTransformLayerRef,
        TransformFunction: LLVMOrcIRTransformLayerTransformFunction,
        Ctx: *mut ::std::os::raw::c_void,
    ) {
        (self
            .LLVMOrcIRTransformLayerSetTransform
            .as_ref()
            .expect("Expected function, got error."))(
            IRTransformLayer, TransformFunction, Ctx
        )
    }
    #[doc = " Set the transform function on an LLVMOrcObjectTransformLayer."]
    pub unsafe fn LLVMOrcObjectTransformLayerSetTransform(
        &self,
        ObjTransformLayer: LLVMOrcObjectTransformLayerRef,
        TransformFunction: LLVMOrcObjectTransformLayerTransformFunction,
        Ctx: *mut ::std::os::raw::c_void,
    ) {
        (self
            .LLVMOrcObjectTransformLayerSetTransform
            .as_ref()
            .expect("Expected function, got error."))(
            ObjTransformLayer, TransformFunction, Ctx
        )
    }
    #[doc = " Create a LocalIndirectStubsManager from the given target triple.\n\n The resulting IndirectStubsManager is owned by the client\n and must be disposed of by calling LLVMOrcDisposeDisposeIndirectStubsManager."]
    pub unsafe fn LLVMOrcCreateLocalIndirectStubsManager(
        &self,
        TargetTriple: *const ::std::os::raw::c_char,
    ) -> LLVMOrcIndirectStubsManagerRef {
        (self
            .LLVMOrcCreateLocalIndirectStubsManager
            .as_ref()
            .expect("Expected function, got error."))(TargetTriple)
    }
    #[doc = " Dispose of an IndirectStubsManager."]
    pub unsafe fn LLVMOrcDisposeIndirectStubsManager(&self, ISM: LLVMOrcIndirectStubsManagerRef) {
        (self
            .LLVMOrcDisposeIndirectStubsManager
            .as_ref()
            .expect("Expected function, got error."))(ISM)
    }
    pub unsafe fn LLVMOrcCreateLocalLazyCallThroughManager(
        &self,
        TargetTriple: *const ::std::os::raw::c_char,
        ES: LLVMOrcExecutionSessionRef,
        ErrorHandlerAddr: LLVMOrcJITTargetAddress,
        LCTM: *mut LLVMOrcLazyCallThroughManagerRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcCreateLocalLazyCallThroughManager
            .as_ref()
            .expect("Expected function, got error."))(
            TargetTriple, ES, ErrorHandlerAddr, LCTM
        )
    }
    #[doc = " Dispose of an LazyCallThroughManager."]
    pub unsafe fn LLVMOrcDisposeLazyCallThroughManager(
        &self,
        LCTM: LLVMOrcLazyCallThroughManagerRef,
    ) {
        (self
            .LLVMOrcDisposeLazyCallThroughManager
            .as_ref()
            .expect("Expected function, got error."))(LCTM)
    }
    #[doc = " Create a DumpObjects instance.\n\n DumpDir specifies the path to write dumped objects to. DumpDir may be empty\n in which case files will be dumped to the working directory.\n\n IdentifierOverride specifies a file name stem to use when dumping objects.\n If empty then each MemoryBuffer's identifier will be used (with a .o suffix\n added if not already present). If an identifier override is supplied it will\n be used instead, along with an incrementing counter (since all buffers will\n use the same identifier, the resulting files will be named <ident>.o,\n <ident>.2.o, <ident>.3.o, and so on). IdentifierOverride should not contain\n an extension, as a .o suffix will be added by DumpObjects."]
    pub unsafe fn LLVMOrcCreateDumpObjects(
        &self,
        DumpDir: *const ::std::os::raw::c_char,
        IdentifierOverride: *const ::std::os::raw::c_char,
    ) -> LLVMOrcDumpObjectsRef {
        (self
            .LLVMOrcCreateDumpObjects
            .as_ref()
            .expect("Expected function, got error."))(DumpDir, IdentifierOverride)
    }
    #[doc = " Dispose of a DumpObjects instance."]
    pub unsafe fn LLVMOrcDisposeDumpObjects(&self, DumpObjects: LLVMOrcDumpObjectsRef) {
        (self
            .LLVMOrcDisposeDumpObjects
            .as_ref()
            .expect("Expected function, got error."))(DumpObjects)
    }
    #[doc = " Dump the contents of the given MemoryBuffer."]
    pub unsafe fn LLVMOrcDumpObjects_CallOperator(
        &self,
        DumpObjects: LLVMOrcDumpObjectsRef,
        ObjBuffer: *mut LLVMMemoryBufferRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcDumpObjects_CallOperator
            .as_ref()
            .expect("Expected function, got error."))(DumpObjects, ObjBuffer)
    }
    #[doc = " Create an LLVMOrcLLJITBuilder.\n\n The client owns the resulting LLJITBuilder and should dispose of it using\n LLVMOrcDisposeLLJITBuilder once they are done with it."]
    pub unsafe fn LLVMOrcCreateLLJITBuilder(&self) -> LLVMOrcLLJITBuilderRef {
        (self
            .LLVMOrcCreateLLJITBuilder
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " Dispose of an LLVMOrcLLJITBuilderRef. This should only be called if ownership\n has not been passed to LLVMOrcCreateLLJIT (e.g. because some error prevented\n that function from being called)."]
    pub unsafe fn LLVMOrcDisposeLLJITBuilder(&self, Builder: LLVMOrcLLJITBuilderRef) {
        (self
            .LLVMOrcDisposeLLJITBuilder
            .as_ref()
            .expect("Expected function, got error."))(Builder)
    }
    #[doc = " Set the JITTargetMachineBuilder to be used when constructing the LLJIT\n instance. Calling this function is optional: if it is not called then the\n LLJITBuilder will use JITTargeTMachineBuilder::detectHost to construct a\n JITTargetMachineBuilder.\n\n This function takes ownership of the JTMB argument: clients should not\n dispose of the JITTargetMachineBuilder after calling this function."]
    pub unsafe fn LLVMOrcLLJITBuilderSetJITTargetMachineBuilder(
        &self,
        Builder: LLVMOrcLLJITBuilderRef,
        JTMB: LLVMOrcJITTargetMachineBuilderRef,
    ) {
        (self
            .LLVMOrcLLJITBuilderSetJITTargetMachineBuilder
            .as_ref()
            .expect("Expected function, got error."))(Builder, JTMB)
    }
    #[doc = " Set an ObjectLinkingLayer creator function for this LLJIT instance."]
    pub unsafe fn LLVMOrcLLJITBuilderSetObjectLinkingLayerCreator(
        &self,
        Builder: LLVMOrcLLJITBuilderRef,
        F: LLVMOrcLLJITBuilderObjectLinkingLayerCreatorFunction,
        Ctx: *mut ::std::os::raw::c_void,
    ) {
        (self
            .LLVMOrcLLJITBuilderSetObjectLinkingLayerCreator
            .as_ref()
            .expect("Expected function, got error."))(Builder, F, Ctx)
    }
    #[doc = " Create an LLJIT instance from an LLJITBuilder.\n\n This operation takes ownership of the Builder argument: clients should not\n dispose of the builder after calling this function (even if the function\n returns an error). If a null Builder argument is provided then a\n default-constructed LLJITBuilder will be used.\n\n On success the resulting LLJIT instance is uniquely owned by the client and\n automatically manages the memory of all JIT'd code and all modules that are\n transferred to it (e.g. via LLVMOrcLLJITAddLLVMIRModule). Disposing of the\n LLJIT instance will free all memory managed by the JIT, including JIT'd code\n and not-yet compiled modules."]
    pub unsafe fn LLVMOrcCreateLLJIT(
        &self,
        Result: *mut LLVMOrcLLJITRef,
        Builder: LLVMOrcLLJITBuilderRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcCreateLLJIT
            .as_ref()
            .expect("Expected function, got error."))(Result, Builder)
    }
    #[doc = " Dispose of an LLJIT instance."]
    pub unsafe fn LLVMOrcDisposeLLJIT(&self, J: LLVMOrcLLJITRef) -> LLVMErrorRef {
        (self
            .LLVMOrcDisposeLLJIT
            .as_ref()
            .expect("Expected function, got error."))(J)
    }
    #[doc = " Get a reference to the ExecutionSession for this LLJIT instance.\n\n The ExecutionSession is owned by the LLJIT instance. The client is not\n responsible for managing its memory."]
    pub unsafe fn LLVMOrcLLJITGetExecutionSession(
        &self,
        J: LLVMOrcLLJITRef,
    ) -> LLVMOrcExecutionSessionRef {
        (self
            .LLVMOrcLLJITGetExecutionSession
            .as_ref()
            .expect("Expected function, got error."))(J)
    }
    #[doc = " Return a reference to the Main JITDylib.\n\n The JITDylib is owned by the LLJIT instance. The client is not responsible\n for managing its memory."]
    pub unsafe fn LLVMOrcLLJITGetMainJITDylib(&self, J: LLVMOrcLLJITRef) -> LLVMOrcJITDylibRef {
        (self
            .LLVMOrcLLJITGetMainJITDylib
            .as_ref()
            .expect("Expected function, got error."))(J)
    }
    #[doc = " Return the target triple for this LLJIT instance. This string is owned by\n the LLJIT instance and should not be freed by the client."]
    pub unsafe fn LLVMOrcLLJITGetTripleString(
        &self,
        J: LLVMOrcLLJITRef,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMOrcLLJITGetTripleString
            .as_ref()
            .expect("Expected function, got error."))(J)
    }
    #[doc = " Returns the global prefix character according to the LLJIT's DataLayout."]
    pub unsafe fn LLVMOrcLLJITGetGlobalPrefix(&self, J: LLVMOrcLLJITRef) -> ::std::os::raw::c_char {
        (self
            .LLVMOrcLLJITGetGlobalPrefix
            .as_ref()
            .expect("Expected function, got error."))(J)
    }
    #[doc = " Mangles the given string according to the LLJIT instance's DataLayout, then\n interns the result in the SymbolStringPool and returns a reference to the\n pool entry. Clients should call LLVMOrcReleaseSymbolStringPoolEntry to\n decrement the ref-count on the pool entry once they are finished with this\n value."]
    pub unsafe fn LLVMOrcLLJITMangleAndIntern(
        &self,
        J: LLVMOrcLLJITRef,
        UnmangledName: *const ::std::os::raw::c_char,
    ) -> LLVMOrcSymbolStringPoolEntryRef {
        (self
            .LLVMOrcLLJITMangleAndIntern
            .as_ref()
            .expect("Expected function, got error."))(J, UnmangledName)
    }
    #[doc = " Add a buffer representing an object file to the given JITDylib in the given\n LLJIT instance. This operation transfers ownership of the buffer to the\n LLJIT instance. The buffer should not be disposed of or referenced once this\n function returns.\n\n Resources associated with the given object will be tracked by the given\n JITDylib's default resource tracker."]
    pub unsafe fn LLVMOrcLLJITAddObjectFile(
        &self,
        J: LLVMOrcLLJITRef,
        JD: LLVMOrcJITDylibRef,
        ObjBuffer: LLVMMemoryBufferRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcLLJITAddObjectFile
            .as_ref()
            .expect("Expected function, got error."))(J, JD, ObjBuffer)
    }
    #[doc = " Add a buffer representing an object file to the given ResourceTracker's\n JITDylib in the given LLJIT instance. This operation transfers ownership of\n the buffer to the LLJIT instance. The buffer should not be disposed of or\n referenced once this function returns.\n\n Resources associated with the given object will be tracked by ResourceTracker\n RT."]
    pub unsafe fn LLVMOrcLLJITAddObjectFileWithRT(
        &self,
        J: LLVMOrcLLJITRef,
        RT: LLVMOrcResourceTrackerRef,
        ObjBuffer: LLVMMemoryBufferRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcLLJITAddObjectFileWithRT
            .as_ref()
            .expect("Expected function, got error."))(J, RT, ObjBuffer)
    }
    #[doc = " Add an IR module to the given JITDylib in the given LLJIT instance. This\n operation transfers ownership of the TSM argument to the LLJIT instance.\n The TSM argument should not be disposed of or referenced once this\n function returns.\n\n Resources associated with the given Module will be tracked by the given\n JITDylib's default resource tracker."]
    pub unsafe fn LLVMOrcLLJITAddLLVMIRModule(
        &self,
        J: LLVMOrcLLJITRef,
        JD: LLVMOrcJITDylibRef,
        TSM: LLVMOrcThreadSafeModuleRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcLLJITAddLLVMIRModule
            .as_ref()
            .expect("Expected function, got error."))(J, JD, TSM)
    }
    #[doc = " Add an IR module to the given ResourceTracker's JITDylib in the given LLJIT\n instance. This operation transfers ownership of the TSM argument to the LLJIT\n instance. The TSM argument should not be disposed of or referenced once this\n function returns.\n\n Resources associated with the given Module will be tracked by ResourceTracker\n RT."]
    pub unsafe fn LLVMOrcLLJITAddLLVMIRModuleWithRT(
        &self,
        J: LLVMOrcLLJITRef,
        JD: LLVMOrcResourceTrackerRef,
        TSM: LLVMOrcThreadSafeModuleRef,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcLLJITAddLLVMIRModuleWithRT
            .as_ref()
            .expect("Expected function, got error."))(J, JD, TSM)
    }
    #[doc = " Look up the given symbol in the main JITDylib of the given LLJIT instance.\n\n This operation does not take ownership of the Name argument."]
    pub unsafe fn LLVMOrcLLJITLookup(
        &self,
        J: LLVMOrcLLJITRef,
        Result: *mut LLVMOrcExecutorAddress,
        Name: *const ::std::os::raw::c_char,
    ) -> LLVMErrorRef {
        (self
            .LLVMOrcLLJITLookup
            .as_ref()
            .expect("Expected function, got error."))(J, Result, Name)
    }
    #[doc = " Returns a non-owning reference to the LLJIT instance's object linking layer."]
    pub unsafe fn LLVMOrcLLJITGetObjLinkingLayer(
        &self,
        J: LLVMOrcLLJITRef,
    ) -> LLVMOrcObjectLayerRef {
        (self
            .LLVMOrcLLJITGetObjLinkingLayer
            .as_ref()
            .expect("Expected function, got error."))(J)
    }
    #[doc = " Returns a non-owning reference to the LLJIT instance's object linking layer."]
    pub unsafe fn LLVMOrcLLJITGetObjTransformLayer(
        &self,
        J: LLVMOrcLLJITRef,
    ) -> LLVMOrcObjectTransformLayerRef {
        (self
            .LLVMOrcLLJITGetObjTransformLayer
            .as_ref()
            .expect("Expected function, got error."))(J)
    }
    #[doc = " Returns a non-owning reference to the LLJIT instance's IR transform layer."]
    pub unsafe fn LLVMOrcLLJITGetIRTransformLayer(
        &self,
        J: LLVMOrcLLJITRef,
    ) -> LLVMOrcIRTransformLayerRef {
        (self
            .LLVMOrcLLJITGetIRTransformLayer
            .as_ref()
            .expect("Expected function, got error."))(J)
    }
    #[doc = " Get the LLJIT instance's default data layout string.\n\n This string is owned by the LLJIT instance and does not need to be freed\n by the caller."]
    pub unsafe fn LLVMOrcLLJITGetDataLayoutStr(
        &self,
        J: LLVMOrcLLJITRef,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMOrcLLJITGetDataLayoutStr
            .as_ref()
            .expect("Expected function, got error."))(J)
    }
    #[doc = " Create a binary file from the given memory buffer.\n\n The exact type of the binary file will be inferred automatically, and the\n appropriate implementation selected.  The context may be NULL except if\n the resulting file is an LLVM IR file.\n\n The memory buffer is not consumed by this function.  It is the responsibilty\n of the caller to free it with \\c LLVMDisposeMemoryBuffer.\n\n If NULL is returned, the \\p ErrorMessage parameter is populated with the\n error's description.  It is then the caller's responsibility to free this\n message by calling \\c LLVMDisposeMessage.\n\n @see llvm::object::createBinary"]
    pub unsafe fn LLVMCreateBinary(
        &self,
        MemBuf: LLVMMemoryBufferRef,
        Context: LLVMContextRef,
        ErrorMessage: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBinaryRef {
        (self
            .LLVMCreateBinary
            .as_ref()
            .expect("Expected function, got error."))(MemBuf, Context, ErrorMessage)
    }
    #[doc = " Dispose of a binary file.\n\n The binary file does not own its backing buffer.  It is the responsibilty\n of the caller to free it with \\c LLVMDisposeMemoryBuffer."]
    pub unsafe fn LLVMDisposeBinary(&self, BR: LLVMBinaryRef) {
        (self
            .LLVMDisposeBinary
            .as_ref()
            .expect("Expected function, got error."))(BR)
    }
    #[doc = " Retrieves a copy of the memory buffer associated with this object file.\n\n The returned buffer is merely a shallow copy and does not own the actual\n backing buffer of the binary. Nevertheless, it is the responsibility of the\n caller to free it with \\c LLVMDisposeMemoryBuffer.\n\n @see llvm::object::getMemoryBufferRef"]
    pub unsafe fn LLVMBinaryCopyMemoryBuffer(&self, BR: LLVMBinaryRef) -> LLVMMemoryBufferRef {
        (self
            .LLVMBinaryCopyMemoryBuffer
            .as_ref()
            .expect("Expected function, got error."))(BR)
    }
    #[doc = " Retrieve the specific type of a binary.\n\n @see llvm::object::Binary::getType"]
    pub unsafe fn LLVMBinaryGetType(&self, BR: LLVMBinaryRef) -> LLVMBinaryType {
        (self
            .LLVMBinaryGetType
            .as_ref()
            .expect("Expected function, got error."))(BR)
    }
    pub unsafe fn LLVMMachOUniversalBinaryCopyObjectForArch(
        &self,
        BR: LLVMBinaryRef,
        Arch: *const ::std::os::raw::c_char,
        ArchLen: usize,
        ErrorMessage: *mut *mut ::std::os::raw::c_char,
    ) -> LLVMBinaryRef {
        (self
            .LLVMMachOUniversalBinaryCopyObjectForArch
            .as_ref()
            .expect("Expected function, got error."))(BR, Arch, ArchLen, ErrorMessage)
    }
    #[doc = " Retrieve a copy of the section iterator for this object file.\n\n If there are no sections, the result is NULL.\n\n The returned iterator is merely a shallow copy. Nevertheless, it is\n the responsibility of the caller to free it with\n \\c LLVMDisposeSectionIterator.\n\n @see llvm::object::sections()"]
    pub unsafe fn LLVMObjectFileCopySectionIterator(
        &self,
        BR: LLVMBinaryRef,
    ) -> LLVMSectionIteratorRef {
        (self
            .LLVMObjectFileCopySectionIterator
            .as_ref()
            .expect("Expected function, got error."))(BR)
    }
    #[doc = " Returns whether the given section iterator is at the end.\n\n @see llvm::object::section_end"]
    pub unsafe fn LLVMObjectFileIsSectionIteratorAtEnd(
        &self,
        BR: LLVMBinaryRef,
        SI: LLVMSectionIteratorRef,
    ) -> LLVMBool {
        (self
            .LLVMObjectFileIsSectionIteratorAtEnd
            .as_ref()
            .expect("Expected function, got error."))(BR, SI)
    }
    #[doc = " Retrieve a copy of the symbol iterator for this object file.\n\n If there are no symbols, the result is NULL.\n\n The returned iterator is merely a shallow copy. Nevertheless, it is\n the responsibility of the caller to free it with\n \\c LLVMDisposeSymbolIterator.\n\n @see llvm::object::symbols()"]
    pub unsafe fn LLVMObjectFileCopySymbolIterator(
        &self,
        BR: LLVMBinaryRef,
    ) -> LLVMSymbolIteratorRef {
        (self
            .LLVMObjectFileCopySymbolIterator
            .as_ref()
            .expect("Expected function, got error."))(BR)
    }
    #[doc = " Returns whether the given symbol iterator is at the end.\n\n @see llvm::object::symbol_end"]
    pub unsafe fn LLVMObjectFileIsSymbolIteratorAtEnd(
        &self,
        BR: LLVMBinaryRef,
        SI: LLVMSymbolIteratorRef,
    ) -> LLVMBool {
        (self
            .LLVMObjectFileIsSymbolIteratorAtEnd
            .as_ref()
            .expect("Expected function, got error."))(BR, SI)
    }
    pub unsafe fn LLVMDisposeSectionIterator(&self, SI: LLVMSectionIteratorRef) {
        (self
            .LLVMDisposeSectionIterator
            .as_ref()
            .expect("Expected function, got error."))(SI)
    }
    pub unsafe fn LLVMMoveToNextSection(&self, SI: LLVMSectionIteratorRef) {
        (self
            .LLVMMoveToNextSection
            .as_ref()
            .expect("Expected function, got error."))(SI)
    }
    pub unsafe fn LLVMMoveToContainingSection(
        &self,
        Sect: LLVMSectionIteratorRef,
        Sym: LLVMSymbolIteratorRef,
    ) {
        (self
            .LLVMMoveToContainingSection
            .as_ref()
            .expect("Expected function, got error."))(Sect, Sym)
    }
    pub unsafe fn LLVMDisposeSymbolIterator(&self, SI: LLVMSymbolIteratorRef) {
        (self
            .LLVMDisposeSymbolIterator
            .as_ref()
            .expect("Expected function, got error."))(SI)
    }
    pub unsafe fn LLVMMoveToNextSymbol(&self, SI: LLVMSymbolIteratorRef) {
        (self
            .LLVMMoveToNextSymbol
            .as_ref()
            .expect("Expected function, got error."))(SI)
    }
    pub unsafe fn LLVMGetSectionName(
        &self,
        SI: LLVMSectionIteratorRef,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetSectionName
            .as_ref()
            .expect("Expected function, got error."))(SI)
    }
    pub unsafe fn LLVMGetSectionSize(&self, SI: LLVMSectionIteratorRef) -> u64 {
        (self
            .LLVMGetSectionSize
            .as_ref()
            .expect("Expected function, got error."))(SI)
    }
    pub unsafe fn LLVMGetSectionContents(
        &self,
        SI: LLVMSectionIteratorRef,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetSectionContents
            .as_ref()
            .expect("Expected function, got error."))(SI)
    }
    pub unsafe fn LLVMGetSectionAddress(&self, SI: LLVMSectionIteratorRef) -> u64 {
        (self
            .LLVMGetSectionAddress
            .as_ref()
            .expect("Expected function, got error."))(SI)
    }
    pub unsafe fn LLVMGetSectionContainsSymbol(
        &self,
        SI: LLVMSectionIteratorRef,
        Sym: LLVMSymbolIteratorRef,
    ) -> LLVMBool {
        (self
            .LLVMGetSectionContainsSymbol
            .as_ref()
            .expect("Expected function, got error."))(SI, Sym)
    }
    pub unsafe fn LLVMGetRelocations(
        &self,
        Section: LLVMSectionIteratorRef,
    ) -> LLVMRelocationIteratorRef {
        (self
            .LLVMGetRelocations
            .as_ref()
            .expect("Expected function, got error."))(Section)
    }
    pub unsafe fn LLVMDisposeRelocationIterator(&self, RI: LLVMRelocationIteratorRef) {
        (self
            .LLVMDisposeRelocationIterator
            .as_ref()
            .expect("Expected function, got error."))(RI)
    }
    pub unsafe fn LLVMIsRelocationIteratorAtEnd(
        &self,
        Section: LLVMSectionIteratorRef,
        RI: LLVMRelocationIteratorRef,
    ) -> LLVMBool {
        (self
            .LLVMIsRelocationIteratorAtEnd
            .as_ref()
            .expect("Expected function, got error."))(Section, RI)
    }
    pub unsafe fn LLVMMoveToNextRelocation(&self, RI: LLVMRelocationIteratorRef) {
        (self
            .LLVMMoveToNextRelocation
            .as_ref()
            .expect("Expected function, got error."))(RI)
    }
    pub unsafe fn LLVMGetSymbolName(
        &self,
        SI: LLVMSymbolIteratorRef,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetSymbolName
            .as_ref()
            .expect("Expected function, got error."))(SI)
    }
    pub unsafe fn LLVMGetSymbolAddress(&self, SI: LLVMSymbolIteratorRef) -> u64 {
        (self
            .LLVMGetSymbolAddress
            .as_ref()
            .expect("Expected function, got error."))(SI)
    }
    pub unsafe fn LLVMGetSymbolSize(&self, SI: LLVMSymbolIteratorRef) -> u64 {
        (self
            .LLVMGetSymbolSize
            .as_ref()
            .expect("Expected function, got error."))(SI)
    }
    pub unsafe fn LLVMGetRelocationOffset(&self, RI: LLVMRelocationIteratorRef) -> u64 {
        (self
            .LLVMGetRelocationOffset
            .as_ref()
            .expect("Expected function, got error."))(RI)
    }
    pub unsafe fn LLVMGetRelocationSymbol(
        &self,
        RI: LLVMRelocationIteratorRef,
    ) -> LLVMSymbolIteratorRef {
        (self
            .LLVMGetRelocationSymbol
            .as_ref()
            .expect("Expected function, got error."))(RI)
    }
    pub unsafe fn LLVMGetRelocationType(&self, RI: LLVMRelocationIteratorRef) -> u64 {
        (self
            .LLVMGetRelocationType
            .as_ref()
            .expect("Expected function, got error."))(RI)
    }
    pub unsafe fn LLVMGetRelocationTypeName(
        &self,
        RI: LLVMRelocationIteratorRef,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetRelocationTypeName
            .as_ref()
            .expect("Expected function, got error."))(RI)
    }
    pub unsafe fn LLVMGetRelocationValueString(
        &self,
        RI: LLVMRelocationIteratorRef,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMGetRelocationValueString
            .as_ref()
            .expect("Expected function, got error."))(RI)
    }
    #[doc = " Deprecated: Use LLVMCreateBinary instead."]
    pub unsafe fn LLVMCreateObjectFile(&self, MemBuf: LLVMMemoryBufferRef) -> LLVMObjectFileRef {
        (self
            .LLVMCreateObjectFile
            .as_ref()
            .expect("Expected function, got error."))(MemBuf)
    }
    #[doc = " Deprecated: Use LLVMDisposeBinary instead."]
    pub unsafe fn LLVMDisposeObjectFile(&self, ObjectFile: LLVMObjectFileRef) {
        (self
            .LLVMDisposeObjectFile
            .as_ref()
            .expect("Expected function, got error."))(ObjectFile)
    }
    #[doc = " Deprecated: Use LLVMObjectFileCopySectionIterator instead."]
    pub unsafe fn LLVMGetSections(&self, ObjectFile: LLVMObjectFileRef) -> LLVMSectionIteratorRef {
        (self
            .LLVMGetSections
            .as_ref()
            .expect("Expected function, got error."))(ObjectFile)
    }
    #[doc = " Deprecated: Use LLVMObjectFileIsSectionIteratorAtEnd instead."]
    pub unsafe fn LLVMIsSectionIteratorAtEnd(
        &self,
        ObjectFile: LLVMObjectFileRef,
        SI: LLVMSectionIteratorRef,
    ) -> LLVMBool {
        (self
            .LLVMIsSectionIteratorAtEnd
            .as_ref()
            .expect("Expected function, got error."))(ObjectFile, SI)
    }
    #[doc = " Deprecated: Use LLVMObjectFileCopySymbolIterator instead."]
    pub unsafe fn LLVMGetSymbols(&self, ObjectFile: LLVMObjectFileRef) -> LLVMSymbolIteratorRef {
        (self
            .LLVMGetSymbols
            .as_ref()
            .expect("Expected function, got error."))(ObjectFile)
    }
    #[doc = " Deprecated: Use LLVMObjectFileIsSymbolIteratorAtEnd instead."]
    pub unsafe fn LLVMIsSymbolIteratorAtEnd(
        &self,
        ObjectFile: LLVMObjectFileRef,
        SI: LLVMSymbolIteratorRef,
    ) -> LLVMBool {
        (self
            .LLVMIsSymbolIteratorAtEnd
            .as_ref()
            .expect("Expected function, got error."))(ObjectFile, SI)
    }
    #[doc = " Create a RTDyldObjectLinkingLayer instance using the standard\n SectionMemoryManager for memory management."]
    pub unsafe fn LLVMOrcCreateRTDyldObjectLinkingLayerWithSectionMemoryManager(
        &self,
        ES: LLVMOrcExecutionSessionRef,
    ) -> LLVMOrcObjectLayerRef {
        (self
            .LLVMOrcCreateRTDyldObjectLinkingLayerWithSectionMemoryManager
            .as_ref()
            .expect("Expected function, got error."))(ES)
    }
    #[doc = " Create a RTDyldObjectLinkingLayer instance using MCJIT-memory-manager-like\n callbacks.\n\n This is intended to simplify transitions for existing MCJIT clients. The\n callbacks used are similar (but not identical) to the callbacks for\n LLVMCreateSimpleMCJITMemoryManager: Unlike MCJIT, RTDyldObjectLinkingLayer\n will create a new memory manager for each object linked by calling the given\n CreateContext callback. This allows for code removal by destroying each\n allocator individually. Every allocator will be destroyed (if it has not been\n already) at RTDyldObjectLinkingLayer destruction time, and the\n NotifyTerminating callback will be called to indicate that no further\n allocation contexts will be created.\n\n To implement MCJIT-like behavior clients can implement CreateContext,\n NotifyTerminating, and Destroy as:\n\n   void *CreateContext(void *CtxCtx) { return CtxCtx; }\n   void NotifyTerminating(void *CtxCtx) { MyOriginalDestroy(CtxCtx); }\n   void Destroy(void *Ctx) { }\n\n This scheme simply reuses the CreateContextCtx pointer as the one-and-only\n allocation context."]
    pub unsafe fn LLVMOrcCreateRTDyldObjectLinkingLayerWithMCJITMemoryManagerLikeCallbacks(
        &self,
        ES: LLVMOrcExecutionSessionRef,
        CreateContextCtx: *mut ::std::os::raw::c_void,
        CreateContext: LLVMMemoryManagerCreateContextCallback,
        NotifyTerminating: LLVMMemoryManagerNotifyTerminatingCallback,
        AllocateCodeSection: LLVMMemoryManagerAllocateCodeSectionCallback,
        AllocateDataSection: LLVMMemoryManagerAllocateDataSectionCallback,
        FinalizeMemory: LLVMMemoryManagerFinalizeMemoryCallback,
        Destroy: LLVMMemoryManagerDestroyCallback,
    ) -> LLVMOrcObjectLayerRef {
        (self
            .LLVMOrcCreateRTDyldObjectLinkingLayerWithMCJITMemoryManagerLikeCallbacks
            .as_ref()
            .expect("Expected function, got error."))(
            ES,
            CreateContextCtx,
            CreateContext,
            NotifyTerminating,
            AllocateCodeSection,
            AllocateDataSection,
            FinalizeMemory,
            Destroy,
        )
    }
    #[doc = " Add the given listener to the given RTDyldObjectLinkingLayer.\n\n Note: Layer must be an RTDyldObjectLinkingLayer instance or\n behavior is undefined."]
    pub unsafe fn LLVMOrcRTDyldObjectLinkingLayerRegisterJITEventListener(
        &self,
        RTDyldObjLinkingLayer: LLVMOrcObjectLayerRef,
        Listener: LLVMJITEventListenerRef,
    ) {
        (self
            .LLVMOrcRTDyldObjectLinkingLayerRegisterJITEventListener
            .as_ref()
            .expect("Expected function, got error."))(RTDyldObjLinkingLayer, Listener)
    }
    #[doc = " Returns the buffer holding the string.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkStringGetData(
        &self,
        String: LLVMRemarkStringRef,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMRemarkStringGetData
            .as_ref()
            .expect("Expected function, got error."))(String)
    }
    #[doc = " Returns the size of the string.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkStringGetLen(&self, String: LLVMRemarkStringRef) -> u32 {
        (self
            .LLVMRemarkStringGetLen
            .as_ref()
            .expect("Expected function, got error."))(String)
    }
    #[doc = " Return the path to the source file for a debug location.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkDebugLocGetSourceFilePath(
        &self,
        DL: LLVMRemarkDebugLocRef,
    ) -> LLVMRemarkStringRef {
        (self
            .LLVMRemarkDebugLocGetSourceFilePath
            .as_ref()
            .expect("Expected function, got error."))(DL)
    }
    #[doc = " Return the line in the source file for a debug location.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkDebugLocGetSourceLine(&self, DL: LLVMRemarkDebugLocRef) -> u32 {
        (self
            .LLVMRemarkDebugLocGetSourceLine
            .as_ref()
            .expect("Expected function, got error."))(DL)
    }
    #[doc = " Return the column in the source file for a debug location.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkDebugLocGetSourceColumn(&self, DL: LLVMRemarkDebugLocRef) -> u32 {
        (self
            .LLVMRemarkDebugLocGetSourceColumn
            .as_ref()
            .expect("Expected function, got error."))(DL)
    }
    #[doc = " Returns the key of an argument. The key defines what the value is, and the\n same key can appear multiple times in the list of arguments.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkArgGetKey(&self, Arg: LLVMRemarkArgRef) -> LLVMRemarkStringRef {
        (self
            .LLVMRemarkArgGetKey
            .as_ref()
            .expect("Expected function, got error."))(Arg)
    }
    #[doc = " Returns the value of an argument. This is a string that can contain newlines.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkArgGetValue(&self, Arg: LLVMRemarkArgRef) -> LLVMRemarkStringRef {
        (self
            .LLVMRemarkArgGetValue
            .as_ref()
            .expect("Expected function, got error."))(Arg)
    }
    #[doc = " Returns the debug location that is attached to the value of this argument.\n\n If there is no debug location, the return value will be `NULL`.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkArgGetDebugLoc(&self, Arg: LLVMRemarkArgRef) -> LLVMRemarkDebugLocRef {
        (self
            .LLVMRemarkArgGetDebugLoc
            .as_ref()
            .expect("Expected function, got error."))(Arg)
    }
    #[doc = " Free the resources used by the remark entry.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkEntryDispose(&self, Remark: LLVMRemarkEntryRef) {
        (self
            .LLVMRemarkEntryDispose
            .as_ref()
            .expect("Expected function, got error."))(Remark)
    }
    #[doc = " The type of the remark. For example, it can allow users to only keep the\n missed optimizations from the compiler.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkEntryGetType(&self, Remark: LLVMRemarkEntryRef) -> LLVMRemarkType {
        (self
            .LLVMRemarkEntryGetType
            .as_ref()
            .expect("Expected function, got error."))(Remark)
    }
    #[doc = " Get the name of the pass that emitted this remark.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkEntryGetPassName(
        &self,
        Remark: LLVMRemarkEntryRef,
    ) -> LLVMRemarkStringRef {
        (self
            .LLVMRemarkEntryGetPassName
            .as_ref()
            .expect("Expected function, got error."))(Remark)
    }
    #[doc = " Get an identifier of the remark.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkEntryGetRemarkName(
        &self,
        Remark: LLVMRemarkEntryRef,
    ) -> LLVMRemarkStringRef {
        (self
            .LLVMRemarkEntryGetRemarkName
            .as_ref()
            .expect("Expected function, got error."))(Remark)
    }
    #[doc = " Get the name of the function being processed when the remark was emitted.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkEntryGetFunctionName(
        &self,
        Remark: LLVMRemarkEntryRef,
    ) -> LLVMRemarkStringRef {
        (self
            .LLVMRemarkEntryGetFunctionName
            .as_ref()
            .expect("Expected function, got error."))(Remark)
    }
    #[doc = " Returns the debug location that is attached to this remark.\n\n If there is no debug location, the return value will be `NULL`.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkEntryGetDebugLoc(
        &self,
        Remark: LLVMRemarkEntryRef,
    ) -> LLVMRemarkDebugLocRef {
        (self
            .LLVMRemarkEntryGetDebugLoc
            .as_ref()
            .expect("Expected function, got error."))(Remark)
    }
    #[doc = " Return the hotness of the remark.\n\n A hotness of `0` means this value is not set.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkEntryGetHotness(&self, Remark: LLVMRemarkEntryRef) -> u64 {
        (self
            .LLVMRemarkEntryGetHotness
            .as_ref()
            .expect("Expected function, got error."))(Remark)
    }
    #[doc = " The number of arguments the remark holds.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkEntryGetNumArgs(&self, Remark: LLVMRemarkEntryRef) -> u32 {
        (self
            .LLVMRemarkEntryGetNumArgs
            .as_ref()
            .expect("Expected function, got error."))(Remark)
    }
    #[doc = " Get a new iterator to iterate over a remark's argument.\n\n If there are no arguments in \\p Remark, the return value will be `NULL`.\n\n The lifetime of the returned value is bound to the lifetime of \\p Remark.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkEntryGetFirstArg(
        &self,
        Remark: LLVMRemarkEntryRef,
    ) -> LLVMRemarkArgRef {
        (self
            .LLVMRemarkEntryGetFirstArg
            .as_ref()
            .expect("Expected function, got error."))(Remark)
    }
    #[doc = " Get the next argument in \\p Remark from the position of \\p It.\n\n Returns `NULL` if there are no more arguments available.\n\n The lifetime of the returned value is bound to the lifetime of \\p Remark.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkEntryGetNextArg(
        &self,
        It: LLVMRemarkArgRef,
        Remark: LLVMRemarkEntryRef,
    ) -> LLVMRemarkArgRef {
        (self
            .LLVMRemarkEntryGetNextArg
            .as_ref()
            .expect("Expected function, got error."))(It, Remark)
    }
    #[doc = " Creates a remark parser that can be used to parse the buffer located in \\p\n Buf of size \\p Size bytes.\n\n \\p Buf cannot be `NULL`.\n\n This function should be paired with LLVMRemarkParserDispose() to avoid\n leaking resources.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkParserCreateYAML(
        &self,
        Buf: *const ::std::os::raw::c_void,
        Size: u64,
    ) -> LLVMRemarkParserRef {
        (self
            .LLVMRemarkParserCreateYAML
            .as_ref()
            .expect("Expected function, got error."))(Buf, Size)
    }
    #[doc = " Creates a remark parser that can be used to parse the buffer located in \\p\n Buf of size \\p Size bytes.\n\n \\p Buf cannot be `NULL`.\n\n This function should be paired with LLVMRemarkParserDispose() to avoid\n leaking resources.\n\n \\since REMARKS_API_VERSION=1"]
    pub unsafe fn LLVMRemarkParserCreateBitstream(
        &self,
        Buf: *const ::std::os::raw::c_void,
        Size: u64,
    ) -> LLVMRemarkParserRef {
        (self
            .LLVMRemarkParserCreateBitstream
            .as_ref()
            .expect("Expected function, got error."))(Buf, Size)
    }
    #[doc = " Returns the next remark in the file.\n\n The value pointed to by the return value needs to be disposed using a call to\n LLVMRemarkEntryDispose().\n\n All the entries in the returned value that are of LLVMRemarkStringRef type\n will become invalidated once a call to LLVMRemarkParserDispose is made.\n\n If the parser reaches the end of the buffer, the return value will be `NULL`.\n\n In the case of an error, the return value will be `NULL`, and:\n\n 1) LLVMRemarkParserHasError() will return `1`.\n\n 2) LLVMRemarkParserGetErrorMessage() will return a descriptive error\n    message.\n\n An error may occur if:\n\n 1) An argument is invalid.\n\n 2) There is a parsing error. This can occur on things like malformed YAML.\n\n 3) There is a Remark semantic error. This can occur on well-formed files with\n    missing or extra fields.\n\n Here is a quick example of the usage:\n\n ```\n LLVMRemarkParserRef Parser = LLVMRemarkParserCreateYAML(Buf, Size);\n LLVMRemarkEntryRef Remark = NULL;\n while ((Remark = LLVMRemarkParserGetNext(Parser))) {\n    // use Remark\n    LLVMRemarkEntryDispose(Remark); // Release memory.\n }\n bool HasError = LLVMRemarkParserHasError(Parser);\n LLVMRemarkParserDispose(Parser);\n ```\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkParserGetNext(
        &self,
        Parser: LLVMRemarkParserRef,
    ) -> LLVMRemarkEntryRef {
        (self
            .LLVMRemarkParserGetNext
            .as_ref()
            .expect("Expected function, got error."))(Parser)
    }
    #[doc = " Returns `1` if the parser encountered an error while parsing the buffer.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkParserHasError(&self, Parser: LLVMRemarkParserRef) -> LLVMBool {
        (self
            .LLVMRemarkParserHasError
            .as_ref()
            .expect("Expected function, got error."))(Parser)
    }
    #[doc = " Returns a null-terminated string containing an error message.\n\n In case of no error, the result is `NULL`.\n\n The memory of the string is bound to the lifetime of \\p Parser. If\n LLVMRemarkParserDispose() is called, the memory of the string will be\n released.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkParserGetErrorMessage(
        &self,
        Parser: LLVMRemarkParserRef,
    ) -> *const ::std::os::raw::c_char {
        (self
            .LLVMRemarkParserGetErrorMessage
            .as_ref()
            .expect("Expected function, got error."))(Parser)
    }
    #[doc = " Releases all the resources used by \\p Parser.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkParserDispose(&self, Parser: LLVMRemarkParserRef) {
        (self
            .LLVMRemarkParserDispose
            .as_ref()
            .expect("Expected function, got error."))(Parser)
    }
    #[doc = " Returns the version of the remarks library.\n\n \\since REMARKS_API_VERSION=0"]
    pub unsafe fn LLVMRemarkVersion(&self) -> u32 {
        (self
            .LLVMRemarkVersion
            .as_ref()
            .expect("Expected function, got error."))()
    }
    #[doc = " This function permanently loads the dynamic library at the given path.\n It is safe to call this function multiple times for the same library.\n\n @see sys::DynamicLibrary::LoadLibraryPermanently()"]
    pub unsafe fn LLVMLoadLibraryPermanently(
        &self,
        Filename: *const ::std::os::raw::c_char,
    ) -> LLVMBool {
        (self
            .LLVMLoadLibraryPermanently
            .as_ref()
            .expect("Expected function, got error."))(Filename)
    }
    #[doc = " This function parses the given arguments using the LLVM command line parser.\n Note that the only stable thing about this function is its signature; you\n cannot rely on any particular set of command line arguments being interpreted\n the same way across LLVM versions.\n\n @see llvm::cl::ParseCommandLineOptions()"]
    pub unsafe fn LLVMParseCommandLineOptions(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *const *const ::std::os::raw::c_char,
        Overview: *const ::std::os::raw::c_char,
    ) {
        (self
            .LLVMParseCommandLineOptions
            .as_ref()
            .expect("Expected function, got error."))(argc, argv, Overview)
    }
    #[doc = " This function will search through all previously loaded dynamic\n libraries for the symbol \\p symbolName. If it is found, the address of\n that symbol is returned. If not, null is returned.\n\n @see sys::DynamicLibrary::SearchForAddressOfSymbol()"]
    pub unsafe fn LLVMSearchForAddressOfSymbol(
        &self,
        symbolName: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        (self
            .LLVMSearchForAddressOfSymbol
            .as_ref()
            .expect("Expected function, got error."))(symbolName)
    }
    #[doc = " This functions permanently adds the symbol \\p symbolName with the\n value \\p symbolValue.  These symbols are searched before any\n libraries.\n\n @see sys::DynamicLibrary::AddSymbol()"]
    pub unsafe fn LLVMAddSymbol(
        &self,
        symbolName: *const ::std::os::raw::c_char,
        symbolValue: *mut ::std::os::raw::c_void,
    ) {
        (self
            .LLVMAddSymbol
            .as_ref()
            .expect("Expected function, got error."))(symbolName, symbolValue)
    }
}
